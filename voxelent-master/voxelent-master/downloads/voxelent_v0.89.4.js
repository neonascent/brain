/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   
try{
    if (!jQuery){
    	alert('Voxelent: jQuery is not loaded. Please include JQuery in your page');	
    }
}catch(e){
    alert('Voxelent: jQuery is not loaded. Please include JQuery in your page');
}


/**
* <p>Contains all the constants and default variables used by Voxelent.</p> 
* 
* <p> These properties aregrouped into sub namespaces. 
* The <code>vxl.c</code> namespace covers all the 'current' objects such as the 
* <i>current view</i> and the <i>current scene</i>.</p>
* <p>The <code>vxl.def</code> namespace contains all the definitions and default values for 
* voxelent's global parameters</p> 
* <p>The <code>vxl.events</code> namespace contains all the events used in Voxelent</p>
* <p>The <code>vxl.go</code> namespace contains all the 'global' objects. These are objects that
* can be accessed from any context in a Voxelent program</p>
* <p>The <code>vxl.version</code> namespace simply informs the version of the current Voxelent platform</p> 
* 
* @namespace Voxelent Main Namespace
* @property {vxl.c}         c           current objects
* @property {vxl.def}       def         definition objects
* @property {vxl.events}    events      events generated by voxelent
* @property {vxl.go}        go          global objects
* @property {vxl.version}   version     version
* 
*/
var vxl = {

/**
* Version
* @namespace Voxelent Version
* @property {String} number         the number of the current version
* @property {String} codename       the codename of the current version
* @property {Array}  plugins        installed plugins if any
*/
version : 
{
    number: '0.89.4',
   	codename : 'c4n314',
   	plugins  : []
},

/**
 * @namespace Voxelent Default/Definition Objects
 * @property {vxl.def.essl}     essl    ESSL constants
 * @property {vxl.def.lut}      lut     Lookup Table Definitions
 * @property {vxl.def.model}    model   Default          values for models
 * @property {vxl.def.view}     view    Default values for views 
 * 
 */
def : {
  
    /**
     * Pi divided by 2
     */
    piOver2: Math.PI /2,
    /**
     * Multiplicative constant to convert degrees to radians
     */
    deg2rad : Math.PI / 180,
    /**
     * Multiplicative constant to convert radians to degrees 
     */
    rad2deg : 180 / Math.PI,
    /**
     * Used mainly by <code>vxlRenderEngine</code> and its descendents
     * @namespace GLSL constants
     * @property {String} VERTEX_SHADER Vertex Shader Id
     * @property {String} FRAGMENT_SHADER Fragment Shader Id
     * @property {String} MODEL_VIEW_MATRIX  the model view matrix Id
     * @property {String} NORMAL_MATRIX the normal matrix Id
     * @property {String} PERSPECTIVE_MATRIX the perspective matrix Id
     * @property {String} MVP_MATRIX the model view perspective matrix Id
     * @property {String} VERTEX_ATTRIBUTE the vertex attribute Id
     * @property {String} NORMAL_ATTRIBUTE the normal attribute Id
     * @property {String} COLOR_ATTRIBUTE the color attribute Id
     * @property {JSON} blender The program to render blender scenes
     * @property {JSON} lambert The program to render scenes without specular reflections
     * @property {JSON} phong The program to render scenes with specular reflections
     * @property {JSON} bake The program that interleaves buffers for optimized rendering
     */
	essl			: { 
						VERTEX_SHADER   	: 'VERTEX_SHADER',
						FRAGMENT_SHADER 	: 'FRAGMENT_SHADER',
						MODEL_VIEW_MATRIX  	: 'mModelView',
						NORMAL_MATRIX   	: 'mNormal',
						PERSPECTIVE_MATRIX 	: 'mPerspective',
						MVP_MATRIX          : 'mModelViewPerspective',
						VERTEX_ATTRIBUTE    : 'aVertexPosition',
						NORMAL_ATTRIBUTE    : 'aVertexNormal',
						COLOR_ATTRIBUTE     : 'aVertexColor',
						TEXCOORD_ATTRIBUTE  : 'aVertexTextureCoords'
					},
    /** 
     * @namespace Lookup Table Definitions 
     * @property {Array}       list         List of lookup tables available
     * @property {String}      main         Lookup table loaded by default
     */                
	lut             : {
             
						list : ["default","aal","autumn","blackbody","bone","brodmann","cardiac",
								"copper","cortex","cte","french","fs","ge_color","gold","gooch",
								"hot","hotiron","hsv","jet","nih","nih_fire","nih_ice","pink",
								"rainramp","spectrum","surface","x_hot","x_rain"],
                              
						main:"default"

				    },
	/**
    * @namespace Default values for models
    */
	model			: {
	                   
						/** 
						 *  Enumeration with the different loading modes provided for models
						 * <ul>
                         * <li><code>LIVE</code>: Each asset is added to the scene as soon as it is downloaded</li>
                         * <li><code>LATER</code>: The assets are added to the scene only when ALL of them have been downloaded</li> 
                         * <li><code>DETACHED</code>: The assets are never added to the scene. The programmer decides when to do this.</li> 
                         * </ul> 
                         * 
                         * These modes can be used with {@link vxl.api.load} and with {@link vxlScene.setLoadingMode}
                         */
                         loadingMode     : { LIVE:'LIVE', LATER:'LATER', DETACHED:'DETACHED'},
                         /**
                          * Maximum number of indices per model (Unsigned Short range) 
                          */
                         MAX_NUM_INDICES: 65535,
                         /**
                          * Types of models
                          * <ul>
                          * <li><code>SIMPLE</code>: The model is rendered at all once
                          * <li><code>MESH</code>: This model represents a mesh (no shared triangles). Flat shading is required
                          * <li><code>BIG_DATA</code>: This model is complex and it may required several rendering cycles.
                          */
                         type :{SIMPLE:'SIMPLE', MESH:'MESH', BIG_DATA:'BIG DATA'}
					},

    material        : {
                       /**
                        * Diffuse color used by default when a model does 
                        * not have diffuse color information: [0.8,0.8,0.8,1.0] 
                        */ 
                        diffuse: [0.8,0.8,0.8,1.0],
                        /**
                        * Ambient color used by default when a model 
                        * does not have ambient color information: [0.0,0.0,0.0,1.0] 
                        */
                        ambient: [0.0,0.0,0.0,1.0],
                        /**
                        * Specular color used by default when a model 
                        * does not have specular color information: [0.0,0.0,0.0,1.0] 
                        */
                        specular: [0.0,0.0,0.0,1.0],
                        /**
                        * Shininess used by default when a model 
                        * does not have shininess information: 0 
                        */
                        shininess : 0.0,
                        /**
                        * Opacity used by default when a model 
                        * does not have opacity information: 0 
                        */
                        opacity : 1.0,
                        /**
                        * Shading used by default when a model 
                        * does not have shading information: 0 
                        */
                        shading : true
    },				
    /**
    * @namespace Default values for views
    * @property {Array} background  A 4-valued array that contains the default background colour for view. The format is [r,g,b,a]
    */
    view			: {
    					background: [135/256,135/256,135/256]
    					
    				},	
    /**
     *@namespace Default values for view interactors 
     */ 				
    interactor :{
                        /** 
                         * 
                         * Enumeration of common camera tasks
                         * 
                         * <p>The camera tasks can be:
                         * <ul>
                         * <li><code>NONE</code></li>
                         * <li><code>PAN</code></li> 
                         * <li><code>ROTATE</code></li> 
                         * <li><code>DOLLY</code></li>
                         * <li><code>ROLL</code></li>
                         * </ul>
                         * </p>
                         *  These constants are used internally and you probably would never need to use them.
                         */
                        task      : { NONE : 0, PAN : 1, ROTATE : 2, DOLLY : 3, ROLL : 4}
    },     						      
	/**
    * Contains the constants and default values that can be associated with <code>vxlActor</code>
    * 
    * @namespace Default values and constants that can be used with the <code>vxlActor</code> class.
    */
	actor			: {
                        /**
                         * <p>Defines the visualization modes available for instances of vxlActor</p> 
                         * <p>The visualization  modes can be:
                         * <ul>
                         * <li><code>TEXTURED</code>: Used when the model associated with this actor has a texture</li>
                         * <li><code>SOLID</code></li>
                         * <li><code>WIREFRAME</code></li> 
                         * <li><code>POINTS</code></li> 
                         * <li><code>LINES</code></li>
                         * <li><code>BOUNDING_BOX</code> (added in 0.88.1)</li>
                         * <li><code>BB_AND_SOLID</code> (added in 0.89)</li>
                         * <li><code>WIRED_AND_SOLID</code> (added in 0.89.1)</li>
                         * <li><code>FLAT</code> (added in 0.89.1)</li>
                         * </ul>
                         * </p>
                         * <p> to set the actor mode you should use the <code>{@link vxlActor#setVisualizationMode}</code>
                         *  For instance, if you want to visualize the wireframe of your actor you can do something like this:
                         * </p>
                         *  <pre class='prettyprint'>
                         *  var actor = vxl.c.scene.getActorByName('example.json'); //from the current scene
                         *  actor.setVisualizationMode(vxl.def.actor.mode.WIREFRAME)
                         * </pre>
                         * @see vxlActor#setVisualizationMode
                         */
						mode: {	
						        TEXTURED:'TEXTURED', 
						        SOLID:'SOLID', 
						        WIREFRAME:'WIREFRAME', 
						        POINTS:'POINTS', 
						        LINES:'LINES', 
						        BOUNDING_BOX:'BOUNDING_BOX',
						        BB_AND_SOLID:'BBANDSOLID',
						        WIRED_AND_SOLID:'WIRED_AND_SOLID',
						        FLAT:'FLAT',
						 },
						 /**
						  *  <p>Defines the culling modes available for instances of vxlActor</p> 
                          *  <p>These modes can be BACK,FRONT or NONE</p>
                          *  <pre class='prettyprint'>
                          *   var actor = vxl.c.scene.getActorByName('sphere'); //from the current scene
                          *   actor.cullFace(vxl.def.actor.cull.BACK); //hides the back face.
                          *  </pre>
						  */
						 cull:{
						     BACK:'BACK',
						     FRONT:'FRONT',
						     NONE:'NONE'
						 },
						 
						 /**
						  * <p>Defines the picking modes available for <code>vxlActor</code></p> 
						  */
						 picking: {
						     DISABLED:'DISABLED',
						     CELL:'CELL',
						     OBJECT:'OBJECT'
						 }
						
					},
	/**
	 * Defines the constants that can be used with <code>vxlCamera</code> 
	 *
     * @namespace Default values for cameras
     */
	camera          : {
                        
                        /** 
                         * Camera type available
                         * 
                         * <p>The camera type can be:
                         * <ul>
                         * <li><code>ORBITING</code>: Orbiting Camera - Around the World</li>
                         * <li><code>DYNAMIC</code>: Camera axes are updated on every rotation</li> 
                         * <li><code>TRACKING</code>: Tracking Camera - First Person Camera</li> 
                         * </ul>
                         * </p>
                         * 
                         * <p> These modes can be used with the {@link vxlCamera vxlCamera constructor} or with its {@link vxlCamera#setType setType} method</p>
                         */
    					type      : { ORBITING: 'ORBITING', TRACKING : 'TRACKING', EXPLORING: 'EXPLORING'},
    					/**
    					 * Right vector constant: [1,0,0] 
    					 */
    					right     : [1,0,0],
    					/**
    					 * Up vector constant: [0,1,0] 
    					 */
    					up        : [0,1,0],
    					/**
    					 * Camera axial or normal vector constant: [0,0,1] 
    					 */
    					normal    : [0,0,1],
    					/**
    					 * Default field of view value: 30 
    					 */
    					fov       : 30,
    					/**
    					 * Default value for the near field: 0.1 
    					 */
    					near      : 0.1,
    					/**
    					 * Default value for the far field: 10000 
    					 */
    					far       : 10000,
    					/**
                         * <p>Defines the tracking modes available for instances of vxlCamera</p>
                         * <p>A tracking mode is <u>only</u> required when the camera is set to follow an 
                         * actor using <code>{@link vxlCamera#follow}</code></p> 
                         * <p>The tracking  modes can be:
                         * <ul>
                         * <li><code>DEFAULT</code>:  The camera does not follow an actor. Controlled by the user to look around the world.</li>
                         * <li><code>ROTATIONAL</code>: The camera does not move but follows an actor position</li>
                         * <li><code>TRANSLATIONAL</code>: The camera moves with the actor, the angle is constant</li> 
                         * <li><code>CINEMATIC</code>: Similar to ROTATIONAL but allowing camera roll for a more dramatic effect</li>
                         * </ul>
                         * </p>
                         * <p> to set the tracking mode of the camera <code>myCamera</code> you should make sure that your camera is of tracking type with:
                         *  <code>myCamera.setType(vxl.def.camera.type.TRACKING)</code>.
                         *  For instance:
                         * </p>
                         *  <pre class='prettyprint'>
                         *  var actor = vxl.api.getActor('cone'); //from the current scene
                         *  var camera = vxl.c.camera;
                         *  camera.setType(vxl.def.camera.type.TRACKING);
                         *  camera.setTrackingMode(vxl.def.camera.tracking.ROTATIONAL);
                         *  camera.follow(actor);
                         * </pre>
                         * <p> a shorter way would be:</p>
                         * <pre class='prettyprint'>
                         *  var actor = vxl.api.getActor('cone'); //from the current scene
                         *  var camera = vxl.c.camera;
                         *  camera.setType(vxl.def.camera.type.TRACKING);
                         *  camera.follow(actor, vxl.def.camera.tracking.ROTATIONAL);
                         * </pre>
                         * @see vxlCamera#follow, vxlCamera#setTrackingMode
                         */
                        tracking: {
                              DEFAULT:'DEFAULT',
                              ROTATIONAL:'ROTATIONAL',
                              TRANSLATIONAL:'TRANSLATIONAL',
                              CINEMATIC: 'CINEMATIC'   
                        }
					},
				 	
    /**
    * @namespace Default values for renderers
    * @property {vxl.def.renderer.mode} mode The rendering mode
    * @property {vxl.def.renderer.rate} rate The rendering rat
    */
	renderer 		: {
			        mode: { TIMER:'TIMER', ANIMFRAME:'ANIFRAME'}, //EXPERIMENTAL NOT WAY TO CANCEL YET },
			        rate : { SLOW: 10000,  NORMAL: 500 }
	},
	
	renderable      :{
	                 task :{CREATE:'CREATE', 
	                        UPDATE_GEOMETRY:'UPDATE_GEOMETRY',
	                        UPDATE_COLORS:'UPDATE_COLORS'}
	    
	},
					
	/**
	 * @namespace Constants to handle textures 
	 * @property {vxl.def.texture.filter} filter The different filters applicable to textures
	 */
	texture : {
	    filter:{
    	    NEAREST:'NEAREST',
    	    LINEAR:'LINEAR',
    	    NEAREST_MIPMAP_NEAREST:'NEAREST_MIPMAP_NEAREST',
    	    LINEAR_MIPMAP_NEAREST:'LINEAR_MIPMAP_NEAREST',
    	    NEAREST_MIPMAP_LINEAR:'NEAREST_MIPMAP_LINEAR',
    	    LINEAR_MIPMAP_LINEAR:'LINEAR_MIPMAP_LINEAR'
	    }
	}
},

/**
* Congregates all the events fired by Voxelent
* 
* These events are registered with the vxlNotifier
* 
* @namespace Voxelent Events
* @property {String} DEFAULT_LUT_LOADED fired when the default lookup table is loaded
* @property {String} SCENE_UPDATED fired by vxlScene when an actor is added to the scene
* @property {String} MODELS_LOADED fired by vxlModelManager after loading a set of models
* @property {String} MODEL_NEW fired by the vxlModel constructor
* @property {String} ACTOR_MOVED fired by vxlActor when that actor instance is moved
* @property {String} ACTOR_SCALED fired by vxlActor
* @property {String} ACTOR_CHANGED_COLOR fired by vxlActor
* @property {String} ACTOR_CHANGED_SHADING fired by vxlActor
* @property {String} VIEW_NEW fired by the vxlView constructor
* @property {String} SCENE_NEW fired by the vxlScene constructor
* @property {String} READER_DONE fired when a reader is done reading window.File(s)
* @see {vxlNotifier}
*/
events : {
	DEFAULT_LUT_LOADED 	   : 'vxl.events.DEFAULT_LUT_LOADED',
	SCENE_UPDATED		   : 'vxl.events.SCENE_UPDATED',
	MODELS_LOADING         : 'vxl.events.MODELS_LOADING',
	MODEL_NEW              : 'vxl.events.MODEL_NEW',
	MODELS_LOADED		   : 'vxl.events.MODELS_LOADED',
	ACTOR_MOVED            : 'vxl.events.ACTOR_MOVED',
	ACTOR_SCALED           : 'vxl.events.ACTOR_SCALED',
	ACTOR_ROTATED          : 'vxl.events.ACTOR_ROTATED',
	ACTOR_CHANGED_COLOR    : 'vxl.events.ACTOR_CHANGED_COLOR',
	ACTOR_CHANGED_SHADING  : 'vxl.events.ACTOR_CHANGED_SHADING',
	VIEW_NEW               : 'vxl.events.VIEW_NEW',
	SCENE_NEW              : 'vxl.events.SCENE_NEW',
	READER_DONE            : 'vxl.events.READER_DONE'
},


/**
* @namespace Voxelent Global Objects
*
*/
go : {
    debug 	 		    : false,					  
    notifier            : undefined,
    modelManager        : undefined,
    lookupTableManager  : undefined,
    views               : [],
    scenes              : [],
    essl : {},
    renderman : {

		_timid : 0,
		_rates : [],
		_stop  : false,
		
		render : function(){
			for(var i=0; i<vxl.go.views.length;i+=1){
				vxl.go.views[i].renderer.render();
			}
			if (vxl.go.renderman._stop != true){
			 vxl.go.renderman._timid = window.requestAnimFrame(vxl.go.renderman.render);
			}
			else{
			    vxl.go.renderman._stop = false;
			}
		},
		
		cancel : function(){
		    vxl.go.renderman._stop = true;
		},
		
		slow : function(){
			/*vxl.go.renderman._rates = [];
			for(var i = 0; i < vxl.go.renderman._views.length; i++){
			    if (vxl.go.renderman._views[i].renderer.mode == vxl.def.renderer.mode.ANIMFRAME) continue;
				vxl.go.console('vxl.go.slowRendering: slow rendering on view '+vxl.go.renderman._views[i].name,true);
				vxl.go.renderman._rates.push(vxl.go.renderman._views[i].renderer.renderRate);
				vxl.go.renderman._views[i].renderer.setRenderRate(vxl.def.renderer.rate.SLOW);
			}*/
		},
		
		normal : function(){
			/*for(var i = 0; i < vxl.go.renderman._views.length; i++){
			    if (vxl.go.renderman._views[i].renderer.mode == vxl.def.renderer.mode.ANIMFRAME) continue;
				vxl.go.console('vxl.go.normalRendering: go back to normal rendering on view '+vxl.go.renderman._views[i].name,true);
				if (vxl.go.renderman._rates[i] != undefined){
				    vxl.go.renderman._views[i].renderer.setRenderRate(vxl.go.renderman._rates[i]);
				}
			}*/
		}
	},
	
	console : function(txt,flag) { 
		if (this.debug == true || flag){
			console.info(txt);
		}
	}
	
},

/**
* @namespace Voxelent Current Objects
* @property {vxlScene}          scene       the current scene
* @property {vxlView}           view        the current view
* @property {vxlCamera}         camera      the current camera
* @property {vxlActor}          actor       the current actor
* @property {vxlFrameAnimation} animation   the current animation
*/
c : {
	scene		: undefined,
	view		: undefined,
	camera 		: undefined,
	actor		: undefined,  
	animation 	: undefined
},
/**
 * Utility functions
 * @namespace Voxelent Util methods
 * 
 */
util : {
    
    isMac: function(){
        return navigator.platform.toUpperCase().indexOf("MAC") != -1;
    },
    /**
     *Returns a RGB color based on an integer (0..16 millions?) 
     */
    int2rgb: function(i){
        return [((i >> 16) & 0xFF)/256,((i >> 8) & 0xFF)/256,(i & 0xFF)/256]; 
    },
    
    /**
     * This function is attributed to Tim Down
     * @link{http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb} 
     */
    hex2rgb: function(hex){
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
             parseInt(result[1], 16),
             parseInt(result[2], 16),
             parseInt(result[3], 16)
        ] : null;
    },
    /**
     * Rescales the color from [0,255] to [0,1]
     * WebGL uses [0,1] range 
     */
    rgb2decimal : function(rgb){
        if (rgb == null || rgb == undefined) return null;  
        return [rgb[0]/255, rgb[1]/255,rgb[2]/255];   
    },
    
    createColor : function(r,g,b){
        var color = [];
        if (r == undefined) {
            return null;
        }
        
        if (r instanceof Array){
            var c = r.slice(0);
            r = c[0];
            g = c[1];
            b = c[2];
        }
        
        if (typeof(r) == 'string'){
            color = this.rgb2decimal(this.hex2rgb(r)); 
        }
        else if (typeof(r) == 'number'){
            if (r <0 || g == undefined || b == undefined || g <0 || b <0){
                return null; //invalid color
            }
            else if (r>1 || g>1 || b>1){
                color = this.rgb2decimal([r,g,b]);
            }
            else{
                color = [r,g,b]
            }
        }
        
        return color;
    },
    /**
     * Formats Arrays, vec3 and vec4 for display
     * 
     * @param {Array, vec3, vec4} arr the object to format
     * @param {Number} digits the number of decimal figures
     */
	format: function(arr, digits){
		var p = Math.pow(10,digits);
		if (typeof(arr) == 'object'){
			
			var result = '['; 
			for (var i=0; i < arr.length-1; i+=1){
				result  += Math.round(arr[i] * p) / p + ', '; 
			}
			result += Math.round(arr[arr.length-1] * p) / p  + ']'
		}
		else if (typeof(arr) == 'number'){
			result = '[' + Math.round(arr * p) / p  + ']';
		}
		return result;
	},
	
	/**
	 * Creates a vector from a set of parameters
	 * @param {Array, vec3, Number} x it can be an Array, a vec3 or a number
	 * @param {Number} y if x is a number, this parameter corresponds to the y-component
	 * @param {Number} z if x is a number, this parameter corresponds to the z-component
	 */
	createVec3: function(x,y,z){
	    var vvv = vec3.create();
	    if (x instanceof Array){
            vec3.set(vec3.create(x), vvv)
        }
        else if (x instanceof determineMatrixArrayType()){
            vec3.set(x, vvv)
        }
        else{
            vec3.set(vec3.createFrom(x,y,z), vvv);
        }
        return vvv;
	},
	/**
     * Creates an array from a set of parameters
     * @param {Array, vec3, Number} x it can be an Array, a vec3 or a number
     * @param {Number} y if x is a number, this parameter corresponds to the y-component
     * @param {Number} z if x is a number, this parameter corresponds to the z-component
     */
	createArr3: function(x,y,z){
	    var vvv = []
        if (x instanceof Array || x instanceof determineMatrixArrayType()){
            vvv[0] = x[0];
            vvv[1] = x[1];
            vvv[2] = x[2];
        }
        else{
            vvv[0] = x;
            vvv[1] = y;
            vvv[2] = z;
        }
        return vvv;
	},
	
	generateUID: function(){
	       function S4() {
                return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
            }
        return (S4()+"-"+S4()+"-"+S4()+"-"+S4());
    },
    
    extend : function(){
      var ret = {};
      var len = arguments.length;
      for (var i=0; i<len; i++) {
        for (p in arguments[i]) {
          if (arguments[i].hasOwnProperty(p)) {
            ret[p] = arguments[i][p];
          }
        }
      }
      return ret;
    },
    
    getPath : function(path){
        if (path ==undefined || path == null) {
            return "";
        }
        else if (path.length - 1 == path.lastIndexOf('/')){
            return path;
        }
        else if (path.lastIndexOf('.') > path.lastIndexOf('/')){
            return path.substring(0, path.lastIndexOf('/')+1)
        }
        else   
            return path + '/';
    },
    /**
     * Returns an angle between 0 and 360 deg
     * @param{Number} angle the angle 
     */
    getAngle: function(angle){
        if (angle > 360 || angle <-360) {
            return angle % 360;
        }
        else return angle;
    },
    /**
     *Converts degrees to radians
     * @param{Number} deg angle in degrees 
     */
    deg2rad: function(deg){
        return deg * Math.PI / 180;
    }
    
}

};

Array.prototype.max = function(){
    if (this.length > 65535){
       var max = this[0];
       for(var i=0,N = this.length; i <N; i+=1){
           if (this[i] > max){
               max = this[i];
           }
       }
       return max; 
    }
    else{
	   return Math.max.apply(null, this);
	}
};

Array.prototype.min = function(){
	if (this.length > 65535){
       var min = this[0];
       for(var i=0,N = this.length; i <N; i+=1){
           if (this[i] < min){
               min = this[i];
           }
       }
       return min; 
    }
    else{
       return Math.min.apply(null, this);
    }
};




Array.prototype.hasObject = (
  !Array.indexOf ? function (o)
  {
    var l = this.length + 1;
    while (l -= 1)
    {
        if (this[l - 1] === o)
        {
            return true;
        }
    }
    return false;
  } : function (o)
  {
    return (this.indexOf(o) !== -1);
  }
);

window.requestAnimFrame = (function(){
    return  window.requestAnimationFrame       || 
        window.webkitRequestAnimationFrame || 
        window.mozRequestAnimationFrame    || 
        window.oRequestAnimationFrame      || 
        window.msRequestAnimationFrame     || 
        function(/* function */ callback, /* DOMElement */ element){
            return window.setTimeout(callback, 1000 / 60);
        };
})();

window.cancelRequestAnimFrame = ( function() {
    return window.cancelAnimationFrame          ||
        window.webkitCancelRequestAnimationFrame    ||
        window.mozCancelRequestAnimationFrame       ||
        window.oCancelRequestAnimationFrame     ||
        window.msCancelRequestAnimationFrame        ||
        clearTimeout
})();


//$(window).bind('focus', vxl.go.renderman.normal);
//$(window).bind('blur', vxl.go.renderman.slow);

/**
 * <p> 
 * Handles asynchronous communication among classes in Voxelent 
 * using a publisher-subscriber mechanism
 * </p>
 * 
 * @class Hub for the publish-subscribe mechanism among Voxelent entities
 * @constructor
 */
function vxlNotifier(){
	this.targetList = {};
	this.sourceList = {};
    
};

/**
 * <p>Used by any class to declare the events that the class will listen for.</p>
  
 * @param {Object} list
 * @param {Object} receiver
 */
vxlNotifier.prototype.subscribe = function(list,receiver){
	if (typeof(list)=='string'){
		this._addTarget(list,receiver);
	}
	else if (list instanceof Array){
		for (var i=0;i<list.length;i+=1){
			this._addTarget(list[i],receiver);
		}
	}
	else {
		throw 'vxlNotifier.receives: this method receives a string or a list of strings'
	}
};

/**
 * <p>Used by any class to declare the events that the class will generate</p> 
 * @param {Object} list
 * @param {Object} sender
 */
vxlNotifier.prototype.publish = function(list,sender){
	if (typeof(list)== 'string'){
		this._addSource(list,sender);
	}
	else if (list instanceof Array){
		for (var i=0;i<list.length;i+=1){
			this._addSource(list[i],sender);
		}
	}
	else {
		throw 'vxlNotifier.sends: this method receives a string or a list of strings'
	}
}


/**
 * Any class can use this method to tell the notifier that it will listen to 
 * a particular event.
 * 
 * @param {Object} event the event the class will listen to
 * @param {Object} target the object that will listen for the event
 * @private
 */
vxlNotifier.prototype._addTarget = function(event, target){
	vxl.go.console('vxlNotifier: adding target for event '+event);
	var targetList = this.targetList;
	if (targetList[event]== undefined){
		targetList[event] = [];
	}
	targetList[event].push(target);
};


/**
 * Any class can use this method to tell the notifier that it will emit a particular event
 * 
 * @param {Object} event the event to emit
 * @param {Object} src the object that will emit the event
 * @private 
 */
vxlNotifier.prototype._addSource = function(event,src){
	vxl.go.console('vxlNotifier: adding source for event '+event);
	var targetList = this.targetList;
	var sourceList = this.sourceList;
	
	if (sourceList[event]== undefined){
		sourceList[event] = [];
	}
	
	if (targetList[event]== undefined){
		targetList[event] = [];
	}
	
	sourceList[event].push(src);
};

/**
 * <p>Invoked by any class when it needs to emit an event that should be propagated to other
 * objects in the library</p>
 * 
 * <p>The notifier will first verify if the object emitting the event has been authorized to do so.
 * This is, the object should have registered using <code>publish</code>.
 * After that, the notifier will retrieve a list of the objects that have registered as listeners of 
 * the particular event and fires the event to them using JQuery.
 * </p>
 *  
 * @param {Object} event
 * @param {Object} src
 */
vxlNotifier.prototype.fire = function(event, src){
    
    if (this.targetList[event].length == 0) return; //quick and simple
    
    var self = this;
    
    function processEvent(){
    	var targetList = self.targetList;
        var idx = self.sourceList[event].indexOf(src);
        if (idx == -1){
        	throw 'The source '+src+' is not registered to trigger the event '+event+'. Did you use vxlNotifier.publish?';
        }
    	vxl.go.console('vxlNotifier: firing ' +event);
    	
    	var targets = self.targetList[event];
    	
    	for (var index=0;index<targets.length;index++){
             targets[index].handleEvent(event,src);
        }
	}
	setTimeout(function(){processEvent()},0)
};




/**
 * Gets a list of the events handled by this vxlNotifier 
 */
vxlNotifier.prototype.getEvents = function(){
	var list = [];
	for (var event in this.sourceList){
		list.push(event);
	}
	return list;
};


/**
 * Get a list of the objects that are currently registered to listen for a particular event 
 * @param {Object} event the event in question
 */
vxlNotifier.prototype.getTargetsFor = function(event){
	var targets = this.targetList[event];
	var list = [];
	for (var index=0;index<targets.length;index++){
		list.push(targets[index]);
	}
	return list; //@TODO: Reevaluate
};

/**
 *Global notifier object 
 */
vxl.go.notifier = new vxlNotifier();
 

    



/**
 * @fileoverview gl-matrix - High performance matrix and vector operations for WebGL
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 1.3.4
 */

/*
 * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

// Updated to use a modification of the "returnExportsGlobal" pattern from https://github.com/umdjs/umd

(function (root, factory) {
    if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory(global);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function () {
            return factory(root);
        });
    } else {
        // Browser globals
        factory(root);
    }
}(this, function (root) {
    "use strict";

    var glMath = {};
    (function() {
        if (typeof(Float32Array) != 'undefined') {
            var y = new Float32Array(1);
            var i = new Int32Array(y.buffer);

            /**
             * Fast way to calculate the inverse square root,
             * see http://jsperf.com/inverse-square-root/5
             *
             * If typed arrays are not available, a slower
             * implementation will be used.
             *
             * @param {Number} number the number
             * @returns {Number} Inverse square root
             */
            glMath.invsqrt = function(number) {
              var x2 = number * 0.5;
              y[0] = number;
              var threehalfs = 1.5;

              i[0] = 0x5f3759df - (i[0] >> 1);

              var number2 = y[0];

              return number2 * (threehalfs - (x2 * number2 * number2));
            };
        } else {
            glMath.invsqrt = function(number) { return 1.0 / Math.sqrt(number); };
        }
    })();

    /**
     * @class System-specific optimal array type
     * @name MatrixArray
     */
    var MatrixArray = null;
    
    // explicitly sets and returns the type of array to use within glMatrix
    function setMatrixArrayType(type) {
        MatrixArray = type;
        return MatrixArray;
    }

    // auto-detects and returns the best type of array to use within glMatrix, falling
    // back to Array if typed arrays are unsupported
    function determineMatrixArrayType() {
        MatrixArray = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
        return MatrixArray;
    }
    
    determineMatrixArrayType();

    /**
     * @class 3 Dimensional Vector
     * @name vec3
     */
    var vec3 = {};
     
    /**
     * Creates a new instance of a vec3 using the default array type
     * Any javascript array-like objects containing at least 3 numeric elements can serve as a vec3
     *
     * @param {vec3} [vec] vec3 containing values to initialize with
     *
     * @returns {vec3} New vec3
     */
    vec3.create = function (vec) {
        var dest = new MatrixArray(3);

        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];
        } else {
            dest[0] = dest[1] = dest[2] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a vec3, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value

     * @returns {vec3} New vec3
     */
    vec3.createFrom = function (x, y, z) {
        var dest = new MatrixArray(3);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;

        return dest;
    };

    /**
     * Copies the values of one vec3 to another
     *
     * @param {vec3} vec vec3 containing values to copy
     * @param {vec3} dest vec3 receiving copied values
     *
     * @returns {vec3} dest
     */
    vec3.set = function (vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];

        return dest;
    };

    /**
     * Performs a vector addition
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.add = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] += vec2[0];
            vec[1] += vec2[1];
            vec[2] += vec2[2];
            return vec;
        }

        dest[0] = vec[0] + vec2[0];
        dest[1] = vec[1] + vec2[1];
        dest[2] = vec[2] + vec2[2];
        return dest;
    };

    /**
     * Performs a vector subtraction
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.subtract = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] -= vec2[0];
            vec[1] -= vec2[1];
            vec[2] -= vec2[2];
            return vec;
        }

        dest[0] = vec[0] - vec2[0];
        dest[1] = vec[1] - vec2[1];
        dest[2] = vec[2] - vec2[2];
        return dest;
    };

    /**
     * Performs a vector multiplication
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.multiply = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] *= vec2[0];
            vec[1] *= vec2[1];
            vec[2] *= vec2[2];
            return vec;
        }

        dest[0] = vec[0] * vec2[0];
        dest[1] = vec[1] * vec2[1];
        dest[2] = vec[2] * vec2[2];
        return dest;
    };

    /**
     * Negates the components of a vec3
     *
     * @param {vec3} vec vec3 to negate
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.negate = function (vec, dest) {
        if (!dest) { dest = vec; }

        dest[0] = -vec[0];
        dest[1] = -vec[1];
        dest[2] = -vec[2];
        return dest;
    };

    /**
     * Multiplies the components of a vec3 by a scalar value
     *
     * @param {vec3} vec vec3 to scale
     * @param {number} val Value to scale by
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.scale = function (vec, val, dest) {
        if (!dest || vec === dest) {
            vec[0] *= val;
            vec[1] *= val;
            vec[2] *= val;
            return vec;
        }

        dest[0] = vec[0] * val;
        dest[1] = vec[1] * val;
        dest[2] = vec[2] * val;
        return dest;
    };

    /**
     * Generates a unit vector of the same direction as the provided vec3
     * If vector length is 0, returns [0, 0, 0]
     *
     * @param {vec3} vec vec3 to normalize
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.normalize = function (vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        } else if (len === 1) {
            dest[0] = x;
            dest[1] = y;
            dest[2] = z;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };

    /**
     * Generates the cross product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.cross = function (vec, vec2, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];

        dest[0] = y * z2 - z * y2;
        dest[1] = z * x2 - x * z2;
        dest[2] = x * y2 - y * x2;
        return dest;
    };

    /**
     * Caclulates the length of a vec3
     *
     * @param {vec3} vec vec3 to calculate length of
     *
     * @returns {number} Length of vec
     */
    vec3.length = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return Math.sqrt(x * x + y * y + z * z);
    };

    /**
     * Caclulates the dot product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     *
     * @returns {number} Dot product of vec and vec2
     */
    vec3.dot = function (vec, vec2) {
        return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
    };

    /**
     * Generates a unit vector pointing from one vector to another
     *
     * @param {vec3} vec Origin vec3
     * @param {vec3} vec2 vec3 to point to
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.direction = function (vec, vec2, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0] - vec2[0],
            y = vec[1] - vec2[1],
            z = vec[2] - vec2[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };

    /**
     * Performs a linear interpolation between two vec3
     *
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     * @param {number} lerp Interpolation amount between the two inputs
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.lerp = function (vec, vec2, lerp, dest) {
        if (!dest) { dest = vec; }

        dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
        dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
        dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);

        return dest;
    };

    /**
     * Calculates the euclidian distance between two vec3
     *
     * Params:
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     *
     * @returns {number} Distance between vec and vec2
     */
    vec3.dist = function (vec, vec2) {
        var x = vec2[0] - vec[0],
            y = vec2[1] - vec[1],
            z = vec2[2] - vec[2];
            
        return Math.sqrt(x*x + y*y + z*z);
    };

    // Pre-allocated to prevent unecessary garbage collection
    var unprojectMat = null;
    var unprojectVec = new MatrixArray(4);
    /**
     * Projects the specified vec3 from screen space into object space
     * Based on the <a href="http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup">Mesa gluUnProject implementation</a>
     *
     * @param {vec3} vec Screen-space vector to project
     * @param {mat4} view View matrix
     * @param {mat4} proj Projection matrix
     * @param {vec4} viewport Viewport as given to gl.viewport [x, y, width, height]
     * @param {vec3} [dest] vec3 receiving unprojected result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.unproject = function (vec, view, proj, viewport, dest) {
        if (!dest) { dest = vec; }

        if(!unprojectMat) {
            unprojectMat = mat4.create();
        }

        var m = unprojectMat;
        var v = unprojectVec;
        
        v[0] = (vec[0] - viewport[0]) * 2.0 / viewport[2] - 1.0;
        v[1] = (vec[1] - viewport[1]) * 2.0 / viewport[3] - 1.0;
        v[2] = 2.0 * vec[2] - 1.0;
        v[3] = 1.0;
        
        mat4.multiply(proj, view, m);
        if(!mat4.inverse(m)) { return null; }
        
        mat4.multiplyVec4(m, v);
        if(v[3] === 0.0) { return null; }

        dest[0] = v[0] / v[3];
        dest[1] = v[1] / v[3];
        dest[2] = v[2] / v[3];
        
        return dest;
    };

    var xUnitVec3 = vec3.createFrom(1,0,0);
    var yUnitVec3 = vec3.createFrom(0,1,0);
    var zUnitVec3 = vec3.createFrom(0,0,1);

    /**
     * Generates a quaternion of rotation between two given normalized vectors
     *
     * @param {vec3} a Normalized source vector
     * @param {vec3} b Normalized target vector
     * @param {quat4} [dest] quat4 receiving operation result.
     *
     * @returns {quat4} dest if specified, a new quat4 otherwise
     */
    vec3.rotationTo = function (a, b, dest) {
        if (!dest) { dest = quat4.create(); }

        var d = vec3.dot(a, b);
        var axis = vec3.create();
        if (d >= 1.0) {
            quat4.set(identityQuat4, dest);
        } else if (d < (0.000001 - 1.0)) {
            vec3.cross(xUnitVec3, a, axis);
            if (axis.length < 0.000001)
                vec3.cross(yUnitVec3, a, axis);
            if (axis.length < 0.000001)
                vec3.cross(zUnitVec3, a, axis);
            vec3.normalize(axis);
            quat4.fromAxisAngle(axis, Math.PI, dest);
        } else {
            var s = Math.sqrt((1.0 + d) * 2.0);
            var sInv = 1.0 / s;
            vec3.cross(a, b, axis);
            dest[0] = axis[0] * sInv;
            dest[1] = axis[1] * sInv;
            dest[2] = axis[2] * sInv;
            dest[3] = s * 0.5;
            quat4.normalize(dest);
        }
        if (dest[3] > 1.0) dest[3] = 1.0;
        else if (dest[3] < -1.0) dest[3] = -1.0;
        return dest;
    };

    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} vec Vector to represent as a string
     *
     * @returns {string} String representation of vec
     */
    vec3.str = function (vec) {
        return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';
    };

    /**
     * @class 3x3 Matrix
     * @name mat3
     */
    var mat3 = {};

    /**
     * Creates a new instance of a mat3 using the default array type
     * Any javascript array-like object containing at least 9 numeric elements can serve as a mat3
     *
     * @param {mat3} [mat] mat3 containing values to initialize with
     *
     * @returns {mat3} New mat3
     */
    mat3.create = function (mat) {
        var dest = new MatrixArray(9);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
        } else {
            dest[0] = dest[1] =
            dest[2] = dest[3] =
            dest[4] = dest[5] =
            dest[6] = dest[7] =
            dest[8] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a mat3, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22

     * @returns {mat3} New mat3
     */
    mat3.createFrom = function (m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        var dest = new MatrixArray(9);

        dest[0] = m00;
        dest[1] = m01;
        dest[2] = m02;
        dest[3] = m10;
        dest[4] = m11;
        dest[5] = m12;
        dest[6] = m20;
        dest[7] = m21;
        dest[8] = m22;

        return dest;
    };

    /**
     * Calculates the determinant of a mat3
     *
     * @param {mat3} mat mat3 to calculate determinant of
     *
     * @returns {Number} determinant of mat
     */
    mat3.determinant = function (mat) {
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[3], a11 = mat[4], a12 = mat[5],
            a20 = mat[6], a21 = mat[7], a22 = mat[8];

        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
    };

    /**
     * Calculates the inverse matrix of a mat3
     *
     * @param {mat3} mat mat3 to calculate inverse of
     * @param {mat3} [dest] mat3 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat3} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat3.inverse = function (mat, dest) {
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[3], a11 = mat[4], a12 = mat[5],
            a20 = mat[6], a21 = mat[7], a22 = mat[8],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

            d = a00 * b01 + a01 * b11 + a02 * b21,
            id;

        if (!d) { return null; }
        id = 1 / d;

        if (!dest) { dest = mat3.create(); }

        dest[0] = b01 * id;
        dest[1] = (-a22 * a01 + a02 * a21) * id;
        dest[2] = (a12 * a01 - a02 * a11) * id;
        dest[3] = b11 * id;
        dest[4] = (a22 * a00 - a02 * a20) * id;
        dest[5] = (-a12 * a00 + a02 * a10) * id;
        dest[6] = b21 * id;
        dest[7] = (-a21 * a00 + a01 * a20) * id;
        dest[8] = (a11 * a00 - a01 * a10) * id;
        return dest;
    };
    
    /**
     * Performs a matrix multiplication
     *
     * @param {mat3} mat First operand
     * @param {mat3} mat2 Second operand
     * @param {mat3} [dest] mat3 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat3} dest if specified, mat otherwise
     */
    mat3.multiply = function (mat, mat2, dest) {
        if (!dest) { dest = mat; }
        

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[3], a11 = mat[4], a12 = mat[5],
            a20 = mat[6], a21 = mat[7], a22 = mat[8],

            b00 = mat2[0], b01 = mat2[1], b02 = mat2[2],
            b10 = mat2[3], b11 = mat2[4], b12 = mat2[5],
            b20 = mat2[6], b21 = mat2[7], b22 = mat2[8];

        dest[0] = b00 * a00 + b01 * a10 + b02 * a20;
        dest[1] = b00 * a01 + b01 * a11 + b02 * a21;
        dest[2] = b00 * a02 + b01 * a12 + b02 * a22;

        dest[3] = b10 * a00 + b11 * a10 + b12 * a20;
        dest[4] = b10 * a01 + b11 * a11 + b12 * a21;
        dest[5] = b10 * a02 + b11 * a12 + b12 * a22;

        dest[6] = b20 * a00 + b21 * a10 + b22 * a20;
        dest[7] = b20 * a01 + b21 * a11 + b22 * a21;
        dest[8] = b20 * a02 + b21 * a12 + b22 * a22;

        return dest;
    };

    /**
     * Transforms the vec2 according to the given mat3.
     *
     * @param {mat3} matrix mat3 to multiply against
     * @param {vec2} vec    the vector to multiply
     * @param {vec2} [dest] an optional receiving vector. If not given, vec is used.
     *
     * @returns {vec2} The multiplication result
     **/
    mat3.multiplyVec2 = function(matrix, vec, dest) {
      if (!dest) dest = vec;
      var x = vec[0], y = vec[1];
      dest[0] = x * matrix[0] + y * matrix[3] + matrix[6];
      dest[1] = x * matrix[1] + y * matrix[4] + matrix[7];
      return dest;
    };

    /**
     * Transforms the vec3 according to the given mat3
     *
     * @param {mat3} matrix mat3 to multiply against
     * @param {vec3} vec    the vector to multiply
     * @param {vec3} [dest] an optional receiving vector. If not given, vec is used.
     *
     * @returns {vec3} The multiplication result
     **/
    mat3.multiplyVec3 = function(matrix, vec, dest) {
      if (!dest) dest = vec;
      var x = vec[0], y = vec[1], z = vec[2];
      dest[0] = x * matrix[0] + y * matrix[3] + z * matrix[6];
      dest[1] = x * matrix[1] + y * matrix[4] + z * matrix[7];
      dest[2] = x * matrix[2] + y * matrix[5] + z * matrix[8];
      
      return dest;
    };

    /**
     * Copies the values of one mat3 to another
     *
     * @param {mat3} mat mat3 containing values to copy
     * @param {mat3} dest mat3 receiving copied values
     *
     * @returns {mat3} dest
     */
    mat3.set = function (mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        return dest;
    };

    /**
     * Sets a mat3 to an identity matrix
     *
     * @param {mat3} dest mat3 to set
     *
     * @returns dest if specified, otherwise a new mat3
     */
    mat3.identity = function (dest) {
        if (!dest) { dest = mat3.create(); }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 1;
        dest[5] = 0;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 1;
        return dest;
    };

    /**
     * Transposes a mat3 (flips the values over the diagonal)
     *
     * Params:
     * @param {mat3} mat mat3 to transpose
     * @param {mat3} [dest] mat3 receiving transposed values. If not specified result is written to mat
     *
     * @returns {mat3} dest is specified, mat otherwise
     */
    mat3.transpose = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a01 = mat[1], a02 = mat[2],
                a12 = mat[5];

            mat[1] = mat[3];
            mat[2] = mat[6];
            mat[3] = a01;
            mat[5] = mat[7];
            mat[6] = a02;
            mat[7] = a12;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = mat[3];
        dest[2] = mat[6];
        dest[3] = mat[1];
        dest[4] = mat[4];
        dest[5] = mat[7];
        dest[6] = mat[2];
        dest[7] = mat[5];
        dest[8] = mat[8];
        return dest;
    };

    /**
     * Copies the elements of a mat3 into the upper 3x3 elements of a mat4
     *
     * @param {mat3} mat mat3 containing values to copy
     * @param {mat4} [dest] mat4 receiving copied values
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat3.toMat4 = function (mat, dest) {
        if (!dest) { dest = mat4.create(); }

        dest[15] = 1;
        dest[14] = 0;
        dest[13] = 0;
        dest[12] = 0;

        dest[11] = 0;
        dest[10] = mat[8];
        dest[9] = mat[7];
        dest[8] = mat[6];

        dest[7] = 0;
        dest[6] = mat[5];
        dest[5] = mat[4];
        dest[4] = mat[3];

        dest[3] = 0;
        dest[2] = mat[2];
        dest[1] = mat[1];
        dest[0] = mat[0];

        return dest;
    };

    /**
     * Returns a string representation of a mat3
     *
     * @param {mat3} mat mat3 to represent as a string
     *
     * @param {string} String representation of mat
     */
    mat3.str = function (mat) {
        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] +
            ', ' + mat[3] + ', ' + mat[4] + ', ' + mat[5] +
            ', ' + mat[6] + ', ' + mat[7] + ', ' + mat[8] + ']';
    };

    /**
     * @class 4x4 Matrix
     * @name mat4
     */
    var mat4 = {};

    /**
     * Creates a new instance of a mat4 using the default array type
     * Any javascript array-like object containing at least 16 numeric elements can serve as a mat4
     *
     * @param {mat4} [mat] mat4 containing values to initialize with
     *
     * @returns {mat4} New mat4
     */
    mat4.create = function (mat) {
        var dest = new MatrixArray(16);

        if(arguments.length === 4) {
            dest[0] = arguments[0];
            dest[1] = arguments[1];
            dest[2] = arguments[2];
            dest[3] = arguments[3];
            dest[4] = arguments[4];
            dest[5] = arguments[5];
            dest[6] = arguments[6];
            dest[7] = arguments[7];
            dest[8] = arguments[8];
            dest[9] = arguments[9];
            dest[10] = arguments[10];
            dest[11] = arguments[11];
            dest[12] = arguments[12];
            dest[13] = arguments[13];
            dest[14] = arguments[14];
            dest[15] = arguments[15];
        } else if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        return dest;
    };

    /**
     * Creates a new instance of a mat4, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m03
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m13
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22
     * @param {number} m23
     * @param {number} m30
     * @param {number} m31
     * @param {number} m32
     * @param {number} m33

     * @returns {mat4} New mat4
     */
    mat4.createFrom = function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        var dest = new MatrixArray(16);

        dest[0] = m00;
        dest[1] = m01;
        dest[2] = m02;
        dest[3] = m03;
        dest[4] = m10;
        dest[5] = m11;
        dest[6] = m12;
        dest[7] = m13;
        dest[8] = m20;
        dest[9] = m21;
        dest[10] = m22;
        dest[11] = m23;
        dest[12] = m30;
        dest[13] = m31;
        dest[14] = m32;
        dest[15] = m33;

        return dest;
    };

    /**
     * Copies the values of one mat4 to another
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} dest mat4 receiving copied values
     *
     * @returns {mat4} dest
     */
    mat4.set = function (mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Sets a mat4 to an identity matrix
     *
     * @param {mat4} dest mat4 to set
     *
     * @returns {mat4} dest
     */
    mat4.identity = function (dest) {
        if (!dest) { dest = mat4.create(); }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 1;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = 1;
        dest[11] = 0;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;
        return dest;
    };

    /**
     * Transposes a mat4 (flips the values over the diagonal)
     *
     * @param {mat4} mat mat4 to transpose
     * @param {mat4} [dest] mat4 receiving transposed values. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise
     */
    mat4.transpose = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a01 = mat[1], a02 = mat[2], a03 = mat[3],
                a12 = mat[6], a13 = mat[7],
                a23 = mat[11];

            mat[1] = mat[4];
            mat[2] = mat[8];
            mat[3] = mat[12];
            mat[4] = a01;
            mat[6] = mat[9];
            mat[7] = mat[13];
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = mat[14];
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = mat[4];
        dest[2] = mat[8];
        dest[3] = mat[12];
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = mat[9];
        dest[7] = mat[13];
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = mat[14];
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} mat mat4 to calculate determinant of
     *
     * @returns {number} determinant of mat
     */
    mat4.determinant = function (mat) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        return (a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
                a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
                a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
                a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
                a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
                a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33);
    };

    /**
     * Calculates the inverse matrix of a mat4
     *
     * @param {mat4} mat mat4 to calculate inverse of
     * @param {mat4} [dest] mat4 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat4.inverse = function (mat, dest) {
        if (!dest) { dest = mat; }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,

            d = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06),
            invDet;

            // Calculate the determinant
            if (!d) { return null; }
            invDet = 1 / d;

        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into another mat4
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} [dest] mat4 receiving copied values
     *
     * @returns {mat4} dest is specified, a new mat4 otherwise
     */
    mat4.toRotationMat = function (mat, dest) {
        if (!dest) { dest = mat4.create(); }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into a mat3
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat3} [dest] mat3 receiving copied values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise
     */
    mat4.toMat3 = function (mat, dest) {
        if (!dest) { dest = mat3.create(); }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[4];
        dest[4] = mat[5];
        dest[5] = mat[6];
        dest[6] = mat[8];
        dest[7] = mat[9];
        dest[8] = mat[10];

        return dest;
    };

    /**
     * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
     * The resulting matrix is useful for calculating transformed normals
     *
     * Params:
     * @param {mat4} mat mat4 containing values to invert and copy
     * @param {mat3} [dest] mat3 receiving values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise, null if the matrix cannot be inverted
     */
    mat4.toInverseMat3 = function (mat, dest) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[4], a11 = mat[5], a12 = mat[6],
            a20 = mat[8], a21 = mat[9], a22 = mat[10],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

            d = a00 * b01 + a01 * b11 + a02 * b21,
            id;

        if (!d) { return null; }
        id = 1 / d;

        if (!dest) { dest = mat3.create(); }

        dest[0] = b01 * id;
        dest[1] = (-a22 * a01 + a02 * a21) * id;
        dest[2] = (a12 * a01 - a02 * a11) * id;
        dest[3] = b11 * id;
        dest[4] = (a22 * a00 - a02 * a20) * id;
        dest[5] = (-a12 * a00 + a02 * a10) * id;
        dest[6] = b21 * id;
        dest[7] = (-a21 * a00 + a01 * a20) * id;
        dest[8] = (a11 * a00 - a01 * a10) * id;

        return dest;
    };

    /**
     * Performs a matrix multiplication
     *
     * @param {mat4} mat First operand
     * @param {mat4} mat2 Second operand
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.multiply = function (mat, mat2, dest) {
        if (!dest) { dest = mat; }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

            b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3],
            b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7],
            b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11],
            b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];

        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

        return dest;
    };

    /**
     * Transforms a vec3 with the given matrix
     * 4th vector component is implicitly '1'
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    mat4.multiplyVec3 = function (mat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];

        return dest;
    };

    /**
     * Transforms a vec4 with the given matrix
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec4} vec vec4 to transform
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec4} dest if specified, vec otherwise
     */
    mat4.multiplyVec4 = function (mat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2], w = vec[3];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
        dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

        return dest;
    };

    /**
     * Translates a matrix by the given vector
     *
     * @param {mat4} mat mat4 to translate
     * @param {vec3} vec vec3 specifying the translation
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.translate = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2],
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23;

        if (!dest || mat === dest) {
            mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
            mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
            mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
            mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
            return mat;
        }

        a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
        a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
        a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];

        dest[0] = a00; dest[1] = a01; dest[2] = a02; dest[3] = a03;
        dest[4] = a10; dest[5] = a11; dest[6] = a12; dest[7] = a13;
        dest[8] = a20; dest[9] = a21; dest[10] = a22; dest[11] = a23;

        dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
        dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
        dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
        dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
        return dest;
    };

    /**
     * Scales a matrix by the given vector
     *
     * @param {mat4} mat mat4 to scale
     * @param {vec3} vec vec3 specifying the scale for each axis
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @param {mat4} dest if specified, mat otherwise
     */
    mat4.scale = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2];

        if (!dest || mat === dest) {
            mat[0] *= x;
            mat[1] *= x;
            mat[2] *= x;
            mat[3] *= x;
            mat[4] *= y;
            mat[5] *= y;
            mat[6] *= y;
            mat[7] *= y;
            mat[8] *= z;
            mat[9] *= z;
            mat[10] *= z;
            mat[11] *= z;
            return mat;
        }

        dest[0] = mat[0] * x;
        dest[1] = mat[1] * x;
        dest[2] = mat[2] * x;
        dest[3] = mat[3] * x;
        dest[4] = mat[4] * y;
        dest[5] = mat[5] * y;
        dest[6] = mat[6] * y;
        dest[7] = mat[7] * y;
        dest[8] = mat[8] * z;
        dest[9] = mat[9] * z;
        dest[10] = mat[10] * z;
        dest[11] = mat[11] * z;
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the specified axis
     * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {vec3} axis vec3 representing the axis to rotate around
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotate = function (mat, angle, axis, dest) {
        var x = axis[0], y = axis[1], z = axis[2],
            len = Math.sqrt(x * x + y * y + z * z),
            s, c, t,
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23,
            b00, b01, b02,
            b10, b11, b12,
            b20, b21, b22;

        if (!len) { return null; }
        if (len !== 1) {
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
        }

        s = Math.sin(angle);
        c = Math.cos(angle);
        t = 1 - c;

        a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
        a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
        a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];

        // Construct the elements of the rotation matrix
        b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
        b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
        b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform rotation-specific matrix multiplication
        dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
        dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
        dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
        dest[3] = a03 * b00 + a13 * b01 + a23 * b02;

        dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
        dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
        dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
        dest[7] = a03 * b10 + a13 * b11 + a23 * b12;

        dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
        dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
        dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
        dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateX = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[4] = a10 * c + a20 * s;
        dest[5] = a11 * c + a21 * s;
        dest[6] = a12 * c + a22 * s;
        dest[7] = a13 * c + a23 * s;

        dest[8] = a10 * -s + a20 * c;
        dest[9] = a11 * -s + a21 * c;
        dest[10] = a12 * -s + a22 * c;
        dest[11] = a13 * -s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateY = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a20 * -s;
        dest[1] = a01 * c + a21 * -s;
        dest[2] = a02 * c + a22 * -s;
        dest[3] = a03 * c + a23 * -s;

        dest[8] = a00 * s + a20 * c;
        dest[9] = a01 * s + a21 * c;
        dest[10] = a02 * s + a22 * c;
        dest[11] = a03 * s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateZ = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a10 * s;
        dest[1] = a01 * c + a11 * s;
        dest[2] = a02 * c + a12 * s;
        dest[3] = a03 * c + a13 * s;

        dest[4] = a00 * -s + a10 * c;
        dest[5] = a01 * -s + a11 * c;
        dest[6] = a02 * -s + a12 * c;
        dest[7] = a03 * -s + a13 * c;

        return dest;
    };

    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.frustum = function (left, right, bottom, top, near, far, dest) {
        if (!dest) { dest = mat4.create(); }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = (near * 2) / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = (near * 2) / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = (right + left) / rl;
        dest[9] = (top + bottom) / tb;
        dest[10] = -(far + near) / fn;
        dest[11] = -1;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = -(far * near * 2) / fn;
        dest[15] = 0;
        return dest;
    };

    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {number} fovy Vertical field of view
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.perspective = function (fovy, aspect, near, far, dest) {
        var top = near * Math.tan(fovy * Math.PI / 360.0),
            right = top * aspect;
        return mat4.frustum(-right, right, -top, top, near, far, dest);
    };

    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.ortho = function (left, right, bottom, top, near, far, dest) {
        if (!dest) { dest = mat4.create(); }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = 2 / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 2 / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = -2 / fn;
        dest[11] = 0;
        dest[12] = -(left + right) / rl;
        dest[13] = -(top + bottom) / tb;
        dest[14] = -(far + near) / fn;
        dest[15] = 1;
        return dest;
    };

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing "up"
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.lookAt = function (eye, center, up, dest) {
        if (!dest) { dest = mat4.create(); }

        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
            eyex = eye[0],
            eyey = eye[1],
            eyez = eye[2],
            upx = up[0],
            upy = up[1],
            upz = up[2],
            centerx = center[0],
            centery = center[1],
            centerz = center[2];

        if (eyex === centerx && eyey === centery && eyez === centerz) {
            return mat4.identity(dest);
        }

        //vec3.direction(eye, center, z);
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;

        // normalize (no check needed for 0 because of early return)
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        //vec3.normalize(vec3.cross(up, z, x));
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        //vec3.normalize(vec3.cross(z, x, y));
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        dest[0] = x0;
        dest[1] = y0;
        dest[2] = z0;
        dest[3] = 0;
        dest[4] = x1;
        dest[5] = y1;
        dest[6] = z1;
        dest[7] = 0;
        dest[8] = x2;
        dest[9] = y2;
        dest[10] = z2;
        dest[11] = 0;
        dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        dest[15] = 1;

        return dest;
    };

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {quat4} quat Rotation quaternion
     * @param {vec3} vec Translation vector
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to a new mat4
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.fromRotationTranslation = function (quat, vec, dest) {
        if (!dest) { dest = mat4.create(); }

        // Quaternion math
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;
        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;
        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;
        dest[12] = vec[0];
        dest[13] = vec[1];
        dest[14] = vec[2];
        dest[15] = 1;
        
        return dest;
    };

    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} mat mat4 to represent as a string
     *
     * @returns {string} String representation of mat
     */
    mat4.str = function (mat) {
        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] +
            ', ' + mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] +
            ', ' + mat[8] + ', ' + mat[9] + ', ' + mat[10] + ', ' + mat[11] +
            ', ' + mat[12] + ', ' + mat[13] + ', ' + mat[14] + ', ' + mat[15] + ']';
    };

    /**
     * @class Quaternion
     * @name quat4
     */
    var quat4 = {};

    /**
     * Creates a new instance of a quat4 using the default array type
     * Any javascript array containing at least 4 numeric elements can serve as a quat4
     *
     * @param {quat4} [quat] quat4 containing values to initialize with
     *
     * @returns {quat4} New quat4
     */
    quat4.create = function (quat) {
        var dest = new MatrixArray(4);

        if (quat) {
            dest[0] = quat[0];
            dest[1] = quat[1];
            dest[2] = quat[2];
            dest[3] = quat[3];
        } else {
            dest[0] = dest[1] = dest[2] = dest[3] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a quat4, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value
     * @param {number} w W value

     * @returns {quat4} New quat4
     */
    quat4.createFrom = function (x, y, z, w) {
        var dest = new MatrixArray(4);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = w;

        return dest;
    };

    /**
     * Copies the values of one quat4 to another
     *
     * @param {quat4} quat quat4 containing values to copy
     * @param {quat4} dest quat4 receiving copied values
     *
     * @returns {quat4} dest
     */
    quat4.set = function (quat, dest) {
        dest[0] = quat[0];
        dest[1] = quat[1];
        dest[2] = quat[2];
        dest[3] = quat[3];

        return dest;
    };

    /**
     * Creates a new identity Quat4
     *
     * @param {quat4} [dest] quat4 receiving copied values
     *
     * @returns {quat4} dest is specified, new quat4 otherwise
     */
    quat4.identity = function (dest) {
        if (!dest) { dest = quat4.create(); }
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    var identityQuat4 = quat4.identity();

    /**
     * Calculates the W component of a quat4 from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat4} quat quat4 to calculate W component of
     * @param {quat4} [dest] quat4 receiving calculated values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.calculateW = function (quat, dest) {
        var x = quat[0], y = quat[1], z = quat[2];

        if (!dest || quat === dest) {
            quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
            return quat;
        }
        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
        return dest;
    };

    /**
     * Calculates the dot product of two quaternions
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     *
     * @return {number} Dot product of quat and quat2
     */
    quat4.dot = function(quat, quat2){
        return quat[0]*quat2[0] + quat[1]*quat2[1] + quat[2]*quat2[2] + quat[3]*quat2[3];
    };

    /**
     * Calculates the inverse of a quat4
     *
     * @param {quat4} quat quat4 to calculate inverse of
     * @param {quat4} [dest] quat4 receiving inverse values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.inverse = function(quat, dest) {
        var q0 = quat[0], q1 = quat[1], q2 = quat[2], q3 = quat[3],
            dot = q0*q0 + q1*q1 + q2*q2 + q3*q3,
            invDot = dot ? 1.0/dot : 0;
        
        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
        
        if(!dest || quat === dest) {
            quat[0] *= -invDot;
            quat[1] *= -invDot;
            quat[2] *= -invDot;
            quat[3] *= invDot;
            return quat;
        }
        dest[0] = -quat[0]*invDot;
        dest[1] = -quat[1]*invDot;
        dest[2] = -quat[2]*invDot;
        dest[3] = quat[3]*invDot;
        return dest;
    };


    /**
     * Calculates the conjugate of a quat4
     * If the quaternion is normalized, this function is faster than quat4.inverse and produces the same result.
     *
     * @param {quat4} quat quat4 to calculate conjugate of
     * @param {quat4} [dest] quat4 receiving conjugate values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.conjugate = function (quat, dest) {
        if (!dest || quat === dest) {
            quat[0] *= -1;
            quat[1] *= -1;
            quat[2] *= -1;
            return quat;
        }
        dest[0] = -quat[0];
        dest[1] = -quat[1];
        dest[2] = -quat[2];
        dest[3] = quat[3];
        return dest;
    };

    /**
     * Calculates the length of a quat4
     *
     * Params:
     * @param {quat4} quat quat4 to calculate length of
     *
     * @returns Length of quat
     */
    quat4.length = function (quat) {
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };

    /**
     * Generates a unit quaternion of the same direction as the provided quat4
     * If quaternion length is 0, returns [0, 0, 0, 0]
     *
     * @param {quat4} quat quat4 to normalize
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.normalize = function (quat, dest) {
        if (!dest) { dest = quat; }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            len = Math.sqrt(x * x + y * y + z * z + w * w);
        if (len === 0) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            return dest;
        }
        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        dest[3] = w * len;

        return dest;
    };

    /**
     * Performs quaternion addition
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.add = function (quat, quat2, dest) {
        if(!dest || quat === dest) {
            quat[0] += quat2[0];
            quat[1] += quat2[1];
            quat[2] += quat2[2];
            quat[3] += quat2[3];
            return quat;
        }
        dest[0] = quat[0]+quat2[0];
        dest[1] = quat[1]+quat2[1];
        dest[2] = quat[2]+quat2[2];
        dest[3] = quat[3]+quat2[3];
        return dest;
    };

    /**
     * Performs a quaternion multiplication
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.multiply = function (quat, quat2, dest) {
        if (!dest) { dest = quat; }

        var qax = quat[0], qay = quat[1], qaz = quat[2], qaw = quat[3],
            qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];

        dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        return dest;
    };

    /**
     * Transforms a vec3 with the given quaternion
     *
     * @param {quat4} quat quat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns dest if specified, vec otherwise
     */
    quat4.multiplyVec3 = function (quat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3],

            // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return dest;
    };

    /**
     * Multiplies the components of a quaternion by a scalar value
     *
     * @param {quat4} quat to scale
     * @param {number} val Value to scale by
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.scale = function (quat, val, dest) {
        if(!dest || quat === dest) {
            quat[0] *= val;
            quat[1] *= val;
            quat[2] *= val;
            quat[3] *= val;
            return quat;
        }
        dest[0] = quat[0]*val;
        dest[1] = quat[1]*val;
        dest[2] = quat[2]*val;
        dest[3] = quat[3]*val;
        return dest;
    };

    /**
     * Calculates a 3x3 matrix from the given quat4
     *
     * @param {quat4} quat quat4 to create matrix from
     * @param {mat3} [dest] mat3 receiving operation result
     *
     * @returns {mat3} dest if specified, a new mat3 otherwise
     */
    quat4.toMat3 = function (quat, dest) {
        if (!dest) { dest = mat3.create(); }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;

        dest[3] = xy - wz;
        dest[4] = 1 - (xx + zz);
        dest[5] = yz + wx;

        dest[6] = xz + wy;
        dest[7] = yz - wx;
        dest[8] = 1 - (xx + yy);

        return dest;
    };

    /**
     * Calculates a 4x4 matrix from the given quat4
     *
     * @param {quat4} quat quat4 to create matrix from
     * @param {mat4} [dest] mat4 receiving operation result
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    quat4.toMat4 = function (quat, dest) {
        if (!dest) { dest = mat4.create(); }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;

        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;

        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;

        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Performs a spherical linear interpolation between two quat4
     *
     * @param {quat4} quat First quaternion
     * @param {quat4} quat2 Second quaternion
     * @param {number} slerp Interpolation amount between the two inputs
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.slerp = function (quat, quat2, slerp, dest) {
        if (!dest) { dest = quat; }

        var cosHalfTheta = quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3],
            halfTheta,
            sinHalfTheta,
            ratioA,
            ratioB;

        if (Math.abs(cosHalfTheta) >= 1.0) {
            if (dest !== quat) {
                dest[0] = quat[0];
                dest[1] = quat[1];
                dest[2] = quat[2];
                dest[3] = quat[3];
            }
            return dest;
        }

        halfTheta = Math.acos(cosHalfTheta);
        sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (Math.abs(sinHalfTheta) < 0.001) {
            dest[0] = (quat[0] * 0.5 + quat2[0] * 0.5);
            dest[1] = (quat[1] * 0.5 + quat2[1] * 0.5);
            dest[2] = (quat[2] * 0.5 + quat2[2] * 0.5);
            dest[3] = (quat[3] * 0.5 + quat2[3] * 0.5);
            return dest;
        }

        ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
        ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;

        dest[0] = (quat[0] * ratioA + quat2[0] * ratioB);
        dest[1] = (quat[1] * ratioA + quat2[1] * ratioB);
        dest[2] = (quat[2] * ratioA + quat2[2] * ratioB);
        dest[3] = (quat[3] * ratioA + quat2[3] * ratioB);

        return dest;
    };

    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * If dest is omitted, a new quaternion will be created.
     *
     * @param {mat3}  mat    the rotation matrix
     * @param {quat4} [dest] an optional receiving quaternion
     *
     * @returns {quat4} the quaternion constructed from the rotation matrix
     *
     */
    quat4.fromRotationMatrix = function(mat, dest) {
        if (!dest) dest = quat4.create();
        
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".

        var fTrace = mat[0] + mat[4] + mat[8];
        var fRoot;

        if ( fTrace > 0.0 ) {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0);  // 2w
            dest[3] = 0.5 * fRoot;
            fRoot = 0.5/fRoot;  // 1/(4w)
            dest[0] = (mat[7]-mat[5])*fRoot;
            dest[1] = (mat[2]-mat[6])*fRoot;
            dest[2] = (mat[3]-mat[1])*fRoot;
        } else {
            // |w| <= 1/2
            var s_iNext = quat4.fromRotationMatrix.s_iNext = quat4.fromRotationMatrix.s_iNext || [1,2,0];
            var i = 0;
            if ( mat[4] > mat[0] )
              i = 1;
            if ( mat[8] > mat[i*3+i] )
              i = 2;
            var j = s_iNext[i];
            var k = s_iNext[j];
            
            fRoot = Math.sqrt(mat[i*3+i]-mat[j*3+j]-mat[k*3+k] + 1.0);
            dest[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            dest[3] = (mat[k*3+j] - mat[j*3+k]) * fRoot;
            dest[j] = (mat[j*3+i] + mat[i*3+j]) * fRoot;
            dest[k] = (mat[k*3+i] + mat[i*3+k]) * fRoot;
        }
        
        return dest;
    };

    /**
     * Alias. See the description for quat4.fromRotationMatrix().
     */
    mat3.toQuat4 = quat4.fromRotationMatrix;

    (function() {
        var mat = mat3.create();
        
        /**
         * Creates a quaternion from the 3 given vectors. They must be perpendicular
         * to one another and represent the X, Y and Z axes.
         *
         * If dest is omitted, a new quat4 will be created.
         *
         * Example: The default OpenGL orientation has a view vector [0, 0, -1],
         * right vector [1, 0, 0], and up vector [0, 1, 0]. A quaternion representing
         * this orientation could be constructed with:
         *
         *   quat = quat4.fromAxes([0, 0, -1], [1, 0, 0], [0, 1, 0], quat4.create());
         *
         * @param {vec3}  view   the view vector, or direction the object is pointing in
         * @param {vec3}  right  the right vector, or direction to the "right" of the object
         * @param {vec3}  up     the up vector, or direction towards the object's "up"
         * @param {quat4} [dest] an optional receiving quat4
         *
         * @returns {quat4} dest
         **/
        quat4.fromAxes = function(view, right, up, dest) {
            mat[0] = right[0];
            mat[3] = right[1];
            mat[6] = right[2];

            mat[1] = up[0];
            mat[4] = up[1];
            mat[7] = up[2];

            mat[2] = view[0];
            mat[5] = view[1];
            mat[8] = view[2];

            return quat4.fromRotationMatrix(mat, dest);
        };
    })();

    /**
     * Sets a quat4 to the Identity and returns it.
     *
     * @param {quat4} [dest] quat4 to set. If omitted, a
     * new quat4 will be created.
     *
     * @returns {quat4} dest
     */
    quat4.identity = function(dest) {
        if (!dest) dest = quat4.create();
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    /**
     * Sets a quat4 from the given angle and rotation axis,
     * then returns it. If dest is not given, a new quat4 is created.
     *
     * @param {Number} angle  the angle in radians
     * @param {vec3}   axis   the axis around which to rotate
     * @param {quat4}  [dest] the optional quat4 to store the result
     *
     * @returns {quat4} dest
     **/
    quat4.fromAngleAxis = function(angle, axis, dest) {
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
        if (!dest) dest = quat4.create();
        
        var half = angle * 0.5;
        var s = Math.sin(half);
        dest[3] = Math.cos(half);
        dest[0] = s * axis[0];
        dest[1] = s * axis[1];
        dest[2] = s * axis[2];
        
        return dest;
    };

    /**
     * Stores the angle and axis in a vec4, where the XYZ components represent
     * the axis and the W (4th) component is the angle in radians.
     *
     * If dest is not given, src will be modified in place and returned, after
     * which it should not be considered not a quaternion (just an axis and angle).
     *
     * @param {quat4} quat   the quaternion whose angle and axis to store
     * @param {vec4}  [dest] the optional vec4 to receive the data
     *
     * @returns {vec4} dest
     */
    quat4.toAngleAxis = function(src, dest) {
        if (!dest) dest = src;
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)

        var sqrlen = src[0]*src[0]+src[1]*src[1]+src[2]*src[2];
        if (sqrlen > 0)
        {
            dest[3] = 2 * Math.acos(src[3]);
            var invlen = glMath.invsqrt(sqrlen);
            dest[0] = src[0]*invlen;
            dest[1] = src[1]*invlen;
            dest[2] = src[2]*invlen;
        } else {
            // angle is 0 (mod 2*pi), so any axis will do
            dest[3] = 0;
            dest[0] = 1;
            dest[1] = 0;
            dest[2] = 0;
        }
        
        return dest;
    };

    /**
     * Returns a string representation of a quaternion
     *
     * @param {quat4} quat quat4 to represent as a string
     *
     * @returns {string} String representation of quat
     */
    quat4.str = function (quat) {
        return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']';
    };
    
    /**
     * @class 2 Dimensional Vector
     * @name vec2
     */
    var vec2 = {};
     
    /**
     * Creates a new vec2, initializing it from vec if vec
     * is given.
     *
     * @param {vec2} [vec] the vector's initial contents
     * @returns {vec2} a new 2D vector
     */
    vec2.create = function(vec) {
        var dest = new MatrixArray(2);

        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
        } else {
            dest[0] = 0;
            dest[1] = 0;
        }
        return dest;
    };

    /**
     * Creates a new instance of a vec2, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value

     * @returns {vec2} New vec2
     */
    vec2.createFrom = function (x, y) {
        var dest = new MatrixArray(2);

        dest[0] = x;
        dest[1] = y;

        return dest;
    };
    
    /**
     * Adds the vec2's together. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec2} vecA the first operand
     * @param {vec2} vecB the second operand
     * @param {vec2} [dest] the optional receiving vector
     * @returns {vec2} dest
     */
    vec2.add = function(vecA, vecB, dest) {
        if (!dest) dest = vecB;
        dest[0] = vecA[0] + vecB[0];
        dest[1] = vecA[1] + vecB[1];
        return dest;
    };
    
    /**
     * Subtracts vecB from vecA. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec2} vecA the first operand
     * @param {vec2} vecB the second operand
     * @param {vec2} [dest] the optional receiving vector
     * @returns {vec2} dest
     */
    vec2.subtract = function(vecA, vecB, dest) {
        if (!dest) dest = vecB;
        dest[0] = vecA[0] - vecB[0];
        dest[1] = vecA[1] - vecB[1];
        return dest;
    };
    
    /**
     * Multiplies vecA with vecB. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec2} vecA the first operand
     * @param {vec2} vecB the second operand
     * @param {vec2} [dest] the optional receiving vector
     * @returns {vec2} dest
     */
    vec2.multiply = function(vecA, vecB, dest) {
        if (!dest) dest = vecB;
        dest[0] = vecA[0] * vecB[0];
        dest[1] = vecA[1] * vecB[1];
        return dest;
    };
    
    /**
     * Divides vecA by vecB. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec2} vecA the first operand
     * @param {vec2} vecB the second operand
     * @param {vec2} [dest] the optional receiving vector
     * @returns {vec2} dest
     */
    vec2.divide = function(vecA, vecB, dest) {
        if (!dest) dest = vecB;
        dest[0] = vecA[0] / vecB[0];
        dest[1] = vecA[1] / vecB[1];
        return dest;
    };
    
    /**
     * Scales vecA by some scalar number. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecA.
     *
     * This is the same as multiplying each component of vecA
     * by the given scalar.
     *
     * @param {vec2}   vecA the vector to be scaled
     * @param {Number} scalar the amount to scale the vector by
     * @param {vec2}   [dest] the optional receiving vector
     * @returns {vec2} dest
     */
    vec2.scale = function(vecA, scalar, dest) {
        if (!dest) dest = vecA;
        dest[0] = vecA[0] * scalar;
        dest[1] = vecA[1] * scalar;
        return dest;
    };

    /**
     * Calculates the euclidian distance between two vec2
     *
     * Params:
     * @param {vec2} vecA First vector
     * @param {vec2} vecB Second vector
     *
     * @returns {number} Distance between vecA and vecB
     */
    vec2.dist = function (vecA, vecB) {
        var x = vecB[0] - vecA[0],
            y = vecB[1] - vecA[1];
        return Math.sqrt(x*x + y*y);
    };

    /**
     * Copies the values of one vec2 to another
     *
     * @param {vec2} vec vec2 containing values to copy
     * @param {vec2} dest vec2 receiving copied values
     *
     * @returns {vec2} dest
     */
    vec2.set = function (vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        return dest;
    };

    /**
     * Negates the components of a vec2
     *
     * @param {vec2} vec vec2 to negate
     * @param {vec2} [dest] vec2 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec2} dest if specified, vec otherwise
     */
    vec2.negate = function (vec, dest) {
        if (!dest) { dest = vec; }
        dest[0] = -vec[0];
        dest[1] = -vec[1];
        return dest;
    };

    /**
     * Normlize a vec2
     *
     * @param {vec2} vec vec2 to normalize
     * @param {vec2} [dest] vec2 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec2} dest if specified, vec otherwise
     */
    vec2.normalize = function (vec, dest) {
        if (!dest) { dest = vec; }
        var mag = vec[0] * vec[0] + vec[1] * vec[1];
        if (mag > 0) {
            mag = Math.sqrt(mag);
            dest[0] = vec[0] / mag;
            dest[1] = vec[1] / mag;
        } else {
            dest[0] = dest[1] = 0;
        }
        return dest;
    };

    /**
     * Computes the cross product of two vec2's. Note that the cross product must by definition
     * produce a 3D vector. If a dest vector is given, it will contain the resultant 3D vector.
     * Otherwise, a scalar number will be returned, representing the vector's Z coordinate, since
     * its X and Y must always equal 0.
     *
     * Examples:
     *    var crossResult = vec3.create();
     *    vec2.cross([1, 2], [3, 4], crossResult);
     *    //=> [0, 0, -2]
     *
     *    vec2.cross([1, 2], [3, 4]);
     *    //=> -2
     *
     * See http://stackoverflow.com/questions/243945/calculating-a-2d-vectors-cross-product
     * for some interesting facts.
     *
     * @param {vec2} vecA left operand
     * @param {vec2} vecB right operand
     * @param {vec2} [dest] optional vec2 receiving result. If not specified a scalar is returned
     *
     */
    vec2.cross = function (vecA, vecB, dest) {
        var z = vecA[0] * vecB[1] - vecA[1] * vecB[0];
        if (!dest) return z;
        dest[0] = dest[1] = 0;
        dest[2] = z;
        return dest;
    };
    
    /**
     * Caclulates the length of a vec2
     *
     * @param {vec2} vec vec2 to calculate length of
     *
     * @returns {Number} Length of vec
     */
    vec2.length = function (vec) {
      var x = vec[0], y = vec[1];
      return Math.sqrt(x * x + y * y);
    };

    /**
     * Caclulates the dot product of two vec2s
     *
     * @param {vec3} vecA First operand
     * @param {vec3} vecB Second operand
     *
     * @returns {Number} Dot product of vecA and vecB
     */
    vec2.dot = function (vecA, vecB) {
        return vecA[0] * vecB[0] + vecA[1] * vecB[1];
    };
    
    /**
     * Generates a 2D unit vector pointing from one vector to another
     *
     * @param {vec2} vecA Origin vec2
     * @param {vec2} vecB vec2 to point to
     * @param {vec2} [dest] vec2 receiving operation result. If not specified result is written to vecA
     *
     * @returns {vec2} dest if specified, vecA otherwise
     */
    vec2.direction = function (vecA, vecB, dest) {
        if (!dest) { dest = vecA; }

        var x = vecA[0] - vecB[0],
            y = vecA[1] - vecB[1],
            len = x * x + y * y;

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        }

        len = 1 / Math.sqrt(len);
        dest[0] = x * len;
        dest[1] = y * len;
        return dest;
    };

    /**
     * Performs a linear interpolation between two vec2
     *
     * @param {vec2} vecA First vector
     * @param {vec2} vecB Second vector
     * @param {Number} lerp Interpolation amount between the two inputs
     * @param {vec2} [dest] vec2 receiving operation result. If not specified result is written to vecA
     *
     * @returns {vec2} dest if specified, vecA otherwise
     */
    vec2.lerp = function (vecA, vecB, lerp, dest) {
        if (!dest) { dest = vecA; }
        dest[0] = vecA[0] + lerp * (vecB[0] - vecA[0]);
        dest[1] = vecA[1] + lerp * (vecB[1] - vecA[1]);
        return dest;
    };

    /**
     * Returns a string representation of a vector
     *
     * @param {vec2} vec Vector to represent as a string
     *
     * @returns {String} String representation of vec
     */
    vec2.str = function (vec) {
        return '[' + vec[0] + ', ' + vec[1] + ']';
    };
    
    /**
     * @class 2x2 Matrix
     * @name mat2
     */
    var mat2 = {};
    
    /**
     * Creates a new 2x2 matrix. If src is given, the new matrix
     * is initialized to those values.
     *
     * @param {mat2} [src] the seed values for the new matrix, if any
     * @returns {mat2} a new matrix
     */
    mat2.create = function(src) {
        var dest = new MatrixArray(4);
        
        if (src) {
            dest[0] = src[0];
            dest[1] = src[1];
            dest[2] = src[2];
            dest[3] = src[3];
        } else {
            dest[0] = dest[1] = dest[2] = dest[3] = 0;
        }
        return dest;
    };

    /**
     * Creates a new instance of a mat2, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m10
     * @param {number} m11

     * @returns {mat2} New mat2
     */
    mat2.createFrom = function (m00, m01, m10, m11) {
        var dest = new MatrixArray(4);

        dest[0] = m00;
        dest[1] = m01;
        dest[2] = m10;
        dest[3] = m11;

        return dest;
    };
    
    /**
     * Copies the values of one mat2 to another
     *
     * @param {mat2} mat mat2 containing values to copy
     * @param {mat2} dest mat2 receiving copied values
     *
     * @returns {mat2} dest
     */
    mat2.set = function (mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        return dest;
    };

    /**
     * Sets a mat2 to an identity matrix
     *
     * @param {mat2} [dest] mat2 to set. If omitted a new one will be created.
     *
     * @returns {mat2} dest
     */
    mat2.identity = function (dest) {
        if (!dest) { dest = mat2.create(); }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    /**
     * Transposes a mat2 (flips the values over the diagonal)
     *
     * @param {mat2} mat mat2 to transpose
     * @param {mat2} [dest] mat2 receiving transposed values. If not specified result is written to mat
     *
     * @param {mat2} dest if specified, mat otherwise
     */
    mat2.transpose = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a00 = mat[1];
            mat[1] = mat[2];
            mat[2] = a00;
            return mat;
        }
        
        dest[0] = mat[0];
        dest[1] = mat[2];
        dest[2] = mat[1];
        dest[3] = mat[3];
        return dest;
    };

    /**
     * Calculates the determinant of a mat2
     *
     * @param {mat2} mat mat2 to calculate determinant of
     *
     * @returns {Number} determinant of mat
     */
    mat2.determinant = function (mat) {
      return mat[0] * mat[3] - mat[2] * mat[1];
    };
    
    /**
     * Calculates the inverse matrix of a mat2
     *
     * @param {mat2} mat mat2 to calculate inverse of
     * @param {mat2} [dest] mat2 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat2} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat2.inverse = function (mat, dest) {
        if (!dest) { dest = mat; }
        var a0 = mat[0], a1 = mat[1], a2 = mat[2], a3 = mat[3];
        var det = a0 * a3 - a2 * a1;
        if (!det) return null;
        
        det = 1.0 / det;
        dest[0] =  a3 * det;
        dest[1] = -a1 * det;
        dest[2] = -a2 * det;
        dest[3] =  a0 * det;
        return dest;
    };
    
    /**
     * Performs a matrix multiplication
     *
     * @param {mat2} matA First operand
     * @param {mat2} matB Second operand
     * @param {mat2} [dest] mat2 receiving operation result. If not specified result is written to matA
     *
     * @returns {mat2} dest if specified, matA otherwise
     */
    mat2.multiply = function (matA, matB, dest) {
        if (!dest) { dest = matA; }
        var a11 = matA[0],
            a12 = matA[1],
            a21 = matA[2],
            a22 = matA[3];
        dest[0] = a11 * matB[0] + a12 * matB[2];
        dest[1] = a11 * matB[1] + a12 * matB[3];
        dest[2] = a21 * matB[0] + a22 * matB[2];
        dest[3] = a21 * matB[1] + a22 * matB[3];
        return dest;
    };

    /**
     * Rotates a 2x2 matrix by an angle
     *
     * @param {mat2}   mat   The matrix to rotate
     * @param {Number} angle The angle in radians
     * @param {mat2} [dest]  Optional mat2 receiving the result. If omitted mat will be used.
     *
     * @returns {mat2} dest if specified, mat otherwise
     */
    mat2.rotate = function (mat, angle, dest) {
        if (!dest) { dest = mat; }
        var a11 = mat[0],
            a12 = mat[1],
            a21 = mat[2],
            a22 = mat[3],
            s = Math.sin(angle),
            c = Math.cos(angle);
        dest[0] = a11 *  c + a12 * s;
        dest[1] = a11 * -s + a12 * c;
        dest[2] = a21 *  c + a22 * s;
        dest[3] = a21 * -s + a22 * c;
        return dest;
    };

    /**
     * Multiplies the vec2 by the given 2x2 matrix
     *
     * @param {mat2} matrix the 2x2 matrix to multiply against
     * @param {vec2} vec    the vector to multiply
     * @param {vec2} [dest] an optional receiving vector. If not given, vec is used.
     *
     * @returns {vec2} The multiplication result
     **/
    mat2.multiplyVec2 = function(matrix, vec, dest) {
      if (!dest) dest = vec;
      var x = vec[0], y = vec[1];
      dest[0] = x * matrix[0] + y * matrix[1];
      dest[1] = x * matrix[2] + y * matrix[3];
      return dest;
    };
    
    /**
     * Scales the mat2 by the dimensions in the given vec2
     *
     * @param {mat2} matrix the 2x2 matrix to scale
     * @param {vec2} vec    the vector containing the dimensions to scale by
     * @param {vec2} [dest] an optional receiving mat2. If not given, matrix is used.
     *
     * @returns {mat2} dest if specified, matrix otherwise
     **/
    mat2.scale = function(matrix, vec, dest) {
      if (!dest) { dest = matrix; }
      var a11 = matrix[0],
          a12 = matrix[1],
          a21 = matrix[2],
          a22 = matrix[3],
          b11 = vec[0],
          b22 = vec[1];
      dest[0] = a11 * b11;
      dest[1] = a12 * b22;
      dest[2] = a21 * b11;
      dest[3] = a22 * b22;
      return dest;
    };

    /**
     * Returns a string representation of a mat2
     *
     * @param {mat2} mat mat2 to represent as a string
     *
     * @param {String} String representation of mat
     */
    mat2.str = function (mat) {
        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] + ']';
    };
    
    /**
     * @class 4 Dimensional Vector
     * @name vec4
     */
    var vec4 = {};
     
    /**
     * Creates a new vec4, initializing it from vec if vec
     * is given.
     *
     * @param {vec4} [vec] the vector's initial contents
     * @returns {vec4} a new 2D vector
     */
    vec4.create = function(vec) {
        var dest = new MatrixArray(4);
        
        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];
            dest[3] = vec[3];
        } else {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
        }
        return dest;
    };

    /**
     * Creates a new instance of a vec4, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value
     * @param {number} w W value

     * @returns {vec4} New vec4
     */
    vec4.createFrom = function (x, y, z, w) {
        var dest = new MatrixArray(4);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = w;

        return dest;
    };
    
    /**
     * Adds the vec4's together. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec4} vecA the first operand
     * @param {vec4} vecB the second operand
     * @param {vec4} [dest] the optional receiving vector
     * @returns {vec4} dest
     */
    vec4.add = function(vecA, vecB, dest) {
      if (!dest) dest = vecB;
      dest[0] = vecA[0] + vecB[0];
      dest[1] = vecA[1] + vecB[1];
      dest[2] = vecA[2] + vecB[2];
      dest[3] = vecA[3] + vecB[3];
      return dest;
    };
    
    /**
     * Subtracts vecB from vecA. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec4} vecA the first operand
     * @param {vec4} vecB the second operand
     * @param {vec4} [dest] the optional receiving vector
     * @returns {vec4} dest
     */
    vec4.subtract = function(vecA, vecB, dest) {
      if (!dest) dest = vecB;
      dest[0] = vecA[0] - vecB[0];
      dest[1] = vecA[1] - vecB[1];
      dest[2] = vecA[2] - vecB[2];
      dest[3] = vecA[3] - vecB[3];
      return dest;
    };
    
    /**
     * Multiplies vecA with vecB. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec4} vecA the first operand
     * @param {vec4} vecB the second operand
     * @param {vec4} [dest] the optional receiving vector
     * @returns {vec4} dest
     */
    vec4.multiply = function(vecA, vecB, dest) {
      if (!dest) dest = vecB;
      dest[0] = vecA[0] * vecB[0];
      dest[1] = vecA[1] * vecB[1];
      dest[2] = vecA[2] * vecB[2];
      dest[3] = vecA[3] * vecB[3];
      return dest;
    };
    
    /**
     * Divides vecA by vecB. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecB.
     *
     * @param {vec4} vecA the first operand
     * @param {vec4} vecB the second operand
     * @param {vec4} [dest] the optional receiving vector
     * @returns {vec4} dest
     */
    vec4.divide = function(vecA, vecB, dest) {
      if (!dest) dest = vecB;
      dest[0] = vecA[0] / vecB[0];
      dest[1] = vecA[1] / vecB[1];
      dest[2] = vecA[2] / vecB[2];
      dest[3] = vecA[3] / vecB[3];
      return dest;
    };
    
    /**
     * Scales vecA by some scalar number. If dest is given, the result
     * is stored there. Otherwise, the result is stored in vecA.
     *
     * This is the same as multiplying each component of vecA
     * by the given scalar.
     *
     * @param {vec4}   vecA the vector to be scaled
     * @param {Number} scalar the amount to scale the vector by
     * @param {vec4}   [dest] the optional receiving vector
     * @returns {vec4} dest
     */
    vec4.scale = function(vecA, scalar, dest) {
      if (!dest) dest = vecA;
      dest[0] = vecA[0] * scalar;
      dest[1] = vecA[1] * scalar;
      dest[2] = vecA[2] * scalar;
      dest[3] = vecA[3] * scalar;
      return dest;
    };

    /**
     * Copies the values of one vec4 to another
     *
     * @param {vec4} vec vec4 containing values to copy
     * @param {vec4} dest vec4 receiving copied values
     *
     * @returns {vec4} dest
     */
    vec4.set = function (vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];
        dest[3] = vec[3];
        return dest;
    };

    /**
     * Negates the components of a vec4
     *
     * @param {vec4} vec vec4 to negate
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec4} dest if specified, vec otherwise
     */
    vec4.negate = function (vec, dest) {
        if (!dest) { dest = vec; }
        dest[0] = -vec[0];
        dest[1] = -vec[1];
        dest[2] = -vec[2];
        dest[3] = -vec[3];
        return dest;
    };

    /**
     * Performs a linear interpolation between two vec4
     *
     * @param {vec4} vecA First vector
     * @param {vec4} vecB Second vector
     * @param {Number} lerp Interpolation amount between the two inputs
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vecA
     *
     * @returns {vec4} dest if specified, vecA otherwise
     */
    vec4.lerp = function (vecA, vecB, lerp, dest) {
        if (!dest) { dest = vecA; }
        dest[0] = vecA[0] + lerp * (vecB[0] - vecA[0]);
        dest[1] = vecA[1] + lerp * (vecB[1] - vecA[1]);
        dest[2] = vecA[2] + lerp * (vecB[2] - vecA[2]);
        dest[3] = vecA[3] + lerp * (vecB[3] - vecA[3]);
        return dest;
    };

    /**
     * Returns a string representation of a vector
     *
     * @param {vec4} vec Vector to represent as a string
     *
     * @returns {String} String representation of vec
     */
    vec4.str = function (vec) {
        return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ', ' + vec[3] + ']';
    };

    /*
     * Exports
     */

    if(root) {
        root.glMatrixArrayType = MatrixArray;
        root.MatrixArray = MatrixArray;
        root.setMatrixArrayType = setMatrixArrayType;
        root.determineMatrixArrayType = determineMatrixArrayType;
        root.glMath = glMath;
        root.vec2 = vec2;
        root.vec3 = vec3;
        root.vec4 = vec4;
        root.mat2 = mat2;
        root.mat3 = mat3;
        root.mat4 = mat4;
        root.quat4 = quat4;
    }

    return {
        glMatrixArrayType: MatrixArray,
        MatrixArray: MatrixArray,
        setMatrixArrayType: setMatrixArrayType,
        determineMatrixArrayType: determineMatrixArrayType,
        glMath: glMath,
        vec2: vec2,
        vec3: vec3,
        vec4: vec4,
        mat2: mat2,
        mat3: mat3,
        mat4: mat4,
        quat4: quat4
    };
}));
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  
/**
 * Creates a vxlLandmark object and associates it with a vxlCamera. 
 * 
 * 
 * @class Stores the camera state so it can be retrieved later 
 * @constructor this is the constructor doc
 * @param {vxlCamera} camera
 * @author Diego Cantor
 * @see vxlCamera
  */

function vxlLandmark(name, camera) {
	
	if(!( camera instanceof vxlCamera)) {
		alert('vxlLandmark needs a vxlCamera as argument');
		return null;
	}
	
	this.name             = name;
	this.camera           = camera;
	
	var c = this.camera;
    
    this._fov             = c._fov;
    this.Z_NEAR           = c.Z_NEAR;    
    this.Z_FAR            = c.Z_FAR;
    
    this._matrix          = mat4.set(c._matrix, mat4.create());
    this._right           = vec3.set(c._right, vec3.create());
    this._up              = vec3.set(c._up, vec3.create());
    this._normal          = vec3.set(c._normal, vec3.create());   
    this._position        = vec3.set(c._position, vec3.create());
    this._focalPoint      = vec3.set(c._focalPoint, vec3.create());
    this._distanceVector  = vec3.set(c._distanceVector, vec3.create());
    
    this._azimuth       = c._azimuth;
    this._elevation     = c._elevation;
    this._roll          = c._roll;
    this._relAzimuth    = c._relAzimuth;
    this._relElevation  = c._relElevation;
    this._relRoll       = c._relRoll;
    this._dollyingStep  = c._dollyngStep; //dollying step
    this._distance      = c._distance;
    
    this._following     = c._following;
    this._trackingMode  = c._trackingMode;
};


/**
 * Updates the camera with the state stored in vxlLandmark.
 */
vxlLandmark.prototype.retrieve = function() {
    
	var c = this.camera;
	
	c._fov             = this._fov;
    c.Z_NEAR           = this.Z_NEAR;    
    c.Z_FAR            = this.Z_FAR;
    
    c._matrix          = mat4.set(this._matrix, mat4.create());
    c._right           = vec3.set(this._right, vec3.create());
    c._up              = vec3.set(this._up, vec3.create());
    c._normal          = vec3.set(this._normal, vec3.create());   
    c._position        = vec3.set(this._position, vec3.create());
    c._focalPoint      = vec3.set(this._focalPoint, vec3.create());
    c._distanceVector  = vec3.set(this._distanceVector, vec3.create());
    
    c._azimuth       = this._azimuth;
    c._elevation     = this._elevation;
    c._roll          = this._roll;
    c._relAzimuth    = this._relAzimuth;
    c._relElevation  = this._relElevation;
    c._relRoll       = this._relRoll;
    c._dollyingStep  = this._dollyngStep; //dollying step
    c._distance      = this._distance;
    
    c._following     = this._following;
    c._trackingMode  = this._trackingMode;
    
    c.refresh();
};
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  

/**
 * 
 * A vxlCamera object simplifies WebGL programming by providing a simple object interface to the lower level
 * matrix manipulations that are required to view a 3D scene.
 * 
 * When moving and rotating the camera, such matrices are updated and Voxelent's Nucleo will use this information
 * in order to draw the scene accordingly to the camera position an orientation.
 * 
 * A vxlCamera object requires a vxlView to be created. Having said that, a vxlView can be associated with 
 * multiple cameras.
 * 
 * The azimuth, elevation and roll operations occur with respect to the standard coordinate system:
 * right =[1,0,0], up = [0,1,0] and normal 
 * of 
 * 
 * @class Like a real camera it moves around the 3D scene displaying the current point of view in the browser
 * @constructor Creates a vxlCamera. 
 * @param {vxlView} vw
 * @param {Object} t the type of camera 
 * @author Diego Cantor
 */
function vxlCamera(vw,t) {
    this.UID            = vxl.util.generateUID(); //unique identification key
    this.view           = vw;

    this._fov           = vxl.def.camera.fov;
    this.Z_NEAR         = vxl.def.camera.near;    
    this.Z_FAR          = vxl.def.camera.far;
    
    this._matrix 	      = mat4.identity();
    this._right 		  = vec3.createFrom(1, 0, 0);
	this._up              = vec3.createFrom(0, 1, 0);
	this._forward          = vec3.createFrom(0, 0, 1);	
	this._position        = vec3.createFrom(0, 0, 1);
	this._focalPoint      = vec3.createFrom(0, 0, 0);
	this._distanceVector  = vec3.createFrom(0, 0, 0);
    
    this._azimuth 	    = 0;
    this._elevation     = 0;
    this._roll          = 0;
	this._relAzimuth    = 0;
    this._relElevation  = 0;
    this._relRoll       = 0;
	this._dollyingStep  = 0; //dollying step
    this._distance      = 1;
    
    this._following     = undefined;
    this._trackingMode  = vxl.def.camera.tracking.DEFAULT;
    
    this.landmarks         = [];

	if (t != undefined && t !=null){
        this.type = t;
    }
    else {
        this.type = vxl.def.camera.type.EXPLORING;
    }
    
};

/**
 * Establishes the type of camera
 * @param {vxl.def.camera.type} type the type of camera
 * @param {vxl.def.camera.tracking} trackingMode if the camera is of tracking type, the tracking mode can be set as 
 * an optional parameter here.
 * @see {vxl.def.camera}
 */
vxlCamera.prototype.setType = function(type, trackingMode){
    
    if (type != vxl.def.camera.type.ORBITING && 
        type != vxl.def.camera.type.TRACKING &&
        type != vxl.def.camera.type.EXPLORING) {
        console.error('vxlCamera.setType ERROR type'+ type +' unknown. Setting camera to EXPLORING type.');
        this.type = vxl.def.camera.type.EXPLORING;
    }
    else {
        this.type = type
    }
    
    if (this.type  == vxl.def.camera.type.TRACKING && trackingMode != undefined){
        this.setTrackingMode(trackingMode);
    }
};

/**
 * Sets the tracking type of this camera when it follows an actor
 * <p> to set the tracking type of the camera <code>myCamera</code> you should make sure that your camera is of tracking type with:
 *  <code>myCamera.setType(vxl.def.camera.type.TRACKING)</code>.
 *  For instance:
 * </p>
 *  <pre class='prettyprint'>
 *  var actor = vxl.api.getActor('cone'); //from the current scene
 *  var camera = vxl.c.camera;
 *  camera.setType(vxl.def.camera.type.TRACKING);
 *  camera.setTrackingMode(vxl.def.camera.tracking.ROTATIONAL);
 *  camera.follow(actor);
 * </pre>
 * <p> a shorter way would be:</p>
 * <pre class='prettyprint'>
 *  var actor = vxl.api.getActor('cone'); //from the current scene
 *  var camera = vxl.c.camera;
 *  camera.setType(vxl.def.camera.type.TRACKING);
 *  camera.follow(actor, vxl.def.camera.tracking.ROTATIONAL);
 * </pre>
 * @see vxlCamera#follow, vxlCamera#setTrackingMode
 */
vxlCamera.prototype.setTrackingMode = function(mode){
    if (this.type != vxl.def.camera.type.TRACKING){
        alert("Impossible to set a tracking mode if the camera is not of tracking type");
        throw("Impossible to set a tracking mode if the camera is not of tracking type");
    }
    if (mode == undefined) return;
    this._trackingMode = mode;
};

/**
 * Follows a given actor. If this operation is called on an ORBITING camera,
 * the camera mode will change to be a TRACKING camera.
 * 
 * @param {vxlActor} actor actor to track
 * @param {String} trackingType one of the possible values of <code>vxl.def.camera.tracking</code>
 * @see {vxlCamera#setType, vxl.def.camera.tracking}
 */
vxlCamera.prototype.follow = function(actor, trackingType){
    this.setType(vxl.def.camera.type.TRACKING, trackingType);
    if (actor == undefined || actor == null){
        alert("vxlCamera.follow: Unable to follow undefined/null actor");
        console.error("vxlCamera.follow: Unable to follow undefined/null actor");
    }
    this._following = actor;
    actor.addTrackingCamera(this);
};

/**
 * Stops following an actor  
 */
vxlCamera.prototype.unfollow = function(){
    this._following.removeTrackingCamera(this);
    this._following = undefined;
};

/**
 * Updates the camera according to the current tracking mode. This method is a callback used by the 
 * vxlActor class to notify the camera of any actor transformations. This is applicable of course only when
 * this camera is following the actor passed as parameter here
 * @param {vxlActor} actor the actor being followed by this camera
 */
vxlCamera.prototype.updateWithActor = function(actor){
    if (this._following != actor) return; //fail safe
    
    switch(this._trackingMode){
        case vxl.def.camera.tracking.DEFAULT:
                break;
        case vxl.def.camera.tracking.ROTATIONAL:
        case vxl.def.camera.tracking.CINEMATIC:
                this.setFocalPoint(actor._position);
                break;
        case vxl.def.camera.tracking.TRANSLATIONAL:
                this.translate(actor._translation);  
                this.setFocalPoint(actor._position);      
                break;
    }
};
/**
 *<p>Sets the camera position in the scene
 * This method has three parameters x,y,z which represent the coordinates for 
 * the camera's position.
 * </p>
 * <p>
 * This method takes into account the current focal point. The camera will look at the
 * focal point after this operation. If you want to move the camera position and the focal point
 * simultaneously, then use <code>vxlCamera.translate</code>.
 * </p>
 *  
 *  * @param {Number, Array} x the x-coordinate. x can also be an Array [a,b,c] in this case the y and z parameters are discarded.
 * @param {Number} y the y-coordinate
 * @param {Number} z the z-coordinate
 * @see{vxlCamera#translate}
 */
vxlCamera.prototype.setPosition = function(x,y,z) {
    this._setPosition(x,y,z);
    this.setFocalPoint(this._focalPoint);
};

/**
 * Looks at a given point in space (sets the focal point of this camera).
 * 
 * Note: If the camera is doing cinematic tracking, the up vector will be affected.
 * @param {Number, Array, vec3} x it can be the x coordinate, a 3-dimensional Array or a vec3 (glMatrix)
 * @param {Number} y if x is a number, then this parameter corresponds to the y-coordinate
 * @param {Number} z if x is a number, then this parameter corresponds to the z-coordinate
 */
vxlCamera.prototype.setFocalPoint = function(x,y,z) {
    
    var up = vec3.create([0,1,0]);
    //var up = vec3.create(this._up);
    this._focalPoint = vxl.util.createVec3(x,y,z);
    
    if (this._trackingMode == vxl.def.camera.tracking.CINEMATIC){
        var d  = vec3.subtract(this._focalPoint, this._position, vec3.create());
        var x  = d[0], y = d[1],  z = d[2],  r  = vec3.length(d);
        var el =      Math.asin(y/r)  * vxl.def.rad2deg;
        var az = 90 + Math.atan2(z,x) * vxl.def.rad2deg;
        var m = mat4.identity();
        mat4.rotateY(m, az * vxl.def.deg2rad);
        mat4.rotateX(m, el * vxl.def.deg2rad);
        up = mat4.multiplyVec3(m, [0,1,0], vec3.create());
    }
    
    mat4.inverse(mat4.lookAt(this._position, this._focalPoint, up), this._matrix);
    
    this._getAxes();
    this._getDistance();
    this._getAngles();
};

/**
 * Position the camera to a given distance from the current focal point
 * @param {Number} d the distance
 * @TODO: REVIEW COMMENTED CODE
 */
vxlCamera.prototype.setDistance = function(d) {
    
    if(this._distance == d || d <0) {
        return;
    }

    this._distance = d;

    // Distance should be greater than .0002
    if(this._distance < 0.0002) {
        this._distance = 0.0002;
        console.warn(" vxlCamera.setDistance WARN: Distance is set to minimum (0.0002)");
    }
    
    this._dollyingStep = this._distance / 100;
    
    var pos = vec3.create();
    
    var d = this._distance;
    var n = this._forward;
    var f = this._focalPoint;
    
    pos[0] = d*n[0] + f[0];
    pos[1] = d*n[1] + f[1];
    pos[2] = d*n[2] + f[2];
    
    this._setPosition(pos);
};

/**
 * Changes the initial azimuth of the camera
 * @param {Number} el the azimuth increment in degrees
 */
vxlCamera.prototype.changeAzimuth = function(az){
    this.setAzimuth(this._azimuth + az);
};

/**
 * Changes the initial elevation of the camera
 * @param {Number} el the elevation increment in degrees
 */
vxlCamera.prototype.changeElevation = function(el){
    this.setElevation(this._elevation + el);
};


/**
 * Changes the initial roll of the camera
 * @param {Number} rl the roll increment in degrees
 */
vxlCamera.prototype.changeRoll = function(rl){
    this.roll(this._roll + rl);
};
/**
 * Sets the initial azimuth of the camera
 * @param {Number} el the azimuth in degrees
 */
vxlCamera.prototype.setAzimuth = function(az){
    this._azimuth = this._getAngle(az);
    this._computeMatrix();
    
    this._getAxes();
    if (this.type == vxl.def.camera.type.ORBITING || this.type == vxl.def.camera.type.EXPLORING){
        this._getPosition();
    }
    else if (this.type == vxl.def.camera.type.TRACKING){
        this._getFocalPoint();
    }
};

/**
 * Sets the initial elevation of the camera
 * @param {Number} el the elevation in degrees
 */
vxlCamera.prototype.setElevation = function(el){
    this._elevation =this._getAngle(el);
    this._computeMatrix();
    
    this._getAxes();
    if (this.type == vxl.def.camera.type.ORBITING || this.type == vxl.def.camera.type.EXPLORING){
        this._getPosition();
    }
    else if (this.type == vxl.def.camera.type.TRACKING){
        this._getFocalPoint();
    }
};

/**
 * Sets the initial roll of the camera
 * Rotates the camera around its view (forward) axis
 * @param {Number} angle the roll angle
 */
vxlCamera.prototype.setRoll = function(angle){
    this._roll = this._getAngle(angle);
    this._computeMatrix();
       
    this._getAxes();
    if (this.type == vxl.def.camera.type.ORBITING || this.type == vxl.def.camera.type.EXPLORING){
        this._getPosition();
    }
    else if (this.type == vxl.def.camera.type.TRACKING){
        this._getFocalPoint();
    }
};

/**
 * Changes the azimuth and elevation with respect to the current camera axes
 * @param {Number} azimuth the relative azimuth
 * @param {Number} elevation the relative elevation
 * @param {Number} roll the relative roll
 */
vxlCamera.prototype.rotate = function(azimuth,elevation,roll){
   
    if (this.type == vxl.def.camera.type.EXPLORING){ 
        
        azimuth   = this._getAngle(azimuth);
        elevation = this._getAngle(elevation);
        roll      = this._getAngle(roll);
        var rotX  = quat4.fromAngleAxis(elevation * vxl.def.deg2rad, [1,0,0]);
        var rotY  = quat4.fromAngleAxis(azimuth   * vxl.def.deg2rad, [0,1,0]);
        var rotZ  = quat4.fromAngleAxis(roll      * vxl.def.deg2rad, [0,0,1]); 
        var rotQ = quat4.multiply(rotY, rotX, quat4.create());
        rotQ = quat4.multiply(rotQ, rotZ, quat4.create());
        var rotMatrix = quat4.toMat4(rotQ);
        mat4.translate(this._matrix, [0,0,-this._distance]);
        mat4.multiply(this._matrix, rotMatrix);
        mat4.translate(this._matrix, [0,0,this._distance]);
    }
    else {
        if (Math.abs(this._elevation + elevation) > 90) return; //don't allow
        this._relElevation = this._getAngle(elevation);
        this._relAzimuth = this._getAngle(azimuth);
        this._relRoll = this._getAngle(roll);
        
        if (this.type == vxl.def.camera.type.TRACKING){
            //this._relElevation = -this._relElevation;
            //this._relAzimuth   = -this._relAzimuth;
            //this._relRoll      = -this._relRoll;
        }
        
        this._elevation += this._relElevation;
        this._azimuth += this._relAzimuth;
        this._roll += this._relRoll;
        
         this._computeMatrix();
    }
    
       
    this._getAxes();
    if (this.type == vxl.def.camera.type.ORBITING || this.type == vxl.def.camera.type.EXPLORING){
        this._getPosition();
    }
    else if (this.type == vxl.def.camera.type.TRACKING){
        this._getFocalPoint();
    }
    
   this._update();
};


/**
 * Performs the dollying operation in the direction indicated by the camera normal axis.
 * The dollying mechanism offered by a camera makes sure that the camera moves fast
 * towards the object when the distance is large and slow when it is very close to the object.
 * For that effect, every time that the new position  (after dollying) is calculated, the field dstep is computed.
 * 
 * @param {Number} value the dollying value 
 * 
 */
vxlCamera.prototype.dolly = function(value) {
    
	var    n =  this._forward; 
    var pos = vec3.create(this._position);
    var step = value*this._dollyingStep;
    pos[0] += step*n[0];
    pos[1] += step*n[1];
    pos[2] += step*n[2];
    
    this._setPosition(pos);
    if (this.type == vxl.def.camera.type.ORBITING || this.type == vxl.def.camera.type.DYNAMIC){
        this._getDistance();
    }
    else if (this.type == vxl.def.camera.type.TRACKING){
        //move the focal point and keep the distance
        vec3.add(pos, this._distanceVector, this._focalPoint);
    }
};

/**
 * Translates the camera side-to-side and up-and-down
 * @param {Number} dx the horizontal displacement
 * @param {Number} dy the vertical displacement
 */
vxlCamera.prototype.pan = function(tx, ty) {
    this.translate(tx,ty,0); 
};

/**
 * Translates the camera by a given vector 
 * 
 * @param {Number, Array, vec3} x it can be the x coordinate, a 3-dimensional Array or a vec3 (glMatrix)
 * @param {Number} y if x is a number, then this parameter corresponds to the y-coordinate
 * @param {Number} z if x is a number, then this parameter corresponds to the z-coordinate
 */
vxlCamera.prototype.translate = function(x,y,z){
    
    var coords = vxl.util.createVec3(x,y,z);
    var pos = vec3.create(this._position);
    
    vec3.add(pos, vec3.scale(this._right  ,coords[0], vec3.create()));
    vec3.add(pos, vec3.scale(this._up     ,coords[1],vec3.create()));    
    vec3.add(pos, vec3.scale(this._forward ,coords[2], vec3.create()));
    
    this._setPosition(pos);
    
   /* var fp  = vec3.create(this._focalPoint);
    vec3.add(fp, vec3.scale(this._right  ,x, vec3.create()));
    vec3.add(fp, vec3.scale(this._up     ,y, vec3.create()));    
    vec3.add(fp, vec3.scale(this._forward ,z, vec3.create()));*/
    
 
    //this.setFocalPoint(fp);
};




/**
 * This method updates the 3D scene
 * This is the call stack:
 * vxlCamera.refresh -> vxlView.refresh -> vxlRenderer.render
 */
vxlCamera.prototype.refresh = function() {
	this.view.refresh();
};


/**
 *  Looks at a given actor without displacing the camera
 *  @param {String, vxlActor} actor The name of the actor or the actor object this camera will look at. 
 */
vxlCamera.prototype.lookAt = function(actor){
    if (actor instanceof vxlActor){
          this.setFocalPoint(actor._position);
    }
    else if (typeof(actor) == 'string'){
        var actor = this.view.scene.getActorByName(actor);
        if (actor == undefined){
            throw 'vxlCamera.lookAt ERROR: The actor '+actorName+' does not exist'
        }
        else{
            this.setFocalPoint(actor._position);
        }
    }  
};


/**
 *  Performs a close up of an actor.
 *  @param {String, vxlActor}  actor The name of the actor or the actor object this camera will look at.
 *  @see <a href="http://en.wikipedia.org/wiki/Close-up">Close-up (Wikipedia)</a>
 */
vxlCamera.prototype.closeUp = function(actor){
	if (actor instanceof vxlActor){
        this._shot(actor._bb);
    }
    else if (typeof(actor) == 'string'){
        var actor = this.view.scene.getActorByName(actor);
        if (actor == undefined){
            throw 'vxlCamera.lookAt ERROR: The actor '+actorName+' does not exist'
        }
        else{
	       this._shot(actor._bb);
	    }
	}	
};

/**
 * The camera moves to a position where all the actors in the scene are viewed. The actors
 * are seen in full within their surrounding environment.
 * 
 * A long shot uses the global bounding box of the view's scene
 * @see <a href="http://en.wikipedia.org/wiki/Long_shot">Long Shot (Wikipedia)</a>
 */
vxlCamera.prototype.longShot = function() {
    this.view.scene.computeBoundingBox(); //perfect example of BY DEMAND UPDATING OF BB
    this._shot(this.view.scene.bb);
};

/**
 * Changes the field of view of the  camera
 * 
 * @param{Number} fov the field of view in degrees [0-360] 
 * @see <a href="http://en.wikipedia.org/wiki/Angle_of_view">Angle of view</a>
 */
vxlCamera.prototype.setFieldOfView = function(fov){
    this._fov = fov;
};

/**
 * Saves the current camera state in a landmark
 * @param {String} name the landmark name
 * @see vxlCameraState
 */
vxlCamera.prototype.setLandmark = function(name) {
    var l = new vxlLandmark (name, this);
    this.landmarks.push(l);
};

/**
 * Retrieves the landmark by name from the known landmarks
 * @param {String} name the landmark name
 * @see vxlCameraState
 */
vxlCamera.prototype.goTo = function(name) {
    for(var i=0, N =this.landmarks.length; i<N;i+=1){
        if (this.landmarks[i].name == name){
            this.landmarks[i].retrieve();
            return;
        }
    }
    console.warn('vxlCamera.goTo: landmark with name: '+name+', was not found');
};

/**
 * Returns a list of known landmarks
 */
vxlCamera.prototype.getLandmarks = function(){
  var lmarks = [];
  for(var i=0, N =this.landmarks.length; i<N;i+=1){
      lmarks.push(this.landmarks[i].name);
  }
  return lmarks;  
};


vxlCamera.prototype.getLandmarks
/**
 * This method sets the camera to a distance such that the area covered by the bounding box (parameter)
 * is viewed.
 * @param {vxlBoundingBox} bb the bounding box
 */
vxlCamera.prototype._shot = function(bb){
    
    this.setElevation(0);
    this.setAzimuth(0);
    
	var maxDim = Math.max(bb[3] - bb[0], bb[4] - bb[1]);
	
	cc = [0,0,0];

	cc[0] = (bb[3] + bb[0]) /2;
	cc[1] = (bb[4] + bb[1]) /2;
	cc[2] = (bb[5] + bb[2]) /2;
		
	cc[0] = Math.round(cc[0]*1000)/1000;
	cc[1] = Math.round(cc[1]*1000)/1000;
	cc[2] = Math.round(cc[2]*1000)/1000;
	
	if(maxDim != 0) {
		var d = 1.5 * maxDim / (Math.tan(this._fov * Math.PI / 180));
		this.setPosition([cc[0], cc[1], cc[2]+ d]);
	}
	
	this.setFocalPoint(cc);
};



/**
 * Prints a summary of the camera variables on the browser's console
 */
vxlCamera.prototype.status = function() {
	console.info('------------- Camera Status -------------');
	console.info('       type: ' + this.type);
    console.info('      right: ' + vxl.util.format(this._right, 2)); 
    console.info('         up: ' + vxl.util.format(this._up, 2));   
    console.info('    forward: ' + vxl.util.format(this._forward,2));           
    console.info('   position: ' + vxl.util.format(this._position,2));
    console.info('focal point: ' + vxl.util.format(this._focalPoint,2));
    console.info('   d vector: ' + vxl.util.format(this._distanceVector,2));
    console.info('    azimuth: ' + vxl.util.format(this._azimuth,3));
    console.info('  elevation: ' + vxl.util.format(this._elevation,3));
    console.info('   distance: ' + vxl.util.format(this._distance,2));
};


/**
 * Inverts the camera mattrix to obtain the correspondent Model-View Transform
 * @returns {mat4} m the Model-View Transform
 */
vxlCamera.prototype.getViewTransform = function(){
    return mat4.inverse(this._matrix, mat4.create());
};

/**
 * Sets the camera matrix
 * @param {mat4} matrix the new camera matrix
 */
vxlCamera.prototype.setMatrix = function(matrix){
    this._matrix = matrix;
    this._update();
};

/**
 * Sets the  camera matrix
 * @private
 */
vxlCamera.prototype._computeMatrix = function(){
    
    mat4.identity(this._matrix);
    
    var rotX  = quat4.fromAngleAxis(this._elevation * vxl.def.deg2rad, [1,0,0]);
    var rotY  = quat4.fromAngleAxis(this._azimuth   * vxl.def.deg2rad, [0,1,0]);
    var rotZ  = quat4.fromAngleAxis(this._roll      * vxl.def.deg2rad, [0,0,1]); 
    var rotQ = quat4.multiply(rotY, rotX, quat4.create());
    rotQ = quat4.multiply(rotQ, rotZ, quat4.create());
    var rotMatrix = quat4.toMat4(rotQ);
    
    if (this.type ==  vxl.def.camera.type.ORBITING || this.type == vxl.def.camera.type.EXPLORING){
        mat4.translate(this._matrix, this._focalPoint);
        mat4.multiply(this._matrix, rotMatrix);
        mat4.translate(this._matrix, [0,0,this._distance]);
    } 
    else if(this.type ==  vxl.def.camera.type.TRACKING){
        mat4.translate(this._matrix, this._position);
        mat4.multiply(this._matrix, rotMatrix);
    }
};

/*
 * Updates the camera matrix. Used on rotate to avoid gimbal lock
 * @private
 */
/*vxlCamera.prototype._updateMatrix = function(){
   
    var rotX  = quat4.fromAngleAxis(this._relElevation * vxl.def.deg2rad, [1,0,0]);
    var rotY  = quat4.fromAngleAxis(this._relAzimuth   * vxl.def.deg2rad, [0,1,0]);
    var rotZ  = quat4.fromAngleAxis(this._relRoll      * vxl.def.deg2rad, [0,0,1]); 
    var rotQ = quat4.multiply(rotY, rotX, quat4.create());
    rotQ = quat4.multiply(rotQ, rotZ, quat4.create());
    var rotMatrix = quat4.toMat4(rotQ);
    
    if (this.type ==  vxl.def.camera.type.ORBITING){
        mat4.translate(this._matrix, [0,0,-this._distance]);
        mat4.multiply(this._matrix, rotMatrix);
        mat4.translate(this._matrix, [0,0,this._distance]);
    } 
    else if(this.type ==  vxl.def.camera.type.TRACKING){
        mat4.multiply(this._matrix, rotMatrix);
    }
    
    this._relElevation  = 0;
    this._relAzimuth    = 0;
    this._relRoll       = 0;
};*/


/**
 * Sets the camera position in the camera matrix
 * @private
 */
vxlCamera.prototype._setPosition = function(x,y,z){
    this._position = vxl.util.createVec3(x,y,z);
    var m = this._matrix;
    m[12] = this._position[0];
    m[13] = this._position[1];
    m[14] = this._position[2];
    m[15] = 1;
};

/**
 * Recalculates axes based on the current matrix
 * @private
 */
vxlCamera.prototype._getAxes = function(){
    var m       = this._matrix;
    vec3.set(mat4.multiplyVec4(m, [1, 0, 0, 0]), this._right);
    vec3.set(mat4.multiplyVec4(m, [0, 1, 0, 0]), this._up);
    vec3.set(mat4.multiplyVec4(m, [0, 0, 1, 0]), this._forward);
    vec3.normalize(this._right);
    vec3.normalize(this._up);
    vec3.normalize(this._forward);
};

/**
 * Recalculates the position based on the current matrix
 * Called only when camera is of ORBITING type
 * @private
 */
vxlCamera.prototype._getPosition = function(){
    var m       = this._matrix;
    vec3.set(mat4.multiplyVec4(m, [0, 0, 0, 1]), this._position);
    this._getDistance();
};

/**
 * Called only when camera is of TRACKING type
 * @private
 */
vxlCamera.prototype._getFocalPoint = function(){
    mat4.multiplyVec3(mat4.toRotationMat(this._matrix), [0,0,-this._distance], this._distanceVector); 
    vec3.add(this._position, this._distanceVector, this._focalPoint);
    this._getDistance();               
};

/**
 * Recalculates the distance variables based on the current state
 * @private
 */
vxlCamera.prototype._getDistance = function(){
    this._distanceVector = vec3.subtract(this._focalPoint, this._position, vec3.create());
    this._distance = vec3.length(this._distanceVector);
    this._dollyingStep = this._distance / 100;
};

/**
 * Recalculates euler angles based on the current state
 * @private
 */
vxlCamera.prototype._getAngles = function(){
    //Recalculates angles  
    var x = this._distanceVector[0], y = this._distanceVector[1],  z = this._distanceVector[2];
    var r = vec3.length(this._distanceVector);
    this._elevation = Math.asin(y/r)    * vxl.def.rad2deg;
    this._azimuth   = Math.atan2(-x,-z) * vxl.def.rad2deg;
};


/**
 * Recalculates the camera state from the camera matrix
 * @private
 */
vxlCamera.prototype._update = function(){
    this._getAxes();
    this._getPosition();
    this._getDistance();
    this._getAngles();
};

/**
 * @private
 */
vxlCamera.prototype._calculateAngles = function(){
    var rotM = mat4.toMat3(this._matrix);
    var Q = mat3.toQuat4(rotM);
    var x = Q[0], y = Q[1], z = Q[2], w=Q[3];
    
    var roll  = Math.atan2(2 * (w * x + y * z),1 - 2 * (x * x + y * y)) * vxl.def.rad2deg;
    var pitch = Math.asin (2 * (w * y - z * y)) * vxl.def.rad2deg;
    var yaw   = Math.atan2(2 * (w * z + x * y), 1 - 2 * (y *y + z * z)) * vxl.def.rad2deg;
    
    console.info(' roll :' + vxl.util.format(roll,2));
    console.info('pitch :' + vxl.util.format(pitch,2));
    console.info('  yaw :' + vxl.util.format(yaw,2));
};

/**
 * Returns an angle between 0 and 360 degrees
 * @private
 */
vxlCamera.prototype._getAngle = function(angle){
   
    if (angle == undefined){
         return 0;
    }
    else if (angle > 360 || angle <-360) {
        return angle % 360;
    }
    else return angle;
};
 
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  
/**
 * @class The camera manager is responsible for controlling the cameras associated with a view 
 * @constructor
 * @param {vxlView} vw the view
 * @see vxlCamera
 * @see vxlView
 */
function vxlCameraManager(vw){
	this.view = vw;
	this.cameras = [];
	this.active = this.create();
	if (vxl.c.camera == undefined){
	    vxl.c.camera = this.active;
	}
}

/**
 * Resets the camera manager and creates one camera
 * @param {vxl.def.camera.type} type the type of amera
 */
vxlCameraManager.prototype.reset = function(type){
	this.cameras = [];
	this.interactors = [];
	this.active = this.create(type);
};


/**
 * Creates a camera
 * @param {vxl.def.camera.type} type the type of camera to create
 */
vxlCameraManager.prototype.create = function(type){
	var camera = new vxlCamera(this.view, type);
	this.cameras.push(camera);
	return camera;
};

/**
 * Removes a camera from the camera manager. Please notice that this operation
 * will cause reindexing. So, if the camera manager has cameras 0, 1, 2  and camera 1
 * is removed then camera 2 will be now camera 1 so the index is maintained.
 * 
  * @param {Number} idx the index of the camera to be removed
 */
vxlCameraManager.prototype.remove = function(idx){
    if (this.cameras.length == 1){
        throw ('vxlCameraManager.remove ERROR: the camera manager must not eliminate the last camera standing. Operation cancelled');
    }
    else{
        this.cameras.splice(idx,1);
    }
};

/**
 * Returns the camera with index idx
 * @param {Number} idx the index of the camera to return
 */
vxlCameraManager.prototype.get = function(idx){
	this._checkBoundary(idx);
	return this.cameras[idx];
};


/**
 * Changes the active camera to the camera with index idx
 * @param {Number} idx the index of the camera to make active
 */
vxlCameraManager.prototype.switchTo = function(idx){
    var view = this.view;
	this._checkBoundary(idx);
	this.active = this.cameras[idx];
    
    if (view.interactor != undefined) {
        view.interactor.connectCamera(this.active);
    }
    else{
        throw ('vxlCameraManager.switchTo ERROR: switching to camera ['+idx+'] while the view '+view.name+' does not have an interactor set');
    }
    
    vxl.c.camera = this.active;
	
	return this.active;
};

/**
 * Utilitary method that check if the index idx is between 0 and the size of the camera array
 * @param {Number} idx the index to check.
 * @private
 */
vxlCameraManager.prototype._checkBoundary = function(idx){
    if (idx <0 || idx >= this.cameras.length){
        throw('The camera '+idx+' does not exist');
    }
};/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 
/**
 * <p> Handles the interaction between a camera and a view </p>
 * @class
 * @constructor 
 */
function vxlViewInteractor(){
    this.view   = undefined;
	this.camera = undefined;
	this.UID    = vxl.util.generateUID();
};

/**
 * 
 */
vxlViewInteractor.prototype.getType = function(){
    return "vxlViewInteractor";
};

/**
 * @param {vxlView} view the view 
 */
vxlViewInteractor.prototype.connectView = function(view){
  
    if (!(view instanceof vxlView)){
        throw 'ViewInteractor.connectView: the parameter is not a vxlView';
    }
    var interactor = this;
    var canvas = view.canvas;

    this.view   = view;
    this.camera = view.cameraman.active;

    
    canvas.onmousedown = function(ev) {
        interactor.onMouseDown(ev);
    };

    canvas.onmouseup = function(ev) {
        interactor.onMouseUp(ev);
    };
    
    canvas.onmousemove = function(ev) {
        interactor.onMouseMove(ev);
    };
    
    canvas.ondragover = function(ev){
        interactor.onDragOver(ev);
    };
    
    canvas.ondragleave = function(ev){
        interactor.onDragLeave(ev);
    };
    
    canvas.ondrop = function(ev){
        interactor.onDrop(ev);
    };
    
    window.onkeydown = function(ev){
        interactor.onKeyDown(ev);
    };
    
    window.onkeyup = function(ev){
        interactor.onKeyUp(ev);
    };
    
    canvas.ondblclick = function(ev){
        interactor.onDoubleClick(ev);
    }
};


/**
 * @param {vxlCamera} c the camera to connect to this interactor
 * @todo: validate that the camera belongs to the current view. If not throw an exception.
 */
vxlViewInteractor.prototype.connectCamera = function(c){
	if (c instanceof vxlCamera){
		this.camera = c;
		this.camera.interactor = this;
	}
	else {
		throw('ViewInteractor.connectCamera: The object '+c+' is not a valid camera');
	}
};

/**
 * Abstract method to be implemented by the descendants 
 * @param {Object} ev
 */
vxlViewInteractor.prototype.onMouseUp   = function(ev){ alert('implement onMouseUp');};
/**
 * Abstract method to be implemented by the descendants 
 * @param {Object} ev
 */
vxlViewInteractor.prototype.onMouseDown = function(ev){ alert('implement onMouseDown');};
/**
 * Abstract method to be implemented by the descendants 
 * @param {Object} ev
 */
vxlViewInteractor.prototype.onMouseMove = function(ev){ alert('implement onMouseMove');};
/**
 * Abstract method to be implemented by the descendants 
 * @param {Object} ev
 */
vxlViewInteractor.prototype.onKeyDown   = function(ev){ alert('implement onKeyDown');};
/**
 * Abstract method to be implemented by the descendants 
 * @param {Object} ev
 */
vxlViewInteractor.prototype.onKeyUp     = function(ev){ alert('implement onKeyUp');};
/**
 * Abstract method to be implemented by the descendants 
 * @param {Object} ev
 */
vxlViewInteractor.prototype.onDragOver     = function(ev){ alert('implement onDragOver');};
/**
 * Abstract method to be implemented by the descendants 
 * @param {Object} ev
 */
vxlViewInteractor.prototype.onDragLeave     = function(ev){ alert('implement onDragLeave');};

/**
 * Abstract method to be implemented by the descendants 
 * @param {Object} ev
 */
vxlViewInteractor.prototype.onDrop     = function(ev){ alert('implement onDrop');};
/**
 * Abstract method to be implemented by the descendants 
 * @param {Object} ev
 */
vxlViewInteractor.prototype.onDoubleClick     = function(ev){ alert('implement onDrop');};




/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  


vxlTrackerInteractor.prototype = new vxlViewInteractor();
vxlTrackerInteractor.prototype.constructor = vxlViewInteractor;
/**
 * @class Determines the application behaviour originated by mouse and keyboard events. 
 * @constructor
 * Interprets mouse and keyboard events and translate them to camera actions
 * @augments vxlViewInteractor
 */
function vxlTrackerInteractor(){
    vxlViewInteractor.call(this);    
	this.MOTION_FACTOR = 10.0;
	this.task = vxl.def.interactor.task.NONE;
	this.x = 0;
	this.y = 0;
	this.lastX = 0;
	this.lastY = 0;
	this.lastClickedX = 0;
	this.lastClickedY = 0;
	this.ctrlPressed = false;
	this.altPressed = false;
	this.keyPressed = 0;
	this.button = -1;
	this.dragging = false;
	this.dragndrop = false;
	this.isMac = vxl.util.isMac();
	
};

/**
 * Returns the type of this interactor as a string 
 */
vxlTrackerInteractor.prototype.getType = function(){
    return "vxlTrackerInteractor";
};

/**
 * Reacts to the window onKeyDown event 
 */
vxlTrackerInteractor.prototype.onKeyDown = function(ev){
    this.keyPressed = ev.keyCode;
    this.altPressed = ev.altKey;
    this.shiftPressed = ev.shiftKey;
    
    var camera = this.camera;
    
    
    if (!this.altPressed && !this.shiftPressed){
        switch(this.keyPressed){
              case 38:camera.changeElevation(10);  break;
              case 40:camera.changeElevation(-10); break;
              case 37:camera.changeAzimuth(-10);   break;
              case 39:camera.changeAzimuth(10);    break;
              case 70: this.view.fullscreen(true); break;
              case 88: this.view.fullscreen(false); break;
              default: break;
        }
    }
    //PANNING
    else if(this.shiftPressed && this.keyPressed !=17) {
        var px = 0;
        var py = 0;
        switch(this.keyPressed){
            case 38:py = 10; break;
            case 40:py = -10;break;
            case 37:px = -10;break;
            case 39:px = 10; break;
            default: break;
        }
        if(px != 0 || py !=0){
            this.pan(px,py);
        }
    }
    this.camera.refresh();
};

/**
 * Reacts to the canvas onkeyup event 
 */
vxlTrackerInteractor.prototype.onKeyUp = function(ev){
    if (ev.keyCode == 17){
        this.ctrlPressed = false;
    }
};

/**
 *Reacts to the canvas onmouseup event 
 */
vxlTrackerInteractor.prototype.onMouseUp = function(ev){
	task = vxl.def.interactor.task.NONE;
	this.dragging = false;
};

/**
 *Reacts to the canvas onmousedown event 
 */
vxlTrackerInteractor.prototype.onMouseDown = function(ev){
	this.x             = ev.clientX;
	this.y             = ev.clientY;
	this.lastClikedX   = this.x;
	this.lastClickedY  = this.y;
	this.button        = ev.button;
	this.dragging      = true;
};

/**
 *Reacts to the canvas onmousemove event 
 */
vxlTrackerInteractor.prototype.onMouseMove = function(ev){

	this.lastX         = this.x;
	this.lastY         = this.y;
	this.x             = ev.clientX;
    this.y             = ev.clientY;

	if (!this.dragging) return;
    if (this.button !=0) return;  
	
	this.ctrlPressed 	= ev.ctrlKey;
	
	if (this.isMac && ev.metaKey){
	    this.ctrlPressed = true;
	}
	
	this.altPressed 	= ev.altKey;
	this.shiftPressed 	= ev.shiftKey;
	
	var rx = this.x - this.lastX;
	var ry = this.y - this.lastY;
		 
    if (this.ctrlPressed && !this.shiftPressed){ 
		this.dolly(ry);
	}
	else if (this.shiftPressed && !this.ctrlPressed){
		this.pan(rx,ry);
	}
	else if (this.ctrlPressed && this.shiftPressed){
	    this.roll(ry);
	}
	else {

        this.rotate(rx,ry);
    }
	
	this.camera.refresh();
};


/**
 *  Implements the behaviour of the tracker on the ondragover mouse event
 */
vxlTrackerInteractor.prototype.onDragOver = function(event){
    event.stopPropagation();
    event.preventDefault();
    
        
    if (this.view.dragndrop){
        if (!this.dragndrop){
            this.bgcolor = this.view.backgroundColor.slice(0);
            this.dragndrop = true;
        }
        event.dataTransfer.dropEffect = 'copy';
        this.view.setBackgroundColor(0,0.514,0.678);
    }
};

/**
 * Implements the behaviour of the tracker on the ondragleave mouse event 
 */
vxlTrackerInteractor.prototype.onDragLeave = function(event){
    event.stopPropagation();
    event.preventDefault();

    if (this.view.dragndrop){
        event.dataTransfer.dropEffect = 'copy';
        this.view.setBackgroundColor(this.bgcolor);
        this.dragndrop = false;
    }
    
};

/**
 * Implements the behaviour of the tracker on the ondrop mouse event
 * @TODO: this method only works for VTK ascii files. Review other formats 
 */
vxlTrackerInteractor.prototype.onDrop = function(event){
    event.stopPropagation();
    event.preventDefault();
    if (!this.view.dragndrop) return; //the view is configured to not accept dnd
    this.dragndrop = false;
    this.view.setBackgroundColor(this.bgcolor);
    
    var files = event.dataTransfer.files;
    var reader = new vxlVTKReader(this.view.scene);
    if (reader.isSupported()){
        reader.read(files[0]);
    }
    else {
        throw 'vxlTrackerInteractor.drop: File API is not supported on this browser';
    }
};

/**
 * Calls the current camera longShot method 
 * @param {Object} event
 */
vxlTrackerInteractor.prototype.onDoubleClick = function(event){
    this.camera.longShot();
};


/**
 * Internal method used by this tracker to perform dollying
 * @param {Number} value the number of dollying steps
 */
vxlTrackerInteractor.prototype.dolly = function(value){
	
	this.task = vxl.def.interactor.task.DOLLY;
    this.camera.dolly(value);
};

/**
 * Internal method used by this tracker to perform rolling
 * @param {Number} value the rolling angle
 */
vxlTrackerInteractor.prototype.roll = function(value){
    
    this.task = vxl.def.interactor.task.ROLL;
    
    var canvas = this.camera.view.canvas;
    
    var dy = -20.0 / canvas.width;
    
    var rotY = value * dy * this.MOTION_FACTOR;
    
    this.camera.rotate(0,0,rotY);
};



/**    this.dragndrop = false;
 * Internal method used by this tracker to rotate the camera.
 * @param {Number} dx the rotation on the X axis (elevation)
 * @param {Number} dy the rotation on the Y axis (azimuth)
 */
vxlTrackerInteractor.prototype.rotate = function(rx, ry){
	
	this.task = vxl.def.interactor.task.ROTATE;
	
	var canvas = this.camera.view.canvas;
	var dx = -20.0 / canvas.height;
	var dy = -20.0 / canvas.width;
	var motionFactorX = this.MOTION_FACTOR;
	var motionFactorY = this.MOTION_FACTOR;
	if (rx*rx > 2 * ry *ry){
	    motionFactorY *= 0.5;
	}
	else if (ry*ry > 2* rx*rx){
	    motionFactorX *= 0.5;
	}
	
	var rotX = rx * dx * motionFactorX;
	var rotY = ry * dy * motionFactorY;
	
	this.camera.rotate(rotX, rotY);
};

/**
 * Internal method used by this tracker to perform panning 
 * @param {Object} dx
 * @param {Object} dy
 */
vxlTrackerInteractor.prototype.pan = function(dx,dy){

	this.task = vxl.def.interactor.task.PAN;
	
	var camera = this.camera;
	var canvas = camera.view.canvas;
	var scene = camera.view.scene;    this.dragndrop = false;
	var dimMax = Math.max(canvas.width, canvas.height);
	var deltaX = 1 / dimMax;
	var deltaY = 1 / dimMax;
	var max = scene.bb.max();
    var ndx = dx * deltaX * this.MOTION_FACTOR * max / 2;
	var ndy = -dy * deltaY * this.MOTION_FACTOR * max / 2;

	camera.pan(ndx,ndy);
};/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  

vxlPickerInteractor.prototype = new vxlViewInteractor();
vxlPickerInteractor.prototype.constructor = vxlPickerInteractor;
/**
 * @class 
 * Interactor that implements a picking mechanism. Implemented in 0.89.1
 * @constructor   
 * @param {Object} view the view this interactor will observe
 * @param {Object} camera the camera this interactor will master
 * @author Diego Cantor
 */
function vxlPickerInteractor(){
	vxlViewInteractor.call(this);
	this._drag = false;
	this.timerID = -1;
	this.list = [];
	this.rate = 600;

};


vxlPickerInteractor.prototype.getType = function(){
    return "vxlPickerInteractor";
};

vxlPickerInteractor.prototype.get2DCoords = function(ev){
    var x, y, top = 0, left = 0, obj = this.view.canvas;
    var rect = obj.getBoundingClientRect();
     
    // return relative mouse position
    x = ev.clientX - rect.left;
    y = vxl.c.view.canvas.height - (ev.clientY - rect.top); 
                                       //this variable contains the height of the canvas and it updates dynamically
                                       //as we resize the browser window.
    //console.info('x='+x+', y='+y);
    return [x,y];
    
};


/**
 *  Reacts to the onmouse up event on the canvas
 * @param {Object} ev
 */
vxlPickerInteractor.prototype.onMouseUp   = function(ev){
    this._drag = false;
    if (this.timerID != -1){
        clearInterval(this.timerID);
    }
    
    
};

/**
 * Reacts to the onmouse event on the canvas 
 * @param {Object} ev mouse event
 */
vxlPickerInteractor.prototype.onMouseDown = function(ev){ 
    ev.preventDefault();
    this.view.canvas.style.cursor = 'crosshair'
    this.list.push(this.get2DCoords(ev));
    this._doWork();   
    this._drag = true;
    
    if (this.timerID != -1){
        clearInterval(this.timerID);
    }
    this.timerID = setInterval((function(self) {return function() {self._doWork();}})(this),this.rate); 
};

/**
 * Reacts to the onmouse move event on the canvas  
 * @param {Object} ev
 */
vxlPickerInteractor.prototype.onMouseMove = function(ev){ 
    ev.preventDefault();
    if (this._drag){
        this.list.push(this.get2DCoords(ev));
    }
};

vxlPickerInteractor.prototype._doWork = function(){
  var i = this.list.length;
  var rt = this.view.renderer._renderTarget;
    
  while(i--){
        var coords = this.list.pop();
        var color  = rt.readPixel(coords[0], coords[1]);

        if (color[0] == 0 && color[1] == 0 && color[2] == 0 && color[3] ==0){
            continue;
        }
        
        var results = vxl.go.picker.query(color);
        
        if (results == null) continue;
        
        var actor  = this.view.scene.getActorByCellUID(results.uid);
        
        if (actor == null) { //try object UID
            actor = this.view.scene.getActorByUID(results.uid);
        }
        
        if (actor != null && actor.isPickable() && actor._pickingCallback != undefined){
            actor._pickingCallback(actor, results.uid);
        }
  }
};


vxlPickerInteractor.prototype.onKeyDown   = function(ev){};
vxlPickerInteractor.prototype.onKeyUp     = function(ev){};
vxlPickerInteractor.prototype.onDragOver     = function(ev){ };
vxlPickerInteractor.prototype.onDragLeave     = function(ev){};
vxlPickerInteractor.prototype.onDrop     = function(ev){};
vxlViewInteractor.prototype.onDoubleClick     = function(ev){};

/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   

/**
 * @class Encapsulates the matrices required to perform 3D rendering
 * @constructor
 * @author Diego Cantor
 */
function vxlTransforms(vw){
	this._stack = [];
	this.view = vw;
	this.mvMatrix    = mat4.identity();    // The Model-View matrix
	this.pMatrix     = mat4.identity();    // The projection matrix
	this.nMatrix     = mat4.identity();    // The normal matrix
	this.cMatrix     = mat4.identity();    // The camera matrix
	this.mvpMatrix   = mat4.identity();	
};

/**
 * Calculates the Model-View matrix for the current camera.
 */
vxlTransforms.prototype.calculateModelView = function(){
	mat4.set(this.view.cameraman.active.getViewTransform(), this.mvMatrix);
    
};

/**
 * Calculates the normal matrix corresponding to the current Model-View matrix
 */
vxlTransforms.prototype.calculateNormal = function(){
	mat4.identity(this.nMatrix);
    mat4.set(this.mvMatrix, this.nMatrix);
    mat4.inverse(this.nMatrix);
    mat4.transpose(this.nMatrix);
};

/**
 * Calculates the perspective matrix given the current camera
 */
vxlTransforms.prototype.calculatePerspective = function(){
    var c = this.view.cameraman.active;
    var vw = this.view;
	mat4.identity(this.pMatrix);
	mat4.perspective(c._fov, vw.width/vw.height, c.Z_NEAR, c.Z_FAR, this.pMatrix);
};


vxlTransforms.prototype.calculateModelViewPerspective = function(){
    mat4.multiply(this.pMatrix, this.mvMatrix, this.mvpMatrix);
}
/**
 * Calculate the transforms for the current view.renderer
 * 
 */
vxlTransforms.prototype.update = function(){
    this.calculateModelView();
    this.calculatePerspective();
    this.calculateNormal();
    this.calculateModelViewPerspective();
};

/**
 * Saves the current Model-View matrix in the stack. This
 * operation is called by vxlActor.updateMatrixStack
 * @see vxlActor#updateMatrixStack
 */

vxlTransforms.prototype.push = function(){
	var memento =  mat4.create();
	mat4.set(this.mvMatrix, memento);
	this._stack.push(memento);
};

/**
 * Retrieves the last Model-View transformation in the matrix stack.
 * This operation is called by vxlActor.updateMatrixStack
 */
vxlTransforms.prototype.pop = function(){
	if(this._stack.length == 0) return;
	this.mvMatrix  =  this._stack.pop();
	this.calculatePerspective();
	this.calculateNormal();
	this.calculateModelViewPerspective();
};/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 

/**
 * @class Represents the ESSL source code of each program
 */
function vxlProgram(){
    this.ID = undefined;
    this.ATTRIBUTES = [];
    this.UNIFORMS = [];
    this.VERTEX_SHADER = "";
    this.FRAGMENT_SHADER = "";
    this.DEFAULTS = {};
};

vxlProgram.prototype.copy = function(prg){
    this.ID                 = prg.ID;
    this.ATTRIBUTES         = prg.ATTRIBUTES;
    this.UNIFORMS           = prg.UNIFORMS;
    this.VERTEX_SHADER      = prg.VERTEX_SHADER;
    this.FRAGMENT_SHADER    = prg.FRAGMENT_SHADER;
    this.DEFAULTS           = prg.DEFAULTS;
};

/**
 * Obtain the list of attributes and uniforms from the code
 */
vxlProgram.prototype.introspect = function(){
    
    this.ATTRIBUTES = [];
    this.UNIFORMS = [];
    
    var code = this.VERTEX_SHADER.concat(this.FRAGMENT_SHADER);
    code = code.replace(/(\r\n|\n\r|\n)/gm,"");
    
    var uniforms   = code.match(/(uniform)\s*\w*\s*\w*/g);
    var attributes = code.match(/(attribute)\s*\w*\s*\w*/g);    
    
    if (uniforms.length == 0){
        throw new vxlProgramException("The code for the program "+this.ID+" does not contain any valid uniforms");
    }
    
    if (attributes.length == 0){
        throw new vxlProgramException("The code for the program "+this.ID+" does not contain any valid attributes");
    }
    
    for(var i=0, N = uniforms.length; i < N; i +=1){
        this.UNIFORMS.push(uniforms[i].substr(uniforms[i].lastIndexOf(" ")+1, uniforms[i].length));
    }
    
    for(var i=0, N = attributes.length; i < N; i +=1){
        this.ATTRIBUTES.push(attributes[i].substr(attributes[i].lastIndexOf(" ")+1, attributes[i].length));
    }
    
};
/**
 * Creates a program object from the ESSL scripts embedded in the DOM
 * @param {Object} id
 * @param {Object} vertexShaderId
 * @param {Object} fragmentShaderId
 */
vxlProgram.createFromDOM = function(id, vertexShaderId,fragmentShaderId){

    var prg = new vxlProgram();
    
    prg.ID = id;
    var vsElement   = document.getElementById(vertexShaderId);
    var fsElement = document.getElementById(fragmentShaderId);
    
    if (vsElement == null || fsElement == null){
        throw new vxlProgramException("shaders don't exist");
    }
    
    prg.VERTEX_SHADER = vsElement.innerHTML;
    prg.FRAGMENT_SHADER = fsElement.innerHTML;
    
    prg.introspect();
    
    return prg;
    
};


vxlProgram.createFromJSON = function(json){
  
    var prg = new vxlProgram();
     if (json.ID){
       prg.ID = json.ID;
     } //otherwise use the one defined in the constructor
      
     prg.VERTEX_SHADER = json.VERTEX_SHADER;
     prg.FRAGMENT_SHADER = json.FRAGMENT_SHADER;
     prg.DEFAULTS = json.DEFAULTS;      
     prg.introspect();
     
     return prg;
  
};


vxlProgram.createFromTextURL = function(id, vertexShaderURL, fragmentShaderURL){
  //TODO: check $ajax with no async  
  //  $.ajax(vs_url, {async: false, dataType: "text"}).done(function(data){m_VertexShaderSource = data;});
  //$.ajax(fs_url, {async: false, dataType: "text"}).done(function(data){m_FragmentShaderSource = data;});
};






function vxlProgramException(message){
    this.message = "vxlProgramException:" + message;
};
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   

/**
 * @class
 * @private
 */
vxlLambertProgram.prototype = new vxlProgram();
vxlLambertProgram.prototype.constructor = vxlLambertProgram;

function vxlLambertProgram(){
    
    this.copy(vxlProgram.createFromJSON({
    
        ID : 'lambert',
        VERTEX_SHADER : [
        "attribute vec3 aVertexPosition;",
        "attribute vec3 aVertexNormal;",
        "attribute vec3 aVertexColor;",
        "attribute vec2 aVertexTextureCoords;",
        "uniform float uPointSize;",
        "uniform mat4 mModelView;",
        "uniform mat4 mPerspective;",
        "uniform mat4 mModelViewPerspective;",
        "uniform mat4 mNormal;",
        "uniform vec3 uLightDirection;",
        "uniform vec4 uLightAmbient;",  
        "uniform vec4 uLightDiffuse;",
        "uniform vec4 uMaterialDiffuse;",
        "uniform bool uUseShading;",
        "uniform bool uUseVertexColors;",
        "uniform bool uUseLightTranslation;",
        "uniform bool uUseTextures;",
        "varying vec4 vFinalColor;",
        "varying vec2 vTextureCoords;",
        
        "void main(void) {",
        "   gl_Position = mModelViewPerspective * vec4(aVertexPosition, 1.0);",
        "   gl_PointSize = uPointSize;",
        
        "   if (uUseVertexColors) {",
        "       vFinalColor = vec4(aVertexColor,uMaterialDiffuse.a);",
        "   }",
        "   else {",
        "       vFinalColor = uMaterialDiffuse;",
        "   }",
        "   if (uUseShading){",
        "       vec3 N = vec3(mNormal * vec4(aVertexNormal, 1.0));",
        "       vec3 L = normalize(uLightDirection);",
        "       if (uUseLightTranslation){ L = vec3(mNormal * vec4(L,1.0));}",
        "       float lambertTerm = max(dot(N,-L),0.4);",
        "       vec4 Ia = uLightAmbient;",
        "       vec4 Id = vFinalColor * uLightDiffuse * lambertTerm;",
        "       vFinalColor = Ia + Id;",
        "       vFinalColor.a = uMaterialDiffuse.a;",
        "   }" ,
        "   if (uUseTextures){" ,
        "       vTextureCoords = aVertexTextureCoords;",
        "   }",
        "}"].join('\n'),
        
        FRAGMENT_SHADER : [
        "#ifdef GL_ES",
        "precision highp float;",
        "#endif",
    
        "varying vec4      vFinalColor;",
        "varying vec2      vTextureCoords;",
        "uniform bool      uUseTextures;",
        "uniform sampler2D uSampler;",
    
        "void main(void)  {",
        "   if (uUseTextures){",
        "       gl_FragColor = texture2D(uSampler, vTextureCoords);",
        "   }",
        "   else{",
        "       gl_FragColor = vFinalColor;",
        "   }",
        "}"].join('\n'),
        
        DEFAULTS : {
            "uLightDirection"   : [0.0,0.0,-1.0],
            "uLightAmbient"     : [0.0,0.0,0.0,1.0],
            "uLightDiffuse"     : [1.0,1.0,1.0,1.0],
            "uMaterialDiffuse"  : [0.9,0.9,0.9,1.0],
            "uPointSize"        : 1.0,
            "uUseLightTranslation" : false
        }
    }));
  
}; 

vxl.go.essl.lambert = new vxlLambertProgram();
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  
/**
 * @class
 * @private
 */

vxlPhongProgram.prototype = new vxlProgram();
vxlPhongProgram.prototype.constructor = vxlPhongProgram;

function vxlPhongProgram(){
    
    this.copy(vxlProgram.createFromJSON({

        ID : 'phong',

        VERTEX_SHADER: [
        "attribute vec3 aVertexPosition;",
        "attribute vec3 aVertexNormal;",
        "attribute vec3 aVertexColor;",
        "attribute vec2 aVertexTextureCoords;",
        "uniform float uPointSize;",
        "uniform mat4 mModelView;",
        "uniform mat4 mPerspective;",
        "uniform mat4 mModelViewPerspective;",
        "uniform mat4 mNormal;",
        "uniform bool uUseVertexColors;",
        "varying vec3 vNormal;",
        "varying vec3 vEyeVec;",
        "varying vec4 vFinalColor;",
        "varying vec2 vTextureCoords;",
        "uniform bool uUseTextures;",
        
        "void main(void) {",
        "  gl_Position = mPerspective * mModelView * vec4(aVertexPosition, 1.0);",
        "  gl_PointSize = uPointSize;",
        "   if(uUseVertexColors) {",
        "       vFinalColor = vec4(aVertexColor,1.0);",
        "       return;",  
        "   }",
        "   vec4 vertex = mModelView * vec4(aVertexPosition, 1.0);",
        "   vNormal = vec3(mNormal * vec4(aVertexNormal, 1.0));",
        "   vEyeVec = -vec3(vertex.xyz);",
        "   if (uUseTextures){" ,
        "       vTextureCoords = aVertexTextureCoords;",
        "   }",
        "}"].join('\n'),
    
        FRAGMENT_SHADER : [
        "#ifdef GL_ES",
        "precision highp float;",
        "#endif",
        
        "uniform bool uUseShading;",
        "uniform bool uUseVertexColors;",
        "uniform float uShininess;      ",
        "uniform vec3 uLightDirection;  ",
        
        "uniform vec4 uLightAmbient;    ",
        "uniform vec4 uLightDiffuse;    ",
        "uniform vec4 uLightSpecular;   ",
        
        "uniform vec4 uMaterialAmbient; ",
        "uniform vec4 uMaterialDiffuse; ",
        "uniform vec4 uMaterialSpecular;",
        
        "varying vec3 vNormal;",
        "varying vec3 vEyeVec;",
        "varying vec4 vFinalColor;",
        
        "varying vec2      vTextureCoords;",
        "uniform bool      uUseTextures;",
        "uniform sampler2D uSampler;",
        
        "void main(void)",
        "{",
         "  vec4 finalColor = vec4(0.0);",
         "  vec3 L = normalize(uLightDirection);",
         "  vec3 N = normalize(vNormal);",
         "  float lambertTerm = dot(N,-L);",
         "  vec4 Ia = uLightAmbient * uMaterialAmbient;",
         "  vec4 Id = vec4(0.0,0.0,0.0,1.0);",
         "  vec4 Is = vec4(0.0,0.0,0.0,1.0);",
         "  vec4 varMaterialDiffuse = uMaterialDiffuse;",
         "  if(uUseVertexColors) {",
         "        varMaterialDiffuse = vFinalColor;",
         "   }",
         "  if(uUseShading){  ",
         "      if(lambertTerm > 0.0)",
         "      {",
         "          Id = uLightDiffuse * varMaterialDiffuse * lambertTerm;",
         "          vec3 E = normalize(vEyeVec);",
         "          vec3 R = reflect(L, N);",
         "          float specular = pow( max(dot(R, E), 0.0), uShininess);",
         "          Is = uLightSpecular * uMaterialSpecular * specular;",
         "      }",
         "      finalColor = Ia + Id + Is;",
         "      finalColor.a = uMaterialDiffuse.a;",
         "  } ",
         "  else {",
         "      finalColor = varMaterialDiffuse; ", 
         "  }",
         "   if (uUseTextures){",
         "       finalColor =  texture2D(uSampler, vec2(vTextureCoords.s, vTextureCoords.t));",
         "   }",
         "   gl_FragColor = finalColor;",
         "}"].join('\n'),
    
        DEFAULTS : {
            "uShininess"        : 230.0,
            "uLightDirection"   : [0.0, -1.0, -1.0],
            "uLightAmbient"     : [0.03,0.03,0.03,1.0],
            "uLightDiffuse"     : [1.0,1.0,1.0,1.0], 
            "uLightSpecular"    : [1.0,1.0,1.0,1.0],
            "uMaterialAmbient"  : [1.0,1.0,1.0,1.0],
            "uMaterialDiffuse"  : [0.8,0.8,0.8,1.0],
            "uMaterialSpecular" : [1.0,1.0,1.0,1.0]
        }
    }));
   
}; 

vxl.go.essl.phong = new vxlPhongProgram();
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   

/**
 * @class
 * @private
 */

vxlBlenderProgram.prototype = new vxlProgram();
vxlBlenderProgram.prototype.constructor = vxlBlenderProgram;

function vxlBlenderProgram(){
    
    this.copy(vxlProgram.createFromJSON({
    
        ID : 'blender',
    
        VERTEX_SHADER : [
        
        "attribute vec3 aVertexPosition;",
        "attribute vec3 aVertexNormal;",
    
        "uniform mat4 mModelView;",
        "uniform mat4 mPerspective;",
        "uniform mat4 mNormal;",
        
        "uniform vec3 uLightPosition;",
        "uniform bool uTranslateLight;",
        
        "varying vec3 vNormal;",
        "varying vec3 vLightRay;",
        "varying vec3 vEye;",
        
        
        "void main(void) {",
        " vec4 vertex = mModelView * vec4(aVertexPosition, 1.0);",
        " vNormal = vec3(mNormal * vec4(aVertexNormal, 1.0));",
        " vec4 lightPosition = vec4(0.0);",
         
        "if (uTranslateLight){",
        "      lightPosition =   mModelView * vec4(uLightPosition, 1.0);",
        "      vLightRay = vertex.xyz - lightPosition.xyz;",
        "      vEye = -vec3(vertex.xyz);",
        "}",    
        "else {",
        "     lightPosition = vec4(uLightPosition, 1.0);",
        "     vLightRay = vertex.xyz - lightPosition.xyz;",
        "     vEye = -vec3(vertex.xyz);",
        "}",
        "gl_Position = mPerspective * mModelView * vec4(aVertexPosition, 1.0);",
        "}"].join('\n'),
        
        FRAGMENT_SHADER : [
        "#ifdef GL_ES",
        "precision highp float;",
        "#endif",
        "uniform vec3 uLa;",
        "uniform vec3 uLd;",  
        "uniform vec3 uLs;",
        
        "uniform vec3 uKa;",
        "uniform vec3 uKd;",  
        "uniform vec3 uKs;",
        "uniform float uNs;",
        "uniform float d;",
        "uniform int illum;",
     
        "varying vec3 vNormal;",
        "varying vec3 vLightRay;",
        "varying vec3 vEye;",
    
        "void main(void)  {",
        "   if (illum ==0){",
        "       gl_FragColor = vec4(uKd,d);",
        "       return;",
        "   }",
        "   vec3 COLOR = vec3(0.0,0.0,0.0);",
        "   vec3 N =  normalize(vNormal);",
        "   vec3 L =  vec3(0.0,0.0,0.0);",
        "   vec3 E =  vec3(0.0,0.0,0.0);",
        "   vec3 R =  vec3(0.0,0.0,0.0);",
        "    if (illum == 1){",
        "        L = normalize(vLightRay);",    
        "        N = normalize(vNormal);",  
        "        COLOR += (uLa * uKa) + (uLd * uKd * clamp(dot(N, -L),0.0,1.0));",
        "        gl_FragColor =  vec4(COLOR,d);",
        "        return;",
        "   }",
        "   if (illum == 2){",
        "        E = normalize(vEye);",
        "        L = normalize(vLightRay);",
        "        R = reflect(L, N);",
        "        COLOR += (uLa * uKa);",
        "        COLOR += (uLd * uKd * clamp(dot(N,-L),0.0,1.0));",
        "        COLOR += (uLs * uKs * pow( max(dot(R, E), 0.0), uNs) * 4.0);",
        "        gl_FragColor =  vec4(COLOR,d);",
        "       return;",
        "   }" ,
        "}"].join('\n'),
        
        DEFAULTS : {
            "uLa"   : [1.0,1.0,1.0],
            "uLd"   : [1.0,1.0,1.0],
            "uLs"   : [0.8,0.8,0.8],
            "uKa"   : [1.0,1.0,1.0],
            "uKd"   : [1.0,1.0,1.0],
            "uKs"   : [1.0,1.0,1.0],
            "uNs"   : 1.0,
            "uTranslateLight" : false,
            "uLightPosition"   : [0,50,50]
        }
    }));
};


vxl.go.essl.blender = new vxlBlenderProgram();
 /*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   

/**
 * @private
 * @class
 */

vxlBakeProgram.prototype = new vxlProgram();
vxlBakeProgram.prototype.constructor = vxlBakeProgram;

function vxlBakeProgram(){
    
    this.copy(vxlProgram.createFromJSON({
    
        ID : 'bake',
    
        VERTEX_SHADER : [
        "attribute vec3 aVertexPosition;",
        "attribute vec3 aVertexNormal;",
        "attribute vec3 aVertexColor;",
        "attribute vec3 aPosition;",
        "attribute vec3 aScale;",
        "attribute float aShading;",
        
        "uniform mat4 mModelView;",
        "uniform mat4 mPerspective;",
        "uniform mat4 mNormal;",
        "uniform mat4 mModelViewPerspective;",
    
        "uniform vec3 uLightDirection;",
        "uniform vec4 uLightAmbient;",  
        "uniform vec4 uLightDiffuse;",
        "uniform bool uUseLightTranslation;",
        "varying vec4 vFinalColor;",
        
        "void main(void) {",
        "   vec3 position = (aVertexPosition * aScale) + aPosition;",
        "   gl_Position = mModelViewPerspective * vec4(position, 1.0);",
        "   vFinalColor = vec4(aVertexColor,1.0);",
        
        "   if (aShading == 1.0){",
        "      vec3 N = vec3(mNormal * vec4(aVertexNormal, 1.0));",
        "      vec3 L = normalize(uLightDirection);",
        "      if (uUseLightTranslation) { L = vec3(mNormal * vec4(L,1.0));}",
        "      float lambertTerm = max(dot(N,-L),0.4);",
        "      vec4 Ia = uLightAmbient;",
        "      vec4 Id = vFinalColor * uLightDiffuse * lambertTerm;",
        "      vFinalColor = Ia + Id;",
        "      vFinalColor.a = 1.0;",
        "   }",
        "}"].join('\n'),
        
        FRAGMENT_SHADER : [
        "#ifdef GL_ES",
        "precision highp float;",
        "#endif",
    
        "varying vec4  vFinalColor;",
    
        "void main(void)  {",
        "       gl_FragColor = vFinalColor;",
        "}"].join('\n'),
        
        DEFAULTS : {
            "uLightDirection"   : [0.0,0.0,-1.0],
            "uLightAmbient"     : [0.0,0.0,0.0,1.0],
            "uLightDiffuse"     : [1.0,1.0,1.0,1.0],
            "uUseLightTranslation" : false
        }
    }));
 
}; 



vxl.go.essl.bake = new vxlBakeProgram();


/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  

/**
 * <p>Presents a simple interface to communicate with a ESSL (GLSL) program
 * This class is responsible for creating, compiling and linking any ESSL program.
 * It also has methods to query and set uniforms and attributes belonging to the program
 * that is being currently executed in the GPU</P>
 * 
 * <p>a vxlProgramManager maintains a database of the programs that have been linked to the GPU. 
 * This way, program switching is easier as it is not necessary to go through the 
 * compilation and linking process every time</p>
 * @class
 * @constructor
 */
function vxlProgramManager (gl) {
    this._gl                = gl;
    this._codebase          = {};

    this._program           = {};
    this._attributeList     = {};
    this._enabledAttributes = [];
    this._uniformList       = {};
    this._uniformType       = {};

    this._uniform_cache     = {};
    
    this._essl     =  null;
    this._currentProgramID        = "";
    this._currentUniformLocation  = {};
    this._defaults         = [];
    this._oneTimeWarning  = false;
};


/**
 * Register a program in the database
 * @param {JSON} the program to register
 */
vxlProgramManager.prototype.register = function(program){
	/*@TODO: this method receives a JSON Object we could instead
	 * receive a text file and parse it into JSON. This would make
	 * the writing of shaders much easier.
	 */
	vxl.go.console('Registering program '+ program.ID);
    this._codebase[program.ID] = program;
};

/**
 * Verifies whether a program is loaded in the database or not
 * @param {String} ID program id
 * @returns true if the program is registered, false otherwise
 */
vxlProgramManager.prototype.isRegistered = function(ID){
	return (this._codebase[ID] != undefined);
};

/**
 * Loads a program
 * @param {String} ID the id of the program to load
 */
vxlProgramManager.prototype.loadProgram = function(ID){
    
    var code = this._codebase[ID];
    
    var gl   = this._gl;
    var esslProgram  = gl.createProgram();
    
    
    if (code.VERTEX_SHADER){
        var vs = this._createShader(vxl.def.essl.VERTEX_SHADER,code.VERTEX_SHADER);
        gl.attachShader(esslProgram, vs);
    }
    
    if (code.FRAGMENT_SHADER){
        var fs = this._createShader(vxl.def.essl.FRAGMENT_SHADER,code.FRAGMENT_SHADER);
        gl.attachShader(esslProgram, fs);
    }
    
    //fix for version 0.89.2 Making sure that the vertex array is ALWAYS the attribute with location 0
    gl.bindAttribLocation(esslProgram, 0 , vxl.def.essl.VERTEX_ATTRIBUTE);
    
    gl.linkProgram(esslProgram);
     
    if (!gl.getProgramParameter(esslProgram, gl.LINK_STATUS)) {
        
        alert(ID+":\n\n "+gl.getProgramInfoLog(esslProgram));
        throw("Error linking program "+ID+":\n\n "+gl.getProgramInfoLog(esslProgram));
    }
    
    this._program[ID] = esslProgram;
  
};

/**
 * Verifies if a program is loaded
 * @param {String} ID the program id
 * @returns true if the program is loaded, false otherwise
 */
vxlProgramManager.prototype.isLoaded = function(ID){
    return (this._program[ID] != undefined);
};

/**
 * Uses a program from the database.
 * If you are not sure if the program you want to use is in the database then call vxlRenderer.setProgram instead
 * @param {String} ID the program id
 * @see vxlRenderer#setProgram
 */
vxlProgramManager.prototype.useProgram = function(ID){

    var gl = this._gl;
    var esslProgram = this._program[ID];
    
    if (esslProgram != undefined && esslProgram != null){
        
        if (esslProgram == this._essl) return;
        
        //gl.linkProgram(esslProgram);
        gl.useProgram (esslProgram);
        
        this._essl = esslProgram;
        this._currentProgramID = ID;
        this._parseUniforms();
        this._oneTimeWarning  = false;
    }
    else{
        alert("Program: the program " + ID + " has NOT been loaded");
    }
};

    
/**
 * Loads the uniform defaults for the current program
 */
vxlProgramManager.prototype.loadDefaults = function(){
    var code = this._codebase[this._currentProgramID];
   
    if ('DEFAULTS' in code){
    
        var defaults = code.DEFAULTS;
        
        
        for(var u in defaults){
            this.setUniform(u,defaults[u]);
        }
    }
    //overriding defaults
    var defaults = this._defaults[this._currentProgramID];
    if (defaults != undefined){
  
        for (var u in defaults){
            this.setUniform(u,defaults[u])
        }
    }
   
};

/**
 * Overrides defaults by hand 
 */
vxlProgramManager.prototype.setDefault = function(programID, uniformName, value){
    
    if (this._defaults[programID] == undefined){
        this._defaults[programID] = {}
    }
  
    this._defaults[programID][uniformName] = value;
    
    //Overriding behaviour
    if (programID == this._currentProgramID){
        this.setUniform(uniformName, value);
    }
};


/**
 * Overrides defaults by hand 
 */
vxlProgramManager.prototype.getDefault = function(programID, uniformName){
    
    if (this._defaults[programID] == undefined){
        return undefined;
    }
  
    return this._defaults[programID][uniformName];
};

/**
 * Sets all the uniforms defined by the object obj
 * @param {Object} an object containing uniform names and values. Every property of this object
 * will be considered a uniform
 */
vxlProgramManager.prototype.setUniforms = function(obj){
	for(uni in obj){
		this.setUniform(uni,obj[uni]);
	}
};

/**
 * Sets a uniform.
 * Uses polymorphism to make the programmers life happier
 * @param {String} uniform name
 * @param {Object} the value
 */
vxlProgramManager.prototype.setUniform = function(uniformID, value, hint){
    
    var webGLProgram 		= this._essl;
    var uniformList 		= this._uniformList[this._currentProgramID];
    var uniformLoc  		= this._currentUniformLocation;
    var uniform_cache 		= this._uniform_cache;
    
    if (uniformList.hasObject(uniformID)){
        uniformLoc[uniformID] = this._gl.getUniformLocation(webGLProgram,uniformID);
        
    }
    else{
    	throw('Program: the uniform '+uniformID+' is not defined for the program '+this._currentProgramID);
        return;
    }
    
    uniform_cache[uniformID] = value;
    this._setPolymorphicUniform(uniformID, uniformLoc[uniformID], value, hint);
};

/**
 * Returns a uniform value from the cache maintained by vxlProgramManager
 * @param {String} the uniform id
 */
vxlProgramManager.prototype.getUniform = function(uniformID){
    //TODO: Think about this
    //if(!(name in this._uniformList)){
      //  alert('Program: the uniform ' + name + ' has not been set');
        //return null;
   //}
    return this._uniform_cache[uniformID];
};

/**
 * This method tells the WebGL context how to access the information contained in the
 * WebGL buffer associated with the attribute
 * @param {String} name name of the attribute
 * 
 */
vxlProgramManager.prototype.setAttributePointer = function(name, numElements, type, norm,stride,offset){
    var a = this._getAttributeLocation(name);
    this._gl.vertexAttribPointer(a,numElements, type, norm, stride, offset);
};

/**
 * Enables a vertex attribute array
 * @param {String} name the name of the attribute array to enable
 */
vxlProgramManager.prototype.enableAttribute = function(name){
    
   if (this._enabledAttributes.indexOf(name) != -1) return; //Speeds up
     
   var a = this._getAttributeLocation(name);
   this._gl.enableVertexAttribArray(a);
   this._enabledAttributes.push(name);
};

/**
 * Disables a vertex attribute array
 * @param {String} name the name of the attribute array to disable
 * 
 */
vxlProgramManager.prototype.disableAttribute = function(name){
    
    var idx = this._enabledAttributes.indexOf(name); 
    if (idx != -1) { //so it is enabled
        var a = this._getAttributeLocation(name);
        this._gl.disableVertexAttribArray(a);
        this._enabledAttributes.splice(idx,1);
    }
};

/**
 * Creates a WebGL shader
 * 
 * @private This method is private.
 */
vxlProgramManager.prototype._createShader = function(type,code){
    var gl      = this._gl;
    var shader = null;
    
    if (type == vxl.def.essl.VERTEX_SHADER){
        shader = gl.createShader(gl.VERTEX_SHADER);
    }
    else if (type == vxl.def.essl.FRAGMENT_SHADER){
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    }
    
    if (code == undefined || code == null){
        alert('Error getting the code for shader of type ' + type);
    }
    
    gl.shaderSource(shader, code);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(type+":\n\n "+gl.getShaderInfoLog(shader));
        throw("Error compiling shader "+type+":\n\n "+gl.getShaderInfoLog(shader));
    }
    
    return shader;
};
    

/**
 * Parses uniforms
 * This method is private
 * @private
 * 
 */
vxlProgramManager.prototype._parseUniforms = function(id){
    
    vs = this._codebase[this._currentProgramID].VERTEX_SHADER;
    fs = this._codebase[this._currentProgramID].FRAGMENT_SHADER;
    /*@TODO: look for a way to retrieve uNames directly from the parsing of the shaders
    this should simplify the structure of the JSON file representing the program*/
    uNames = this._codebase[this._currentProgramID].UNIFORMS;
    
    uTypes = {};
    
    
    for (var i=0;i< uNames.length; i++){
        var uniformID = uNames[i];
        var rex = new RegExp('uniform\\s+\\w+\\s'+uniformID,'g');
        
        if (vs.search(rex) != -1){
            uTypes[uniformID] = vs.substring(vs.search(rex),vs.length).substring(0,vs.indexOf(';')).split(' ')[1];
        }
        
        else if(fs.search(rex) != 1){
            uTypes[uniformID] = fs.substring(fs.search(rex),fs.length).substring(0,fs.indexOf(';')).split(' ')[1];
        }
        
        else{
            alert('Program: In the program '+this._currentProgramID+' the uniform '+uniformID+' is listed but not used');
        }
    }
    
    
    this._uniformList[this._currentProgramID] = uNames;
    this._uniformType[this._currentProgramID] = uTypes; 
};

/**
 * Obtains an attribute location
 * This method is private
 * @param {String} name
 * @private
 */
vxlProgramManager.prototype._getAttributeLocation = function(name){

    if(!(name in this._attributeList)){
        this._attributeList[name] = this._gl.getAttribLocation(this._essl,name);
    }

    return this._attributeList[name];
};

/**
 * This is one of the jewels of Voxelent. Based on the information contained in the 
 * program database, it will do the appropriate gl call to set the uniform
 * This method is private. Use setUniform instead.
 * @see vxlProgramManager#setUniform
 * @private 
 */
vxlProgramManager.prototype._setPolymorphicUniform = function(uniformID, locationID,value,hint){

	//In the extend of what it is reasonable,
	//We cross check GLSL type information with actual javascript variable types 
	//to make the right calls
	//hint allows better casting of int and float values. If not specified default is float
    
    var gl = this._gl;
    var glslType = this._uniformType[this._currentProgramID][uniformID];
    
    if (glslType == 'bool'){
    	//if (typeof value != 'boolean') { 
    	//	vxl.go.console('Program: the uniform '+uniformID+' is defined as bool in GLSL. However the JS variable is not');
    	//}/
        gl.uniform1i(locationID,value);
        return;
    }
    
    else if (glslType == 'float'){
    	gl.uniform1f(locationID,value);
    	return;
    }
    
    else if (glslType == 'int' || glslType == 'sampler2D'){
        gl.uniform1i(locationID,value);
        return;
    }
    
    else if (glslType == 'mat4'){    
        gl.uniformMatrix4fv(locationID,false,value);
        return;
    }
    
    
    else if (value instanceof Array){
        
        /*If we receive a uniform of length 3 but the type is length 4
         * complete with 1.0
         * This will happen for blender scenes where the material colors are 
         * of length 3 (no alpha)
         * 
         */ 
         
        if (value.length == 3 && glslType == 'vec4'){
             value[3] = 1.0;
             if (!this._oneTimeWarning){
                 alert('The uniform '+uniformID+' has only 3 components but voxelent needs 4. This is a one time warning');
                 this._oneTimeWarning = true;
             }
        }
        
        if (hint  == 'int'){
            switch(value.length){
                case 1: { gl.uniform1iv(locationID,value); break; };
                case 2: { gl.uniform2iv(locationID,value); break; };
                case 3: { gl.uniform3iv(locationID,value); break; };
                case 4: { gl.uniform4iv(locationID,value); break; };
                default: alert('ERROR');
            }
       }
       else{
            switch(value.length){
                case 1 : { gl.uniform1fv(locationID,value); break; }
                case 2 : { gl.uniform2fv(locationID,value); break; }
                case 3 : { gl.uniform3fv(locationID,value); break; }
                case 4 : { gl.uniform4fv(locationID,value); break; }
                default: alert('ERROR');
            }
       }
    }
    
    else {
    	alert('Program: ERROR. The uniform  '+uniformID+ ' could not be mapped');
    }
};
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   
/**
 * One of the main classes of Voxelent's Nucleo
 * A renderer object encapsulates most of the low level calls to WebGL.
 * It is here where Nucleo obtains a reference to the WebGL context.
 * 
 * It is also here here (and in the Actor class) where all the attributes and uniforms are passed
 * to the rendering program.
 * 
 * @class
 * @constructor
 * @author Diego Cantor
 */
function vxlRenderer(vw){
    
	this.view       	= vw;
	this.renderRate 	= vxl.def.renderer.rate.NORMAL;
	this.mode       	= vxl.def.renderer.mode.TIMER;
    this.gl         	= this.getWebGLContext();
    this.pm        	    = new vxlProgramManager(this.gl);
    this.transforms 	= new vxlTransforms(vw);
    this.fps            = 0;
    this.currentProgram = undefined;
    this.engine 		= new vxlRenderEngine(this);
    
    
    this._time          = 0;
    this._startDate     = 0;
    this._running       = false;
    this._clearColor    = undefined;
    this._renderTarget  = undefined;
    
    this._knownPrograms = {};
    this._enforce       = false; //to enforce the program or not
    this.setProgram(vxl.go.essl.lambert);
    
}

/**
 * Tries to obtain a WebGL context from the canvas associated with the view to which this
 * renderer belongs to.
 * @TODO: Review depth test and blending functions maybe these should be configurable.
 */
vxlRenderer.prototype.getWebGLContext = function(){
	
	var WEB_GL_CONTEXT = null;
	var canvas     = this.view.canvas;
	this.width     = canvas.width;
	this.height    = canvas.height;
	
	var names      = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
	
	for (var i = 0; i < names.length; ++i) {
		try {
			WEB_GL_CONTEXT = canvas.getContext(names[i]);
		} 
		catch(e) {}
		if (WEB_GL_CONTEXT) {
			break;
		}
	}
	if (WEB_GL_CONTEXT == null) {
		//@TODO: print a nicer jquery  alert
		alert("Sorry: WebGL is not available on this browser. Have you tried the newest version of Firefox, Chrome or Safari?"); 
		return;
	}
	else {
		this._initializeGLContext(WEB_GL_CONTEXT);
		
	}
    return WEB_GL_CONTEXT;
};

/**
 * Initializes the WebGL context
 *
 * @private 
 */
vxlRenderer.prototype._initializeGLContext = function(gl){
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthFunc(gl.LESS);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
};


/**
 * Tries to add a new program definition to this renderer
 * @param {vxlProgram} program an instance of a vxlProgram object or one of its descendents
 * @param {vxlEngine} engine (optional) a new engine
 */
vxlRenderer.prototype.setProgram = function(program,engine,forceIt){
    
    
    if (this._enforce && program.ID != this.currentProgram.ID){
        throw new vxlRendererException("The current program is being enforced. Please use vxlRenderer.releaseProgram first");
    }
    
    if (forceIt != undefined && forceIt == true){
        this._enforce = true;
    }
    else{
        this._enforce = false;
    }
    
    
    //Check if the program has be instantiated before
    if (this._knownPrograms[program.ID] == undefined || this._enforce){
        this._knownPrograms[program.ID]= program;
    }
    
    var prg = this._knownPrograms[program.ID];
    var pm = this.pm;

	if (!pm.isRegistered(prg.ID)){
		pm.register(prg);
	}
	
	if (!pm.isLoaded(prg.ID)){
		pm.loadProgram(prg.ID);
	}
	
	pm.useProgram(prg.ID);
	pm.loadDefaults();
	
	this.currentProgram = prg;
	
	if (engine != undefined && engine != this.engine){
	   this.setEngine(engine);
	}
	
	
};

/**
 * When the current program is being enforced by the renderer (see setProgram), any
 * subsequent call to setProgram will be unsuccessful. So for instance, actors
 * who want to use a different program to be rendered would not be able to do so.
 * 
 * This method releases the current program from being enforced 
 */
vxlRenderer.prototype.releaseProgram = function(){
    this._enforce = false;
}

/**
 * Sets the current rendering engine. 
 * 
 * @param {vxlEngine} engine The engine to be used.  
 */
vxlRenderer.prototype.setEngine = function(engine){
    if (engine != null && engine != undefined){
        this.engine = engine
    }
    else if (this.engine == undefined){
        this.engine = new vxlRenderEngine(this);
    }
}


/**
 * Clears the rendering context
 */
vxlRenderer.prototype.clear = function(){
    this.gl.clearColor(this._clearColor[0], this._clearColor[1], this._clearColor[2], 1.0);
	this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
	this.gl.viewport(0, 0, this.view.canvas.width, this.view.canvas.height); //@TODO: Think about dividing view ports for multi-view apps - March 19/2012
	this.transforms.calculatePerspective();
};

/**
 * Sets the rendering mode. Options are in vxl.def.renderer.mode
 * This method updates the rendering mode and tries to restart the rendering process
 * @param {String} mode the mode to set
 */
vxlRenderer.prototype.setMode = function(mode){
    this.stop();
    this.mode = mode;
    this.start();   
};

/**
 * Starts the renderer
 */
vxlRenderer.prototype.start = function(){
    
    this._running = true;
    this._startDate = new Date().getTime();
    this._time  = 0;
    
	if(this.mode == vxl.def.renderer.mode.TIMER){
		vxl.go.console('Renderer: starting rendering for view ['+this.view.name+'] at '+this.renderRate+ 'ms');
		this._timeUp();
		//this.timerID = setInterval((function(self) {return function() {self.render();}})(this),this.renderRate); 
	}
	else if(this.mode == vxl.def.renderer.mode.ANIMFRAME){
	    vxl.go.console('Renderer: starting rendering at the fastest speed',true);
		vxl.go.renderman.render();
	}
};

/**
 * Implements a self adjusting timer
 * @see <a href="http://www.sitepoint.com/creating-accurate-timers-in-javascript/">Creating accurate timers in JavasScript</a>
 * @private   
 */
vxlRenderer.prototype._timeUp = function(){
    if (!this._running) return;
    
    this.render();
    
    if (this._time == this.renderRate * 100){  
        this._time = 0;
        this._startDate = new Date().getTime();
    }
    
    this._time += this.renderRate;

    var diff = (new Date().getTime() - this._startDate) - this._time;
    
    if (diff > this.renderRate) diff = 0; //ignore it
    
    setTimeout((function(self){
        return function(){
            self._timeUp();
        }
    })(this), this.renderRate - diff);
}
/**
 * Stops the renderer
 */
vxlRenderer.prototype.stop = function(){
	if (this.mode == vxl.def.renderer.mode.TIMER){
		//clearInterval(this.timerID);
		this._running = false;
	}
	else if (this.mode == vxl.def.renderer.mode.ANIMFRAME){
		vxl.go.renderman.cancel();
	}
};

/**
 * Sets the rendering rate in ms
 * @param {Number} /test-baking.htmlrate the new rendering rate in milliseconds
 */
vxlRenderer.prototype.setRenderRate = function(rate){ //rate in ms
    
    if (rate == undefined || rate <=0){ 
        throw 'vxlRenderer.setRenderRate: the rate cannot be zero or undefined';
    } 
    
    if (this.mode == vxl.def.renderer.mode.ANIMFRAME){
        throw 'vxlRenderer.setRenderRate: if the mode is ANIMFRAME render rate is irrelevant';
    }
      
	this.stop();
	this.renderRate = rate;
	this.start();
    
    vxl.go.console('Renderer: view['+this.view.name+'], render rate = ' + rate,true);

};

/**
 * Sets the color used to clear the rendering context
 * @param {Number, Array, vec3} r it can be the red component, a 3-dimensional Array or a vec3 (glMatrix)
 * @param {Number} g if r is a number, then this parameter corresponds to the green component
 * @param {Number} b if r is a number, then this parameter corresponds to the blue component
 * @see vxlView#setBackgroundColor
 */
vxlRenderer.prototype.clearColor = function(r,g,b){
    var cc = vxl.util.createArr3(r,g,b);
    this._clearColor = cc;
	this.gl.clearColor(cc[0], cc[1], cc[2], 1.0);
};

/**
 * Sets the clear depth for the rendering context
 * @param {Number} d the new clear depth
 */
vxlRenderer.prototype.clearDepth = function(d){
	this.gl.clearDepth(d);
};

/**
 * Renders the scene using the current engine
 */
vxlRenderer.prototype.render = function(){
    var engine = this.engine, scene = this.view.scene, start = undefined, elapsed = undefined;
    
    this.clear();                   //clear the canvas
    engine.allocate(scene);	    //allocate memory for actors added since last rendering
    
    start = new Date().getTime();
    engine.render(scene);
    elapsed = new Date().getTime() - start;
    
    engine.deallocate(scene);     //deallocate memory if necessary
    
    // calculating FPS metric
    if(elapsed >0){
        this.fps = Math.round((this.fps * 0.80 + (1000.0/elapsed) * 0.2)* 100)/100;
    }
    
};

/**
 * Reallocates the actors marked as dirty, without requiring rerendering. This mechanism allows
 * to update the GL buffers for dirty actors. 
 */
vxlRenderer.prototype.reallocate = function(){
  this.engine.allocate(this.view.scene);  
};

/**
 * Disables offscreen rendering
 *  
 */
vxlRenderer.prototype.disableOffscreen = function(){
    this.engine.disableOffscreen();
};


/**
 *Sets the render target for this renderer 
 */
vxlRenderer.prototype.enableOffscreen = function(){
    this._renderTarget = new vxlRenderTarget(this);
    this.engine.enableOffscreen(this._renderTarget);    
};

/**
 * Returns true if the offscreen rendering is enabled. False otherwise. 
 */
vxlRenderer.prototype.isOffscreenEnabled = function(){
    return this.engine.isOffscreenEnabled();  
};


/**
 * @class  Encapsulates a renderer exception
 * @param {Object} message
 */
function vxlRendererException(message){
    this.message = message;
};

/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   


function vxlRenderTarget(renderer){
   
    this.canvas         = renderer.view.canvas;
    this.texture        = null;
    this.framebuffer    = null;
    this.renderbuffer   = null;
    this.gl             = renderer.gl;
    this.configure(); 
};


vxlRenderTarget.prototype.configure = function(){
    var width = this.canvas.width;
    var height = this.canvas.height;
    var gl = this.gl;
    
    //1. Init Picking Texture
    this.texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    
    //2. Init Render Buffer
    this.renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
    
    
    //3. Init Frame Buffer
    this.framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderbuffer);
    

    //4. Clean up
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};

vxlRenderTarget.prototype.update = function(){
    
    var gl = this.gl;
    var width = this.canvas.width;
    var height = this.canvas.height;
   
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    
    //2. Init Render Buffer
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
};

/**
 * 
 * @param{Number} x
 * @param{Number} y
 */
vxlRenderTarget.prototype.readPixel = function(x,y){
    
    var gl = this.gl;
    var readout = new Uint8Array(1 * 1 * 4);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    gl.readPixels(x,y,1,1,gl.RGBA,gl.UNSIGNED_BYTE,readout);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return readout;
}
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 

/**
 * Models are totally independent of views and of the rendering process
 * @class Represents a geometric object. A model is represented by an actor in a scene.
 * @constructor
 * @param {String} name the name for this model
 * @param {Object} JSON_OBJECT the JSON Object that defines this model (Optional)
 * @see vxlModel#load
 * @author Diego Cantor
 */
function vxlModel(name, JSON_OBJECT){
	this.name       = name;
	this.indices 	= [];
	this.vertices 	= [];
	this.scalars 	= undefined;
	this.diffuse	= undefined;
	this.ambient    = undefined;
	this.specular   = undefined;
	this.shininness = undefined;
	this.normals 	= undefined;
	this.wireframe 	= undefined;
	this.bb         = [0,0,0,0,0,0];
    this.centre     = [0,0,0,0,0,0];
	this.mode       = vxl.def.actor.mode.SOLID
	this.image      = undefined;
	this.uri        = undefined;
	this.colors     = undefined;
	this.type       = vxl.def.model.type.SIMPLE;
	this.renderable = undefined;
   
    if (JSON_OBJECT != undefined){
        this.load(this.name, JSON_OBJECT);
    }
    
    this.setType(this.type);
};

/**
 * Sets the type of model. A renderable object is created and associated
 * with this model in case the type is MESH or BIG_DATA
 * 
 * @param {vxl.def.model.type} type the type of model
 */
vxlModel.prototype.setType = function(type){
    
    if (this.indices.max() < vxl.def.model.MAX_NUM_INDICES && 
        type == vxl.def.model.type.BIG_DATA){
            throw('The model is not big enough to be of BIG_DATA type. Max index found: '+this.indices.max());
        }
    
    this.type = type;  
};

/**
 * Indices to draw the bounding box. The vertices in this case will correspond
 * to the actor bounding box calculation 
 * @static
 */
vxlModel.BB_INDICES = [0,1,1,2,2,3,3,0,0,4,4,5,5,6,6,7,7,4,1,5,2,6,3,7];


/**
 * Populates this model with the JSON_OBJECT (JSON object)
 * @param {String} nm the name given to this model
 * @param {Object} JSON_OBJECT the JSON object that describes the model
 */
vxlModel.prototype.load = function(nm,JSON_OBJECT){
	this.name		= nm.replace(/\.[^/.]+$/, "")
	if (JSON_OBJECT.name != null){ //if the name is defined in the JSON object, then use it
		this.name = JSON_OBJECT.name;
	}
	
	//Load all properties
	for(i in JSON_OBJECT){
		this[i] = JSON_OBJECT[i];
	}
	
	this.update();

};

/**
 * Update model state when the model has changed (changes in vertices or indices) 
 */
vxlModel.prototype.update = function(){
        //Now minimal checks
    if (this.vertices == undefined){
        alert('The model '+ this.name+' does not have vertices. Impossible to render!');
    }
    

    if(
        (this.normals == undefined || 
            (this.normals != undefined && this.normals.length == 0))
        && this.indices != undefined)
    {
        this.computeNormals();
    }
    
     
    if (this.wireframe == undefined){
        this.computeWireframeIndices();
    }
    
    if (this.mode == undefined){
        this.mode = vxl.def.actor.mode.SOLID;
    }
    
    if (this.texture != undefined){
        this.mode = vxl.def.actor.mode.TEXTURED;
    }
    
    this.computeBoundingBox();
    
    
    if (this.type == vxl.def.model.type.SIMPLE && this.indices.max() > vxl.def.model.MAX_NUM_INDICES){
        this.setType(vxl.def.model.type.BIG_DATA);
    }
    
};

/**
 * Calculates the normals for this model in case that the JSON object does not include them
 * 
 * 
 */
vxlModel.prototype.computeNormals = function(){
  //face normal calculation
    var vs = this.vertices;
	var ind = this.indices;
	var x=0; 
    var y=1;
	var z=2;
	
	var ns = [];
	for(var i=0;i<vs.length;i=i+3){ //for each index, initialize normal x, normal y, normal z
		ns[i+x]=0.0;
		ns[i+y]=0.0;
		ns[i+z]=0.0;
	}
	
	for(var i=0;i<ind.length;i=i+3){ //we work on triads of vertex to calculate normals so i = i+3 (i = indices index)
		var v1 = [];
		var v2 = [];
		var normal = [];	
		//p2 - p1
		v1[x] = vs[3*ind[i+2]+x] - vs[3*ind[i+1]+x];
		v1[y] = vs[3*ind[i+2]+y] - vs[3*ind[i+1]+y];
		v1[z] = vs[3*ind[i+2]+z] - vs[3*ind[i+1]+z];
		//p0 - p1
		v2[x] = vs[3*ind[i]+x] - vs[3*ind[i+1]+x];
		v2[y] = vs[3*ind[i]+y] - vs[3*ind[i+1]+y];
		v2[z] = vs[3*ind[i]+z] - vs[3*ind[i+1]+z];
		//cross product
		normal[x] = v1[y]*v2[z] - v1[z]*v2[y];
		normal[y] = v1[z]*v2[x] - v1[x]*v2[z];
		normal[z] = v1[x]*v2[y] - v1[y]*v2[x];
		
		for(j=0;j<3;j++){ //update the normals of the triangle
			ns[3*ind[i+j]+x] =  ns[3*ind[i+j]+x] + normal[x];
			ns[3*ind[i+j]+y] =  ns[3*ind[i+j]+y] + normal[y];
			ns[3*ind[i+j]+z] =  ns[3*ind[i+j]+z] + normal[z];
		}
	}
		
	//normalize the result
	for(var i=0;i<vs.length;i=i+3){ //the increment here is because each vertex occurs with an offset of 3 in the array (due to x, y, z contiguous values)
	
	    var nn=[];
		nn[x] = ns[i+x];
		nn[y] = ns[i+y];
		nn[z] = ns[i+z];
		
		var len = Math.sqrt((nn[x]*nn[x])+(nn[y]*nn[y])+(nn[z]*nn[z]));
		if (len == 0) len = 1.0;
		
		nn[x] = nn[x]/len;
		nn[y] = nn[y]/len;
		nn[z] = nn[z]/len;
		
		ns[i+x] = nn[x];
		ns[i+y] = nn[y];
		ns[i+z] = nn[z];
	}
	this.normals = ns;
};

/**
 * Flips the normals 
 */
vxlModel.prototype.flipNormals = function(){
    var ns = this.normals;
    
    if (ns == undefined) return; //no normals
    
    for (var i=0; i<ns.length; i+=1){
        ns[i] = -ns[i];
    }
};
  
/**
 * Generate the wireframe indices using the model indices
 */  
vxlModel.prototype.computeWireframeIndices = function(){
	var ind = this.indices;
    var wfi = [];
	var j = 0;
	for(var i=0; i<ind.length; i=i+3){
	   wfi[j] = ind[i];
	   wfi[j+1] = ind[i+1];
	   wfi[j+2] = ind[i+1];
	   wfi[j+3] = ind[i+2];
	   wfi[j+4] = ind[i+2];
	   wfi[j+5] = ind[i];
	   j = j+6;
	}
	this.wireframe = wfi;
};


/**
 * Calculate the bounding box of this model and its centre
 * 
 */
vxlModel.prototype.computeBoundingBox = function(){	
    
    //This is the case with the scene toys
    if (this.vertices.length == 0){
        this.bb = [0,0,0,0,0,0];
        this.centre = [0,0,0,0,0,0];
        return;
    }
    
	var vs = this.vertices;
	var bbm  = [vs[0],vs[1],vs[2],vs[0],vs[1],vs[2]];
	
	var i = vs.length;  
	for(var i=0, N = vs.length;i<N;i=i+3){
		bbm[0] = Math.min(bbm[0],vs[i]);
		bbm[1] = Math.min(bbm[1],vs[i+1]);
		bbm[2] = Math.min(bbm[2],vs[i+2]);
		bbm[3] = Math.max(bbm[3],vs[i]);
		bbm[4] = Math.max(bbm[4],vs[i+1]);
		bbm[5] = Math.max(bbm[5],vs[i+2]);
	}
	
	
	var c = [0, 0, 0];
     //computes the centre 
    c[0] = (bbm[3] + bbm[0]) /2;
    c[1] = (bbm[4] + bbm[1]) /2;
    c[2] = (bbm[5] + bbm[2]) /2;
    
    
    this.bb = bbm;  
    this.centre = c;
};

/**
 *Returns the bounding box vertices. This method is used by the rendering engine 
 */
vxlModel.prototype.getBoundingBoxVertices = function(){
    var b = this.bb;
    return [
        b[0], b[1], b[2],
        b[0], b[4], b[2],
        b[3], b[4], b[2],
        b[3], b[1], b[2],
        b[0], b[1], b[5],
        b[0], b[4], b[5],
        b[3], b[4], b[5],
        b[3], b[1], b[5] 
        ];
};

/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/

/**
 * A cell is the minimum surface that can be selected on a mesh
 * @class Provides cell definitions
 * @constructor
 * @author Diego Cantor
 */
function vxlCell(mesh, index, vertices, color){
    
    this.UID = vxl.util.generateUID();
    this.mesh  = mesh;
    this.index = index;
    this.vertices = vertices;
    this.color = color==undefined?[0.8,0.8,0.8]:color;
    this.normal = undefined; //cell normal
    this.position = [0,0,0];
    this._calculatePosition();
    this._calculateNormal();
    this._pickingColor  = vxl.go.picker.getColorFor(this);
};

vxlCell.prototype._calculatePosition = function(){
    this.position[0] = (this.vertices[0][0] + this.vertices[1][0] + this.vertices[2][0])/3;
    this.position[1] = (this.vertices[0][1] + this.vertices[1][1] + this.vertices[2][1])/3;
    this.position[2] = (this.vertices[0][2] + this.vertices[1][2] + this.vertices[2][2])/3;
};
    
    
/**
 * Calculates the cell normal
 * @private
 */
vxlCell.prototype._calculateNormal = function(){
    var p1 = vec3.subtract(this.vertices[1], this.vertices[0], vec3.create());
    var p2 = vec3.subtract(this.vertices[2], this.vertices[0], vec3.create());
    this.normal =  vec3.normalize(vec3.cross(p1,p2,vec3.create()));
};

/**
 * Returns an unidimensional array with the vertex information
 * [[a,b,c],[d,e,f],[g,h,i]] --> [a,b,c,d,e,f,g,h,i]
 */
vxlCell.prototype.getFlattenVertices = function(){
    var v = this.vertices;
    return [v[0][0],v[0][1],v[0][2],v[1][0],v[1][1],v[1][2],v[2][0],v[2][1],v[2][2]];
};


/**
 * Updates the cell color. 
 * @param {Object} r
 * @param {Object} g
 * @param {Object} b
 */
vxlCell.prototype.setColor = function(r,g,b){
    this.color = vxl.util.createArr3(r,g,b);
    
    this.mesh._updateCellColor(this.index);
    
}
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 

/**
 * In a mesh, the geometry is structured in units called cells (triangles).
 * This class provides operations on individual cells.
 * 
 * @class Provides cell by cell operations on models
 * @constructor 
 * @param {vxlActor} prior the model for this mesh
 * @author Diego Cantor
 */
function vxlMesh(actor){
    
    if (actor == undefined){
        throw('vxlMesh: the model passed as parameter cannot be undefined');
    }
    
    this.name = actor.name +'-mesh';
    this.cells = [];
    this.color = [0.8,0.8,0.8]; 
    this.actor = actor;
    this.model = undefined;   //internal representation of the mesh
    this._createMesh(actor);
};



/**
 * Sets the mesh color
 */
vxlMesh.prototype.setColor = function(color){
    this.color = color;
    this._setModelColor(this.color);
};

/**
 * Receives an array with vertex colors (one color per vertex) 
 * interpolates these colors and assign cell colors
 */
vxlMesh.prototype.scalarsToCellColors = function(scalars, lut){
    
};

/**
 * Update the mesh colors based on the current cell colors
 */
vxlMesh.prototype.updateColor = function(){
    var model = this.model;
    
    model.colors = [];
    model.pickingColors = [];
    for(var i=0, count = this.cells.length; i<count; i +=1){
           
            for (var j = 0; j<3;j+=1){
                model.colors.push.apply(model.colors,this.cells[i].color);
                model.pickingColors.push.apply(model.pickingColors, this.cells[i]._pickingColor);
            }
    }
    
    this.actor.updateRenderable();
};



 
/**
 * Determines if this mesh contains the cell indicated by the parameter cellUID
 * @param {String} cellUID the unique identifier of a cell
 */
vxlMesh.prototype.hasCell = function(cellUID){
  for(var i=0, count= this.cells.length; i < count; i+=1){
      if (this.cells[i].UID == cellUID){
          return true;
      }
  } 
  return false; 
};  

/**
 * Determines if this mesh contains the cell indicated by the parameter cellUID
 * @param {String} cellUID the unique identifier of a cell
 */
vxlMesh.prototype.getCell = function(cellUID){
  for(var i=0, count= this.cells.length; i < count; i+=1){
      if (this.cells[i].UID == cellUID){
          return this.cells[i];
      }
  } 
  return null; 
};

    
     

vxlMesh.prototype.removeCell = function(cellUID){
  var idx = -1;
  for(var i=0, count= this.cells.length; i < count; i+=1){
      if (this.cells[i].UID == cellUID){
          idx = i;
          break;
      }
  }
  if (idx !=-1) {
        this.cells.splice(idx,1);
        //TODO: is this efficient?
        this._createModel();
   }
   
};  

/**
 * This is just an experimental method. Determines what cells are facing the camera. 
 * May be this can be used for anything? I don't know! 
 * Maybe to see through a surface??
 *
 * @param {Object} camera
 * @param {Object} angle
 */
vxlMesh.prototype.intersect = function(camera, angle){
    
    var ray = camera._forward;
    
    selection = [];

    /*for(var i=0;i<this.normals.length; i+=1){
        var dp = Math.acos(vec3.dot(ray, this.normals[i])) * vxl.def.rad2deg;
        if (Math.abs(dp) <= angle){
            selection = selection.concat(this.indices[i]);
        }  
    }*/
    return selection;
};

/**
 * Identifies the cells existing in the 
 * @private
 */
vxlMesh.prototype._createMesh = function(actor){
    var prior = actor.model;
    var ver = prior.vertices;
    var ind = prior.indices;
    
    var self = this;
    this.cells = [];
    
    function createMeshTask(){
        var start = new Date().getTime();
        
        var cellIndex = 0;
        
        //@TODO: assign colors if they exist. Should we give the option to change luts here?
        // probably not. Every time the actor changes its LUT the mesh should react and update its colors  

        var meshColor = [self.color[0], self.color[1], self.color[2]];
        
        //1. CREATE CELLS
        for(var i=0, L = ind.length; i<L; i+=3){ 
            idx  = ind[i];
            var triangle = [],x,y,z,idx;

            x = ver[idx*3];
            y = ver[idx*3 + 1];
            z = ver[idx*3 + 2];   
            triangle.push([x,y,z]);

            idx = ind[i+1];
            x = ver[idx*3];
            y = ver[idx*3 + 1];
            z = ver[idx*3 + 2];   
            triangle.push([x,y,z]);

            idx = ind[i+2];            
            x = ver[idx*3];
            y = ver[idx*3 + 1];
            z = ver[idx*3 + 2];   
            triangle.push([x,y,z]);

            
            self.cells.push(new vxlCell(self, cellIndex, triangle, meshColor));
            cellIndex += 1;
        }
        
        
        self._createModel();
        
        var elapsed = new Date().getTime() - start;
        console.info('Mesh ['+ self.name +'] generated in '+elapsed+ ' ms');
        
    };
    
    //because this operation is time consuming it is deferred here.
    //this causes that the mesh is not available for rendering until this operation finishes.
   setTimeout(function(){createMeshTask()},0);
};


/**
 * Based on the mesh information it creates an internal model of the mesh.
 * @private
 * 
 */
vxlMesh.prototype._createModel = function(){
    
    var model = new vxlModel(this.name+'-model');
    
    model.colors = [];
    model.pickingColors = [];
    
    for(var i=0, count = this.cells.length; i<count; i +=1){
            model.indices.push.apply(model.indices,[i*3, i*3+1, i*3+2]);
            model.vertices.push.apply(model.vertices,this.cells[i].getFlattenVertices());
            
            for (var j = 0; j<3;j+=1){
                model.colors.push.apply(model.colors,this.cells[i].color);
                model.pickingColors.push.apply(model.pickingColors, this.cells[i]._pickingColor);
            }
    }
    
    model.computeNormals();
    model.setType(vxl.def.model.type.MESH);
    
    this.model = model;
    this.actor.updateRenderable(vxl.def.renderable.task.CREATE);
    
};

/**
 * @param {vec3} color the new color
 * @private
 */
vxlMesh.prototype._setModelColor = function(color){
    
    if (this.model == undefined) return;
    
    var model = this.model;
    model.colors = [];
    
    for(var i=0, count = this.cells.length; i<count; i +=1){
            this.cells[i].color = [color[0], color[1], color[2]];
            for (var j = 0; j<3;j+=1){
                model.colors.push.apply(model.colors,this.cells[i].color);
            }
    }
    
    this.actor.updateRenderable(vxl.def.renderable.task.CREATE);
};

/**
 * @private
 * @param {Object} cell the cell to be updated
 */
vxlMesh.prototype._updateCellColor = function(index){
    
    var color = this.cells[index].color;
    
    for(var i = index*9, N = index*9+9; i<N; i+=3){
        this.model.colors[i] = color[0];
        this.model.colors[i+1] = color[1];
        this.model.colors[i+2] = color[2];
    }
    
    this.actor.updateRenderable(vxl.def.renderable.task.UPDATE_COLORS);
    
};
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   


/**
 * <p>
 * An actor is a representation of a model in Voxelent. Actors can cache model properties 
 * and modified them. This is useful when there are several actors based in the same model
 * but each one of them needs to have a different version of any given model property (i.e. color)
 * </p>
 * <p> 
 * To propagate one change for all the actors based in the same model, the setProperty method
 * should be invoked by setting the third parameter (scope) like this:
 * </p>
 * 
 * <pre class="prettyprint">
 * var actor = vxl.c.scene.getActorByName('example');
 * actor.setProperty('color',[1.0,0.0,0.0], vxl.def.model)
 * </pre>
 * 
 * <p>If the change should be local (for just that actor)  then you should write:</p>
 * 
 * <pre class="prettyprint">
 * var actor = vxl.c.scene.getActorByName('example');
 * actor.setProperty('color',[1.0,0.0,0.0], vxl.def.actor)
 * </pre>
 * 
 * <p> Or simply </p>
 *  
 * <pre class="prettyprint">
 * var actor = vxl.c.scene.getActorByName('example');
 * actor.setProperty('color',[1.0,0.0,0.0])
 * </pre>
 * @class Actors represent models (assets) in a Scene
 * @constructor
 */
function vxlActor(model){
  
  this._bb = [0, 0, 0, 0, 0, 0];
  this._position 	= vec3.create([0, 0, 0]);
  this._translation = vec3.create([0, 0, 0]);
  this._centre      = vec3.create([0, 0, 0]);
  this._scale 		= vec3.create([1, 1, 1]);
  this._rotation 	= vec3.create([0, 0, 0]);
  this._matrix      = mat4.identity();
  this._renderers   = [];
  this._gl_buffers  = [];
  this._picking     = vxl.def.actor.picking.DISABLED;
  this._pickingCallback = undefined;
  this._pickingColor    = undefined; //used when the picking is vxl.def.actor.picking.OBJECT
  this._trackingCameras = [];
  
  this.UID = vxl.util.generateUID();
  this.scene        = undefined;
  this.clones       = 0;
  
  this.mode         = vxl.def.actor.mode.SOLID;
  this.cull         = vxl.def.actor.cull.NONE;
  this.visible      = true;
 
  this.mesh         = undefined;
  
  this.material     = new vxlMaterial();
  this.renderable   = undefined;
  
  if (model){
  	this.model 	    = model;
  	this.name 	    = model.name;
  	this.mode       = model.mode;
  	this._bb        = model.bb.slice(0);
  	this._centre    = vec3.set(model.centre, vec3.create());
  	this.material.getFrom(model);
  	
  	if (model.type == vxl.def.model.type.BIG_DATA){
  	    this.renderable = new vxlRenderable(this);
  	}
  }
  else{
      this.model = new vxlModel();
  }
  
  var e = vxl.events;
  vxl.go.notifier.publish(
      [
        e.ACTOR_MOVED,
        e.ACTOR_SCALED,
        e.ACTOR_ROTATED,
        e.ACTOR_CHANGED_COLOR,
        e.ACTOR_CHANGED_SHADING,
      ], this);
};


/**
 *Sets the scene the actor belongs to. Used to notifiy the scene
 * about changes in actor properties 
 */
vxlActor.prototype.setScene = function(scene){
    this.scene = scene;
}


/**
 * Sets the position of this actor. 
 * 
 * 
 * @param {Number, Array, vec3} x it can be the x coordinate, a 3-dimensional Array or a vec3 (glMatrix)
 * @param {Number} y if x is a number, then this parameter corresponds to the y-coordinate
 * @param {Number} z if x is a number, then this parameter corresponds to the z-coordinate
 */
vxlActor.prototype.setPosition = function (x,y,z){
    var np = vxl.util.createVec3(x,y,z);
    vec3.subtract(np, this._position, this._translation);
    this._position = np;  
    
    var m = this._matrix;
    m[12] = this._position[0];
    m[13] = this._position[1];
    m[14] = this._position[2];
    m[15] = 1;
    this._computeBoundingBox();
    this._notifyTrackingCameras();
    vxl.go.notifier.fire(vxl.events.ACTOR_MOVED, this);
    
    return this;
};


/**
 * Translates the actor by a given vector 
 * 
 * @param {Number, Array, vec3} x it can be the x coordinate, a 3-dimensional Array or a vec3 (glMatrix)
 * @param {Number} y if x is a number, then this parameter corresponds to the y-coordinate
 * @param {Number} z if x is a number, then this parameter corresponds to the z-coordinate
 */
vxlActor.prototype.translate = function (x,y,z){
    this._translation = vxl.util.createVec3(x,y,z); 
    
    var m = this._matrix;
    mat4.translate(m,this._translation);
    this._position = vec3.createFrom(m[12], m[13], m[14]);
    this._computeBoundingBox();
    this._notifyTrackingCameras();
    vxl.go.notifier.fire(vxl.events.ACTOR_MOVED, this);
    
    return this;
};


/**
 * Rotates the actor on the X axis 
 * 
 * @param {Number} angle the angle
 */ 
vxlActor.prototype.rotateX = function (angle){
    var m = this._matrix;
    var a = vxl.util.deg2rad(vxl.util.getAngle(angle));
    mat4.rotateX(m,a);
    this._computeBoundingBox();
    vxl.go.notifier.fire(vxl.events.ACTOR_ROTATED, this);
    
    return this;
};

/**
 * Rotates the actor on the Y axis 
 * 
 * @param {Number} angle the angle
 */
vxlActor.prototype.rotateY = function (angle){
    var m = this._matrix;
    var a = vxl.util.deg2rad(vxl.util.getAngle(angle));
    mat4.rotateY(m,a);
    this._computeBoundingBox();
    vxl.go.notifier.fire(vxl.events.ACTOR_ROTATED, this);
    
    return this;
};


/**
 * Rotates the actor on the Z axis 
 * 
 * @param {Number} angle the angle
 */
vxlActor.prototype.rotateZ = function (angle){
    var m = this._matrix;
    var a = vxl.util.deg2rad(vxl.util.getAngle(angle));
    mat4.rotateZ(m,a);
    this._computeBoundingBox();
    vxl.go.notifier.fire(vxl.events.ACTOR_ROTATED, this);
    
    return this;
};

/**
 * Scales this actor. 
 * @param {Number, Array, vec3} s the scaling factor. The scaling factor is applied in all axes.
 *
 */
vxlActor.prototype.setScale = function(s,a,b){
    if (s == 0 && a == undefined && b==undefined) return;
    
    
    if (typeof(s)=="number" && a == undefined && b == undefined){
        this._scale = vxl.util.createVec3(s,s,s);
    }
    else{
        this._scale = vxl.util.createVec3(s,a,b);
    }
    
    var m = this._matrix;
    mat4.scale(m,this._scale);
    this._computeBoundingBox();
    vxl.go.notifier.fire(vxl.events.ACTOR_SCALED, this);
    
    return this;
};

/**
 * Adds a tracking camera
 * 
 * @param{vxlCamera} camera the tracking camera
 */
vxlActor.prototype.addTrackingCamera = function(camera){
    if (camera instanceof vxlCamera && camera.type !=vxl.def.camera.type.TRACKING){
        throw "vxlActor._addTrackingCamera ERROR: the selected camera is not set to tracking"
    }
    else if (camera instanceof vxlCamera){
        this._trackingCameras.push(camera);
    }
    else{
        throw "vxlActor._addTrackingCamera ERROR: the object passed as a parameter is not a vxlCamera"
    }
};

/**
 * Removes a tracking camera
 * @param{vxlCamera} camera the tracknig camera
 */
vxlActor.prototype.removeTrackingCamera = function(camera){
    var idx = this._trackingCameras.indexOf(camera);
    this._trackingCameras.splice(idx,1);
};

/**
 * Notifies all the tracking cameras of the actor translation 
 * @param {Object} camera
 */
vxlActor.prototype._notifyTrackingCameras = function(){
    for (var i=0, N = this._trackingCameras.length; i<N;i+=1){
        this._trackingCameras[i].updateWithActor(this);
    }
};

/**
 * Computes the current bounding box for this actor.
 * This method is called on demand by the scene or any other object. 
 * The bounding box is NOT automatically recalculated when 
 * moving or scaling an actor for performance reasons.
 *  
 */
vxlActor.prototype._computeBoundingBox = function(){

    var vs  = this.model.vertices;
    var vsT = [];
    var T = this._matrix;
    
    for(var i=0;i<vs.length;i=i+3){
        var x = vxl.util.createVec3(vs[i],vs[i+1],vs[i+2]);
        mat4.multiplyVec3(T, x);
        vsT.push(x[0], x[1], x[2]);    
    }
    
    var bbA = [vsT[0],vsT[1],vsT[2],vsT[0],vsT[1],vsT[2]];
    
    for(var i=0;i<vsT.length;i=i+3){
        bbA[0] = Math.min(bbA[0],vsT[i]);
        bbA[1] = Math.min(bbA[1],vsT[i+1]);
        bbA[2] = Math.min(bbA[2],vsT[i+2]);
        bbA[3] = Math.max(bbA[3],vsT[i]);
        bbA[4] = Math.max(bbA[4],vsT[i+1]);
        bbA[5] = Math.max(bbA[5],vsT[i+2]);
    }
    
     
    this._bb = bbA;
};

/**
 * Returns an array with the bounding box vertices. Good for rendering the transformed
 * bounding box (after geometric transformations) 
 * @returns {Array} a 8-element array with the vertices that constitute the actor bounding box
 */
vxlActor.prototype.getBoundingBoxVertices = function(){
    var b = this._bb; 
    return [
        b[0], b[1], b[2],
        b[0], b[4], b[2],
        b[3], b[4], b[2],
        b[3], b[1], b[2],
        b[0], b[1], b[5],
        b[0], b[4], b[5],
        b[3], b[4], b[5],
        b[3], b[1], b[5] 
        ];
};


/**
 * Returns the bounding box for this actor. The actor's bounding box observes any geometric
 * transformation suffered by the actor. Therefore it is ideal to do collision detection.
 * 
 * The format of the returned bounding box is [x-min, y-min, z-min, x-ax, y-max, z-max]
 * @returns {Array} the current bounding box.
 */
vxlActor.prototype.getBoundingBox = function(){
    return this._bb.slice[0];
}


/**
 * Returns the height for the current actor. 
 * @returns {Number} the current height
 */
vxlActor.prototype.getHeight = function(){
   var bb = this._bb
   return bb[4]-bb[1]
};


/**
* Sets the actor color. This color can be different from the original model color
* @param {Number, Array, vec3} r it can be the red component, a 3-dimensional Array or a vec3 (glMatrix)
* @param {Number} g if r is a number, then this parameter corresponds to the green component
* @param {Number} b if r is a number, then this parameter corresponds to the blue component
*/
vxlActor.prototype.setColor = function (r,g,b){
	this.material.diffuse = vxl.util.createVec3(r,g,b);
	if (this.mesh){
	    this.mesh.setColor(this.material.diffuse);
	} 
	vxl.go.notifier.fire(vxl.events.ACTOR_CHANGED_COLOR, this);
	
	return this;
};



/**
 * Sets the opacity of this actor. 
 * @param {Number} o a float value between 0 and 1. 
 */
vxlActor.prototype.setOpacity = function(o){
	if (o>=0 && o<=1){
		this.material.opacity = o;
	} 
	else throw 'The opacity value is not valid';
	
	return this;
};


/**
 * Sets the shininess of this actor 
 * @param {Number} s a value for the shininess 
 */
vxlActor.prototype.setShininess = function(s){
    this.material.shininess = s;
    
    return this;
};

/**
 * Associates a new texture with this actor
 * @param {String} uri the location of the texture to load 
 */
vxlActor.prototype.setTexture = function(uri){
    this.material.texture = new vxlTexture(uri);  
    this.dirty = true; //reallocation required
    return this;  
}

/**
 * If the property exists, then it updates it
 * @param {String} property name of the property 
 * @param {Object} value  value to be set
 * @param {String} scope indicates if the change is made at the actor level or at the model level
 * valid values for scope are vxl.def.model and vxl.def.actor
 * @TODO: if the property is position or scale then call the respective methods from here
 */
vxlActor.prototype.setProperty = function(property, value, scope){
    
    
    if (scope == vxl.def.actor || scope == undefined || scope == null){

        switch (property){
            case 'position': this.setPosition(value);  break;
            case 'scale':    this.setScale(value);     break;
            case 'color':    this.setColor(value);     break;
            case 'shading':  this.setShading(value);   break;
            case 'texture':  this.setTexture(value);   break;
            case 'opacity':  this.setOpacity(value);   break;
            case 'shininess':this.setShininess(value); break;
            default: this[property] = value; break;
        }
  
		vxl.go.console('Actor: The actor '+this.name+' has been updated. ['+property+' = '+value+']');
	}
	else if(scope == vxl.def.model){
		this.model[property] = value;
		vxl.go.console('vxlActor: The model '+this.model.namname+' has been updated. ['+property+' = '+value+']');
	}
	else{
		throw('vxlActor.setProperty. Scope:' + scope +' is not valid');
	}
	
	return this;
	
};

/**
 * Enables or disables the calculation of the shading. Any shader should take into account this 
 * actor property to decide how to render it.
 * 
 * @param {Boolean} flag can be true or false
 */
vxlActor.prototype.setShading = function(flag){
    this.material.shading = flag;
    vxl.go.notifier.fire(vxl.events.ACTOR_CHANGED_SHADING, this);
    return this;
};

/**
 * Returns an actor property if that property exists in the actor. Otherwise it will search 
 * in the model. This method is used by the renderer. There are some cases where actors have local changes
 * that are not reflected in the model. In these cases the renderer should pick the actor property
 * over the model property
 * @param {String} property the property name
 * @returns {Object} the property or undefined if the property is not found 
 */
vxlActor.prototype.getProperty = function(property){
    
    if (property == 'color'){
        return this.materia.diffuse; //there's no real 'color' property.
    }
	else if (this.hasOwnProperty(property)) {
		return this[property];
	}
	else if (this.material.hasOwnProperty(property)){
	   return this.material[property];   
	}
	else if (this.model.hasOwnProperty(property)){
		return this.model[property];
	}
	else {
		return undefined;
	}
};

/**
 * Estimates the current position as
 * the center of the current bounding box. 
 * This method does not update the internal position of the actor
 * it only returns an estimate based on the location of its bounding box.
 */
vxlActor.prototype.computePosition = function(){
	bb = this._bb;
	var cc = this._position;
	
	cc[0] = (bb[3] + bb[0]) /2;
	cc[1] = (bb[4] + bb[1]) /2;
	cc[2] = (bb[5] + bb[2]) /2;
		
	cc[0] = Math.round(cc[0]*1000)/1000;
	cc[1] = Math.round(cc[1]*1000)/1000;
	cc[2] = Math.round(cc[2]*1000)/1000;
	
	return vec3.create(cc); 
};


/**
* Sets the visualization mode for this actor.
* @param {vxl.def.actor.mode} mode mode needs to be one of the elements defined in vxl.def.actor.mode
* @TODO: VALIDATE
*/
vxlActor.prototype.setVisualizationMode = function(mode){
	this.mode = mode;
	
	return this;
};

/**
 *Sets the culling mode for this actor.
 * @param {vxl.def.actor.cull} face face needs to be one of the elements defined in vxl.def.actor.cull
 *  @TODO: VALIDATE
 */
vxlActor.prototype.cullFace = function(face){
    this.cull = face;
    
    return this;
};


/**
* Sets the lookup table for this actor.
* This method will only succeed if the model that this actor represents has scalars 
* @param {String} lutID the lookup table id. See {@link vxl.def.lut} for currently supported ids.
* @param {Number} min lowest value for interpolation
* @param {Number} max highest value for interpolation
*/
vxlActor.prototype.setLookupTable = function(lutID,min,max){
	
	if (this.model.scalars == undefined) return;
	
	var self = this;
	
	function scheduledSetLookupTable(scalars){
        var lut = vxl.go.lookupTableManager.get(lutID);
        self.material.colors  = lut.getColors(self.model.scalars,min,max);
        
        //if(this.mesh){
        //    this.mesh. //update mesh with vertex colors it may require access to the original index array
       // }
       
       if (self.model.type == vxl.def.model.type.BIG_DATA){
           self.renderable.update();
       }
	}
	
	//Given that obtaining the colors can be a time consume op, it is deferred here.
	setTimeout(function(){scheduledSetLookupTable()},0);
	
	return this; 
};

/**
* Flips the normal for this actor. It delegates the task to the model
* @TODO: Review. we could want the actor to have flipped normals but not to impose this on the model. 
*/
vxlActor.prototype.flipNormals = function(){
	this.model.flipNormals();
	
	return this;
};

/**
* Sets the visibility of the actor
* @param {boolean} flag true or false
*/
vxlActor.prototype.setVisible = function(flag){
    this.visible = flag;
    
    return this;
};

/**
* Is visible?
* @returns {boolean} true if the object is visible
*/
vxlActor.prototype.isVisible = function(){
    return this.visible;
};

/**
 * Duplicates this actor.
 * 
 * Properties copied by REFERENCE:
 * model,
 * buffers,
 * renderers
 * 
 * Everything else is copied by VALUE.
 * 
 * This method is fundamental to replicate objects in the scene, without having to duplicate
 * the shared model. A cloned actor however can have different position, colors, properties, etc.
 * 
 * If a cloned actor modifies his internal model, any other actor that shares the model will be
 * affected. 
 * 
 * The returned actor is not added to the scene automatically. It is up the
 * programmer to determine the scene the cloned actor needs to be added to if any.
 * 
 * @see vxlModel
 * @returns {vxlActor} an actor 
 */
vxlActor.prototype.clone = function(){
    this.clones++;
	
	var duplicate = new vxlActor(this.model);
	duplicate.setScene(this.scene);
	
	//TODO: duplicate.setMatrix(this._matrix); this method should update all the other variables (position, scale, rot, etc).
     	
	//Now to save us some memory, let's SHARE the WebGL buffers that the current actor has already allocated'
	//duplicate.renderers = this._renderers;
	//duplicate.buffers   = this._gl_buffers;

	duplicate.name     += '-'+this.clones; 
	return duplicate;
};

/**
 * 
 * @param {String} type one of the possible values for vxl.def.actor.picking
 * @param {Object} callback a function that is invoked when a picking event occurs. This parameter is 
 * required if the type (first argument) is different from vxl.def.actor.picking.DISABLED 
 * the callback receives an actor object to operate over it.
 */
vxlActor.prototype.setPicker = function(type, callback){
    this._picking = type;
    
    switch(type){
        case vxl.def.actor.picking.DISABLED: 
            this._pickingCallback = undefined;
            this.mesh = undefined;
            this.renderable = undefined;
            this.setVisualizationMode(vxl.def.actor.mode.SOLID); 
            break;
        
        case vxl.def.actor.picking.CELL: 
            
            if (this.mesh == undefined){
                this.mesh = new vxlMesh(this); 
                this.mesh.setColor(this.material.diffuse);
                this.renderable = new vxlRenderable(this);
                this.setVisualizationMode(vxl.def.actor.mode.FLAT);           
            };
            
            this._pickingCallback = callback;
             
            break;
        case vxl.def.actor.picking.OBJECT:
            this._pickingColor = vxl.go.picker.getColorFor(this);
            this._pickingCallback = callback;
            break;
    }
    
    if (this.isPickable()){
        for(var i=0, N = this.scene.views.length; i<N; i+=1){
            var r = this.scene.views[i].renderer;
            if(!r.isOffscreenEnabled()){
                r.enableOffscreen();
            }
        }
    }
    //@TODO: Disable when there are no pickable actors in the scene.
    
    return this;
};

/**
 * Reports if the current actor is pickable or not
 *   
 */
vxlActor.prototype.isPickable = function(){
    return (this._picking  != vxl.def.actor.picking.DISABLED);  
};

/**
 * Returns the picking type 
 */
vxlActor.prototype.getPickingType = function(){
    return this._picking;  
};

/**
 * 
 */
vxlActor.prototype.getRenderableModel = function(){
    if (this.mesh && this.mesh.model){
        return this.mesh.model;
    }
    else if (this.model.type == vxl.def.model.type.BIG_DATA){
        return this.model;
    }
    else return undefined;
    
};

/**
 * @param {String} task type of update
 */
vxlActor.prototype.updateRenderable = function(task){
    this.renderable.update(task);
}
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 

/**
 * @constructor
 * @class 
 * Picking in voxelent is based on colors. The vxlPicker class keeps track of the colors
 * in the scene that are used to identify objects and cells. The picker contains a map
 * that allows recognizing an object given a color.
 * @author Diego Cantor
 */
function vxlPicker(){
    this._map = {};
    
    this._hmap = [];
    
    for (var i=0;i<=256; i+=1){
        this._hmap[i] = [];
        for(var j=0;j<=256; j+=1){
            this._hmap[i][j] = [];
            for(var k=0;k<=256; k+=1){
                this._hmap[i][j][k] = null;
                }
        }
    }
    
 
};

/**
 * @static 
 */
vxlPicker.RESOLUTION = 1/255; // 1 / (2^8-1) for unsigned byte according to WebGL reference

/**
 * Generates a color that has not been assigned to any object or cell in the scene
 */
vxlPicker.prototype._getColor = function(){
    
    function getN(){
        var x =  Math.floor(Math.random()*255);
        if (x == 0) 
            return getN();
        else
            return x;
    };
   return [getN(), getN(), getN()];
};
  
/**
 * 
 */
vxlPicker.prototype.color2decimal = function(color){
    r = color[0] * vxlPicker.RESOLUTION;
    g = color[1] * vxlPicker.RESOLUTION;
    b = color[2] * vxlPicker.RESOLUTION;
    return [r,g,b];
}  


/**
 * @param {Object} obj an object that can be either a vxlCell or a vxlActor
 */
vxlPicker.prototype.getColorFor = function(obj){
    
    var uid = obj.UID;
    
    if (uid == null || uid  == undefined){
        alert("vxlPicker.getColor: invalid object");
        return;
    }
    
    if(!this._map[uid]){
        
        var color; 
        do{
            color = this._getColor();
        } while(this._hmap[color[0]][color[1]][color[2]] != null);

        this._map[uid] =  color;
        this._hmap[color[0]][color[1]][color[2]] = uid;
    }
    return this.color2decimal(color);
};

/**
 * Checks if the color passed as a parameter correspond to any UID (object,cell) assigned in the picker
 * If so, it returns an object with the results
 * If not, it returns null indicating the query was unsuccessful.
 * @param {Array} color
 * 
 */
vxlPicker.prototype.query = function(color){
    
    var distance = 100;
    var closest_uid = undefined;
    var results = {}
    
    if (this._hmap[color[0]][color[1]][color[2]] != null){
        results.uid = this._hmap[color[0]][color[1]][color[2]];
        results.color = color;
        return results;
    }
    return null;
};

/**
 * Defines a global picker 
 */
vxl.go.picker = new vxlPicker();

/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 

/**
 * Engine interface
 */
function vxlEngine(){
    
};

vxlEngine.prototype = {
    
    allocate   : function(scene){},
    render     : function(scene){},
    deallocate : function(scene){}
};
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 

vxlExternalEngine.prototype = new vxlEngine();
vxlExternalEngine.prototype.constructor = vxlExternalEngine;
/**
 * 
 * @param {Object} allocate
 * @param {Object} render
 * @param {Object} deallocate
 */
function vxlExternalEngine(renderer, allocate, render, deallocate){
    this.renderer = renderer;
    this.allocateCallback = allocate;
    this.renderCallback = render;
    this.deallocateCallback = deallocate;
}


vxlExternalEngine.prototype.allocate = function(scene){
    this.allocateCallback(this.renderer, scene);
};


vxlExternalEngine.prototype.render = function(scene){
    this.renderCallback(this.renderer, scene);  
};

vxlExternalEngine.prototype.deallocate = function(scene){
    this.deallocateCallback(this.renderer, scene);  
};
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 

/**
 * @constructor
 * @class
 * Implements the default rendering strategy 
 * 
 * 
 * A vxlRenderEngine object is selected by default as the strategy that an actor
 * will use for rendering.
 * 
 * A rendering strategy allows decoupling rendering specific code (i.e. code that access and 
 * 	communicates with the program) from the actor.
 * @author Diego Cantor
 * 
 */
function vxlRenderEngine(renderer){
	this.renderer = renderer;
	this._gl_buffers  = {};
	this._gl_textures = {};
	this._offscreen = false;
    this._target    = undefined;
    this._onPickingBuffer  = false;
    this._debug_picking_flag = false; //used only for debuggin purposes
	
	if (renderer){
	var gl = this.renderer.gl;
	
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LESS);
	gl.clearDepth(1.0);
	gl.disable(gl.CULL_FACE);
    }	
}

/**
 * Implements basic allocation of memory. Creates the WebGL buffers for the actor
 * @param {vxlScene} scene the scene to allocate memory for
  */
vxlRenderEngine.prototype.allocate = function(scene){
    var elements = scene._actors.concat(scene.toys.list);
    var i = elements.length;
    
    while(i--){
        this._allocateActor(elements[i]);
    }
};

/**
 * @param {vxlScene} scene the scene to deallocate memory from
 */
vxlRenderEngine.prototype.deallocate = function(scene){
    //DO NOTHING. THE DESCENDANTS WILL.
};

/**
 * Receives one actor and returns the GL buffers
 */
vxlRenderEngine.prototype._allocateActor = function(actor){
   
    if (this._gl_buffers[actor.UID] != undefined){
        if (actor.dirty){ //@TODO: hmmmm frowning on dirty property this is a hack
            this._reallocateActor(actor); 
        }
        return;
    }
   	
	var gl = this.renderer.gl;
	var model = actor.model;
    var buffers = {};
	
	//Vertex Buffer
	buffers.vertex = gl.createBuffer();
	
	
	//Index Buffer
	if (model.indices != undefined){
		buffers.index = gl.createBuffer();
	}
	
	//Normals Buffer
	if (model.normals){
		buffers.normal = gl.createBuffer();
	}
	
	//Color Buffer for scalars
	if (model.scalars != undefined || model.colors != undefined){
		buffers.colors = gl.createBuffer(); //we don't BIND values or use the buffers until the lut is loaded and available
	}
	
	//Wireframe Buffer 
	if (model.wireframe != undefined){
		buffers.wireframe = gl.createBuffer();
	}
	
	//Bounding box Buffer 
    buffers.bb = gl.createBuffer();
	
	//Texture Coords Buffer
	if (model.texcoords){
	    buffers.texcoords = gl.createBuffer();
	}
	   
    //Cleaning up
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	
	
	this._gl_buffers[actor.UID] = buffers;
	this._reallocateActor(actor);
};


/**
 * Receives one actor and returns the GL buffers
 */
vxlRenderEngine.prototype._reallocateActor = function(actor){
   
    var gl = this.renderer.gl;
    var model = actor.model;
    var buffers = this._gl_buffers[actor.UID];
    
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.vertices), gl.STATIC_DRAW);
    
    //Index Buffer
    if (model.indices != undefined){    
  
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(model.indices), gl.STATIC_DRAW);
    }
    
    //Normals Buffer
    if (model.normals){
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.normals), gl.STATIC_DRAW);
    }
    
    //Color Buffer for scalars
    if (model.scalars != undefined || model.colors != undefined){
        buffers.colors = gl.createBuffer(); //we don't BIND values or use the buffers until the lut is loaded and available
    }
    
    //Wireframe Buffer 
    if (model.wireframe != undefined){
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.wireframe);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(model.wireframe), gl.STATIC_DRAW);
    }   
    //Cleaning up
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    
    //Bounding box Buffer 
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.bb);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vxlModel.BB_INDICES), gl.STATIC_DRAW);
    
    
    //Texture Coords Buffer
    if (model.texcoords && actor.material.texture && actor.material.texture.loaded){
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.texcoords);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.texcoords), gl.STATIC_DRAW);
        
        this._gl_textures[actor.UID] = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this._gl_textures[actor.UID]);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, actor.material.texture.image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    
    
    //Cleaning up
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
};
/**
 * Passes the matrices to the shading program
 * @param {vxlActor} the actor 
 * we will update each Model-View matrix of each renderer according to
 * the actor position,scale and rotation.
 * @private
 */
vxlRenderEngine.prototype._applyActorTransform = function(actor){
    
    var r		= this.renderer;
    var trx 	= r.transforms
    var	pm 	= r.pm;
    var essl 	= vxl.def.essl;

    trx.push();
        mat4.multiply(trx.mvMatrix, actor._matrix);
	    pm.setUniform(essl.MODEL_VIEW_MATRIX,	r.transforms.mvMatrix);

	    trx.calculateModelViewPerspective();
        pm.setUniform(essl.MVP_MATRIX, r.transforms.mvpMatrix);
        
        trx.calculateNormal(); 
        pm.setUniform(essl.NORMAL_MATRIX, r.transforms.nMatrix);
    
    trx.pop();
 };
 
 
 /**
 * Passes the matrices to the shading program
 * @param {vxlActor} the actor 
 * we will update each Model-View matrix of each renderer according to
 * the actor position,scale and rotation.
 * @private
 */
vxlRenderEngine.prototype._applyGlobalTransform = function(){
    
    var r       = this.renderer;
    var trx     = r.transforms
    var pm     = r.pm;
    var essl    = vxl.def.essl;

    pm.setUniform(essl.MODEL_VIEW_MATRIX,  r.transforms.mvMatrix);
    trx.calculateModelViewPerspective();
    pm.setUniform(essl.MVP_MATRIX, r.transforms.mvpMatrix);
    trx.calculateNormal(); 
    pm.setUniform(essl.NORMAL_MATRIX, r.transforms.nMatrix);
    
 };
 
 
 /**
 * Renders the actors one by one
 * @param {vxlScene} scene the scene to render
 */
vxlRenderEngine.prototype.render = function(scene){

    //Updates the perspective matrix and passes it to the program
    var r       = this.renderer,
    trx     = r.transforms,
    pm     = r.pm,
    glsl    = vxl.def.essl,
    gl      = r.gl;
    
    trx.calculatePerspective();
    trx.calculateModelView();
    
    
    var elements = scene._actors.concat(scene.toys.list);
   
    //is this supposed to be here?
    //----------------------------------------------------//
    if (scene.frameAnimation != undefined){
        scene.frameAnimation.update();
    }
    //----------------------------------------------------//
    
    this._handlePicking(scene._actors);
    
    if (this._debug_picking_flag){
        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };
    
    var i = elements.length;
    while(i--){
        this._renderActor(elements[i]);
    }
};

/**
 * @private
 */
vxlRenderEngine.prototype._handlePicking = function(actors){
    
    if (this._target == undefined) return; //quick fail if the target has not been defined
    
    if (this._offscreen){
        
        var gl = this.renderer.gl;
        
        this._onPickingBuffer = true;
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._target.framebuffer);
        
        
        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        var i = actors.length;
        while(i--){
            if (actors[i].isPickable()){
                this._renderActor(actors[i]);
            }
        }
        
        this._onPickingBuffer = false;
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        
    }
};

/**
 * @private
 */
vxlRenderEngine.prototype._enablePartVertices = function(actor,part){
    
    var gl = this.renderer.gl;
    var pm = this.renderer.pm;
    var buffers = this._gl_buffers[actor.UID];
    var essl    = vxl.def.essl; 
                
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(part.vertices), gl.STATIC_DRAW);
    pm.setAttributePointer(essl.VERTEX_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0); 
};

/**
 * @private
 */
vxlRenderEngine.prototype._enablePartNormals = function(actor,part){
    
  var gl = this.renderer.gl;
  var pm = this.renderer.pm;
  var buffers = this._gl_buffers[actor.UID];
  var essl    = vxl.def.essl; 
  
  if (part.normals != undefined && part.normals.length>0){
        try{
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(part.normals), gl.STATIC_DRAW);
            
            pm.enableAttribute(essl.NORMAL_ATTRIBUTE);
            pm.setAttributePointer(essl.NORMAL_ATTRIBUTE,3,gl.FLOAT, false, 0,0);
            
        }
        catch(err){
            alert('There was a problem while rendering a BIG DATA part ['+part.name+']. The problem happened while handling the normal buffer. Error =' +err.description);
            throw('There was a problem while rendering a BIG DATA part ['+part.name+']. The problem happened while handling the normal buffer. Error =' +err.description);
        }
  }
    
};

/**
 * @private
 */
vxlRenderEngine.prototype._enablePartColors = function(actor,part){
    
  var gl = this.renderer.gl;
  var pm = this.renderer.pm;
  var buffers = this._gl_buffers[actor.UID];
  var essl    = vxl.def.essl; 
  
  if (part.colors != undefined && part.colors.length>0){
      try{
            pm.setUniform("uUseVertexColors", true);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.colors);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(part.colors), gl.STATIC_DRAW);
        
            pm.enableAttribute(essl.COLOR_ATTRIBUTE);
            pm.setAttributePointer(essl.COLOR_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
          
        }
        catch(err){
            alert('There was a problem while rendering a BIG DATA part ['+part.name+']. The problem happened while handling the color buffer. Error =' +err.description);
            throw('There was a problem while rendering a BIG DATA part ['+part.name+']. The problem happened while handling the color buffer. Error =' +err.description);
        }
    
    }  
};

/**
 * @private
 */
vxlRenderEngine.prototype._enableNormals = function(actor){
    
    var model = actor.model;
    var gl = this.renderer.gl;
    var pm = this.renderer.pm;
    var buffers = this._gl_buffers[actor.UID];
    var essl    = vxl.def.essl; 
    
    if(model.normals && actor.material.shading){
        try{
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.normals), gl.STATIC_DRAW);
            
            pm.enableAttribute(essl.NORMAL_ATTRIBUTE);
            pm.setAttributePointer(essl.NORMAL_ATTRIBUTE,3,gl.FLOAT, false, 0,0);
            
        }
        catch(err){
            alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the normal buffer. Error =' +err.description);
            throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the normal buffer. Error =' +err.description);
        }
    }
}; 

/**
 * @private
 */
vxlRenderEngine.prototype._enableColors = function(actor){
    
    var model = actor.model;
    var gl = this.renderer.gl;
    var pm = this.renderer.pm;
    var buffers = this._gl_buffers[actor.UID];
    var essl    = vxl.def.essl; 
    
    if (actor.material.colors && actor.material.colors.length == actor.model.vertices.length){    
        try{
            pm.setUniform("uUseVertexColors", true);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.colors);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(actor.material.colors), gl.STATIC_DRAW);
            
            pm.enableAttribute(essl.COLOR_ATTRIBUTE);
            pm.setAttributePointer(essl.COLOR_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
        }
        catch(err){
            alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the color buffer. Error =' +err.description);
            throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the color buffer. Error =' +err.description);
        }
    }
};

/**
 * Renders a solid actor
 * @private
 */
vxlRenderEngine.prototype._renderSolid = function(actor){
    
    var buffers = this._gl_buffers[actor.UID];
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl;
    
    if (actor.model.type != vxl.def.model.type.SIMPLE){
        
        if (actor.renderable  == undefined){
            alert('the actor does not have a renderable object');
            throw 'the actor does not have a renderable object';
        }
        
        parts = actor.renderable.parts;
        var i = parts.length;
        while(i--){
             var part = parts[i];
             try{
                 
                this._enablePartVertices(actor,part)
                this._enablePartColors(actor,part);
                this._enablePartNormals(actor,part);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(part.indices), gl.STATIC_DRAW);
                gl.drawElements(gl.TRIANGLES, part.indices.length, gl.UNSIGNED_SHORT,0);
            }
            catch(err){
                alert('Error rendering BIG DATA: There was a problem while rendering the part ['+part.name+']. ' +err.description);
                throw('Error rendering BIG DATA: There was a problem while rendering the part ['+part.name+']. ' +err.description);
            }
        }
    }
    else{
    
        this._enableNormals(actor);
        this._enableColors(actor);    
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(actor.model.indices), gl.STATIC_DRAW);
        gl.drawElements(gl.TRIANGLES, actor.model.indices.length, gl.UNSIGNED_SHORT,0);
    }
};

/**
 * Renders an actor as a wireframe
 */
vxlRenderEngine.prototype._renderWireframe = function(actor){
    

    var buffers = this._gl_buffers[actor.UID];
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl;
    
    if (!actor.toy){
        this._enableNormals(actor);
    }
    this._enableColors(actor);
    
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.wireframe);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(actor.model.wireframe), gl.STATIC_DRAW);
    gl.drawElements(gl.LINES, actor.model.wireframe.length, gl.UNSIGNED_SHORT,0);
};

/**
 * @private
 */
vxlRenderEngine.prototype._renderPoints = function(actor){
    
    var model   = actor.model;
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl; 
    
    pm.setUniform("uUseShading", false);
    
    pm.setUniform("uPointSize", 5);//TODO: this can be an actor property?
    this._enableColors(actor);
    gl.drawArrays(gl.POINTS,0, model.vertices.length/3);
};

/**
 * @private
 */
vxlRenderEngine.prototype._renderLines = function(actor){
    
    var buffers = this._gl_buffers[actor.UID];
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl;
    
    pm.setUniform("uUseShading", false);
     gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(actor.model.vertices), gl.STATIC_DRAW);
    pm.setAttributePointer(essl.VERTEX_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
    this._enableColors(actor);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(actor.model.indices), gl.STATIC_DRAW);
    gl.drawElements(gl.LINES, actor.model.indices.length, gl.UNSIGNED_SHORT,0); 
};

/**
 * @private
 */
vxlRenderEngine.prototype._renderBoundingBox = function(actor){
    
    var buffers = this._gl_buffers[actor.UID];
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl; 
    
    pm.disableAttribute(essl.NORMAL_ATTRIBUTE);
    pm.setUniform("uUseShading", false);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(actor.getBoundingBoxVertices()), gl.STATIC_DRAW);
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.bb);
    gl.drawElements(gl.LINES, vxlModel.BB_INDICES.length, gl.UNSIGNED_SHORT,0);
};

/**
 * @private
 */
vxlRenderEngine.prototype._renderBoundingBoxAndSolid = function(actor){    var model   = actor.model;
    
    var buffers = this._gl_buffers[actor.UID];
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl;
    
    //solid
    this._renderSolid(actor);
    
    //bounding box, don't move the bb as it has been updated with the actor transform already ;-)
    this._applyGlobalTransform();
    
    pm.disableAttribute(essl.NORMAL_ATTRIBUTE);
    pm.setUniform("uUseShading", false);
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
    //@TODO: Review, should we be asking an actor for renderable vertices?
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(actor.getBoundingBoxVertices()), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.bb);
    gl.drawElements(gl.LINES, vxlModel.BB_INDICES.length, gl.UNSIGNED_SHORT,0);
    
};

/**
 * @private
 */
vxlRenderEngine.prototype._renderWiredAndSolid = function(actor){
   
    var model   = actor.model;
    var buffers = this._gl_buffers[actor.UID];
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl;
    
    
    this._renderSolid(actor);
    
    pm.setUniform("uUseShading",false);
    pm.setUniform("uMaterialDiffuse",[0.9,0.9,0.9,1.0]);
    pm.disableAttribute(essl.NORMAL_ATTRIBUTE);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.wireframe);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(model.wireframe), gl.STATIC_DRAW);
    gl.drawElements(gl.LINES, model.wireframe.length, gl.UNSIGNED_SHORT,0); 
};

/**
 * This method will create a mesh for the actor if it does not exist one already
 * Instead of waiting for the mesh to be ready, it will render a wireframe
 * of the actor while it is ready.
 * 
 * @private
 */
vxlRenderEngine.prototype._renderFlat = function(actor){
    
   
    var buffers = this._gl_buffers[actor.UID];
    var texture = this._gl_textures[actor.UID]; 
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl;
    
    if (actor.mesh == undefined){
        actor.mesh = new vxlMesh(actor);
        actor.renderable = new vxlRenderable(actor);
        
    }
    
    if (actor.mesh.model == undefined) {
        //mesh not ready yet. Render actor wireframe in the mean time
        var model = actor.model;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.vertices.slice(0)), gl.STATIC_DRAW);
        pm.setAttributePointer(essl.VERTEX_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.normals), gl.STATIC_DRAW);
        pm.setUniform("uUseShading",actor.material.shading);
        pm.enableAttribute(essl.NORMAL_ATTRIBUTE);
        pm.setAttributePointer(essl.NORMAL_ATTRIBUTE,3,gl.FLOAT, false, 0,0);
        this._renderWireframe(actor);
        return;
    } 

    pm.setUniform("uUseShading",true);

    var parts = actor.renderable.parts;
    var i = parts.length;
    while(i--){
        
        var part = parts[i];
    
        try{
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(part.normals), gl.STATIC_DRAW);
                
                pm.enableAttribute(essl.NORMAL_ATTRIBUTE);
                pm.setAttributePointer(essl.NORMAL_ATTRIBUTE,3,gl.FLOAT, false, 0,0);
                
            }
            catch(err){
                alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the normal buffer. Error =' +err.description);
                throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the normal buffer. Error =' +err.description);
            }
            
        try{
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(part.vertices), gl.STATIC_DRAW);
            pm.setAttributePointer(essl.VERTEX_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
        }
        catch(err){
            alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the vertex buffer. Error =' +err.description);
            throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the vertex buffer. Error =' +err.description);
        }
        
       if (part.colors && part.colors.length > 0){ 
           
                if (buffers.colors == undefined){
                    //when switching to parts this might not be defined
                    buffers.colors = gl.createBuffer();
                }
              
                try{
                    pm.setUniform("uUseVertexColors", true);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.colors);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(part.colors), gl.STATIC_DRAW);
                    
                    pm.enableAttribute(essl.COLOR_ATTRIBUTE);
                    pm.setAttributePointer(essl.COLOR_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
                }
                catch(err){
                    alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the color buffer. Error =' +err.description);
                    throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the color buffer. Error =' +err.description);
                }
        }
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(part.indices), gl.STATIC_DRAW);
        gl.drawElements(gl.TRIANGLES, part.indices.length, gl.UNSIGNED_SHORT,0);
    }
     
};


/**
 * This method takes care of rendering the scene in the background buffer. Only the 
 * actors that are pickable reach this method (see _handlePicking) so the isPickable 
 * validation (actor.isPickable) is not necessary here.
 * 
 * This method makes sure the correct version of the object is rendered in the background
 * buffer
 * 
 * if the object picking method is OBJECT then the same object is rendered but using
 * the picking color (actor._pickingColor) as the diffuse material uniform. 
 *
 * Otherwise, when the object picking mode is CELL, then the mesh model is rendered. 
 * The mesh model colors every cell differently (drawback in performance)
 *    
 * @private
 */
vxlRenderEngine.prototype._renderPickingBuffer = function(actor){
    
    var model   = actor.model;
    var buffers = this._gl_buffers[actor.UID];
    var texture = this._gl_textures[actor.UID]; 
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl;
    
    pm.setUniform("uUseShading",false);
    
    if (actor._picking == vxl.def.actor.picking.CELL){
    
      
        if (actor.mesh == undefined || actor.mesh.model == undefined){
            return; // we just fail safely. We will render it whenever the actor is ready ;-)
                    // the mesh is generated inside actor.setPicker (see actor.setPicker method)
        }
        
      
        var parts = actor.renderable.parts;
        var i = parts.length;
        while(i--){
        
            var part = parts[i];
        
            try{
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(part.vertices), gl.STATIC_DRAW);
                pm.setAttributePointer(essl.VERTEX_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
            }
            catch(err){
                alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the vertex buffer. Error =' +err.description);
                throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the vertex buffer. Error =' +err.description);
            }
            
            if (part.pickingColors && part.pickingColors.length == part.vertices.length){
                
                if (buffers.colorss == undefined){
                    //when switching to parts this might not be defined
                    buffers.colors = gl.createBuffer();
                }
                  
                try{
                    pm.setUniform("uUseVertexColors", true);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.colors);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(part.pickingColors), gl.STATIC_DRAW);
                    
                    pm.enableAttribute(essl.COLOR_ATTRIBUTE);
                    pm.setAttributePointer(essl.COLOR_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
                }
                catch(err){
                    alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the color buffer. Error =' +err.description);
                    throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the color buffer. Error =' +err.description);
                }
            }
            else{
                alert('The object '+part.name+' does not have picking colors assigned.');
                throw('The object '+part.name+' does not have picking colors assigned.')
            }
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(part.indices), gl.STATIC_DRAW);
            gl.drawElements(gl.TRIANGLES, part.indices.length, gl.UNSIGNED_SHORT,0);
        }
    }
    else if (actor._picking == vxl.def.actor.picking.OBJECT){
        
        pm.setUniform("uMaterialDiffuse",actor._pickingColor.concat(1.0));
        try{
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.vertices), gl.STATIC_DRAW);
            pm.setAttributePointer(essl.VERTEX_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
        }
        catch(err){
            alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the vertex buffer. Error =' +err.description);
            throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the vertex buffer. Error =' +err.description);
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(model.indices), gl.STATIC_DRAW);
        gl.drawElements(gl.TRIANGLES, model.indices.length, gl.UNSIGNED_SHORT,0);
    }
    
    //Cleaning up
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
     
};

/**
 * @private
 */
vxlRenderEngine.prototype._renderTextured = function(actor){
    
    var model   = actor.model;
    var buffers = this._gl_buffers[actor.UID];
    var texture = this._gl_textures[actor.UID]; 
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl;   
    
    if (!actor.material.texture.loaded){
        this._renderSolid(actor);
        return;
    }
    
    if (model.texcoords){
        try{
            pm.setUniform("uUseTextures", true);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.texcoords);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.texcoords), gl.STATIC_DRAW);
            pm.setAttributePointer(essl.TEXCOORD_ATTRIBUTE, 2, gl.FLOAT,false, 0,0);
            pm.enableAttribute(essl.TEXCOORD_ATTRIBUTE);
        }
        catch(err){
            alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the texture buffer. Error =' +err.description);
            throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the texture buffer. Error =' +err.description);
        }
    }
    else{
        //@TODO: Be more specific
        throw('error');
    }
            
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, actor.material.texture.getMagFilter(gl));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, actor.material.texture.getMinFilter(gl));
    pm.setUniform("uSampler", 0);
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
    gl.drawElements(gl.TRIANGLES, model.indices.length, gl.UNSIGNED_SHORT,0);
};

/**
 * @private
 */
vxlRenderEngine.prototype._handleCulling = function(actor){
    var gl = this.renderer.gl;
    
    gl.disable(gl.CULL_FACE);
    if (actor.cull != vxl.def.actor.cull.NONE){
        gl.enable(gl.CULL_FACE);
        switch (actor.cull){
            case vxl.def.actor.cull.BACK: gl.cullFace(gl.BACK); break;
            case vxl.def.actor.cull.FRONT: gl.cullFace(gl.FRONT); break;
        }
    } 
    
           
}; 

/**
 * @private
 */
vxlRenderEngine.prototype._renderActor = function(actor){

    if (!actor.visible) return; //Quick and simple

    var model   = actor.model;
    var buffers = this._gl_buffers[actor.UID];
    var texture = this._gl_textures[actor.UID]; 
    var gl      = this.renderer.gl;
    var pm     = this.renderer.pm;
    var essl    = vxl.def.essl;   
    var trx     = this.renderer.transforms;
    var diffuse = [actor.material.diffuse[0], 
                   actor.material.diffuse[1], 
                   actor.material.diffuse[2],
                   actor.material.opacity];
                   
    /**
     * If the renderer is not forcing his program, then give the actors
     * a chance to decide which program they want to use to be rendered
     */
    if (!this.renderer._enforce && actor.mode != vxl.def.actor.mode.FLAT){
        if(actor.material.shininess > 0){
            this.renderer.setProgram(vxl.go.essl.phong);
            pm.setUniform("uShininess", actor.material.shininess);
            pm.setUniform("uMaterialSpecular", actor.material.specular);
        }
        else{
            this.renderer.setProgram(vxl.go.essl.lambert);
        }
    }
    
    if (actor.mode == vxl.def.actor.mode.FLAT){
        this.renderer.setProgram(vxl.go.essl.lambert);
    }
    
    
    pm.disableAttribute(essl.TEXCOORD_ATTRIBUTE);
    pm.disableAttribute(essl.COLOR_ATTRIBUTE);
    pm.disableAttribute(essl.NORMAL_ATTRIBUTE);
    pm.disableAttribute(essl.PICKING_COLOR_ATTRIBUTE);
    pm.enableAttribute(essl.VERTEX_ATTRIBUTE);
    
    pm.setUniform(essl.PERSPECTIVE_MATRIX, trx.pMatrix);
    pm.setUniform("uUseVertexColors", false);
    pm.setUniform("uUseTextures", false);
    pm.setUniform("uUseShading",actor.material.shading);
    pm.setUniform("uMaterialDiffuse",diffuse);
    
    
    this._handleCulling(actor);
    this._applyActorTransform(actor);
    
    
    if(this._onPickingBuffer || this._debug_picking_flag){
        this._renderPickingBuffer(actor);
        return;
    }
    
        
    if (actor.mode != vxl.def.actor.mode.FLAT && actor.model.type != vxl.def.model.type.BIG_DATA){
        try{
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.vertices), gl.STATIC_DRAW);
            pm.setAttributePointer(essl.VERTEX_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
        }
        catch(err){
            alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the vertex buffer. Error =' +err.description);
            throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the vertex buffer. Error =' +err.description);
        }
    }
    
    
    var am = vxl.def.actor.mode;
    
    switch(actor.mode){
        case am.SOLID:           this._renderSolid(actor);               break;
        case am.WIREFRAME:       this._renderWireframe(actor);           break;
        case am.POINTS:          this._renderPoints(actor);              break;
        case am.LINES:           this._renderLines(actor);               break;
        case am.BOUNDING_BOX:    this._renderBoundingBox(actor);         break;
        case am.BB_AND_SOLID:    this._renderBoundingBoxAndSolid(actor); break;
        case am.WIRED_AND_SOLID: this._renderWiredAndSolid(actor);       break;
        case am.FLAT:            this._renderFlat(actor);                break;
        case am.TEXTURED:        this._renderTextured(actor);            break;
        default:
            alert('There was a problem while rendering the actor ['+actor.name+']. The visualization mode: '+actor.mode+' is not valid.');
            throw('There was a problem while rendering the actor ['+actor.name+']. The visualization mode: '+actor.mode+' is not valid.'); 
    }
    
    //Cleaning up
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
};
    
    
/**
 * Sets up the offscreen rendering variant
 * @param {vxlRenderTarget} target the render target
 */
vxlRenderEngine.prototype.enableOffscreen = function(target){
    this._offscreen = true;
    this._target = target;
};

/**
 * Sets up the offscreen rendering variant
 * @param {vxlRenderTarget} target the render target
 */
vxlRenderEngine.prototype.disableOffscreen = function(){
    this._offscreen = false;
    this._target = undefined;
};

/**
 * Returns true if the offscreen rendering does not have any target.
 * @returns {true\false}
 */
vxlRenderEngine.prototype.isOffscreenEnabled = function(){
    return (this._target != undefined);    
}

/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 

/**
 * Implements the strategy to render Blender scenes that have been exported to the OBJ format and from there
 * to the Voxelent format.
 * @author Diego Cantor
 * @class
 * Implements the strategy to render Blender scenes that have been exported to the OBJ format and from there
 * to the Voxelent format. 
 * @extends vxlBasicStrategy
 * @constructor 
 * @param {vxlRenderer} renderer the renderer associated to this strategy
 *  
 */
function vxlBlenderEngine(renderer) {
	this.renderer = renderer;
}

/**
 * Renders the scene
 * @param {Object} scene
 */
vxlBlenderEngine.prototype.render = function(scene){
    
    //Updates the perspective matrix and passes it to the program
    var r       = this.renderer;
    var trx     = r.transforms
    var pm     = r.pm;
    var essl    = vxl.def.essl;
    
    trx.calculatePerspective();
    trx.calculateModelView();
    pm.setUniform(essl.PERSPECTIVE_MATRIX, trx.pMatrix);
    
    var elements = scene._actors.concat(scene.toys.list);
    var NUM = elements.length;
    
    if (scene.frameAnimation != undefined){
        scene.frameAnimation.update();
    }

    for(var i = 0; i < NUM; i+=1){
        this._renderActor(elements[i]);
    }
};


/**
 * Passes the matrices to the shading program
 * @param {vxlActor} the actor 
 * we will update each Model-View matrix of each renderer according to
 * the actor position,scale and rotation.
 * @private
 */
vxlBlenderEngine.prototype._applyActorTransform = function(actor){
    
    var r       = this.renderer;
    var trx     = r.transforms
    var pm     = r.pm;
    var essl    = vxl.def.essl;

    trx.push();
        mat4.translate  (trx.mvMatrix, actor._position);
        mat4.scale      (trx.mvMatrix, actor._scale);
        //@TODO: IMPLEMENT ACTOR ROTATIONS
        
        pm.setUniform(essl.MODEL_VIEW_MATRIX,  r.transforms.mvMatrix);
    trx.pop();
    
    trx.calculateNormal(); 
    pm.setUniform(essl.NORMAL_MATRIX, r.transforms.nMatrix);
    
    
    
 };

/**
 * @private
 * @param {Object} actor
 */
vxlBlenderEngine.prototype._renderActor = function(actor){
	
	if (actor.name == 'bounding box' || actor.name == 'axis' || actor.name =='floor'){
		return;
	}

	var model 	= actor.model;
    var buffers = this._gl_buffers[actor.UID]; 
    var r  		= this.renderer;
	var gl 		= r.gl;
	var pm 	= r.pm;
	var trx 	= r.transforms;
	var essl    = vxl.def.essl;
	
	gl.disable(gl.CULL_FACE);
    
    if (actor.cull != vxl.def.actor.cull.NONE){
        gl.enable(gl.CULL_FACE);
        
        switch (actor.cull){
            case vxl.def.actor.cull.BACK: gl.cullFace(gl.BACK); break;
            case vxl.def.actor.cull.FRONT: gl.cullFace(gl.FRONT); break;
        }
    }
    
	this._applyActorTransform(actor);
	
	pm.disableAttribute(essl.NORMAL_ATTRIBUTE);
	pm.enableAttribute(essl.VERTEX_ATTRIBUTE);
	
	pm.setUniform("uKa", actor.getProperty("Ka"));
	pm.setUniform("uKd", actor.getProperty("Kd"));
	pm.setUniform("uKs", actor.getProperty("Ks"));
	pm.setUniform("uNs", actor.getProperty("Ns"));
	pm.setUniform("d", actor.getProperty("opacity"));
	pm.setUniform("illum", actor.getProperty("illum"));
	
	
	try{
		
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.vertices.slice(0)), gl.STATIC_DRAW);
		pm.setAttributePointer(essl.VERTEX_ATTRIBUTE, 3, gl.FLOAT, false, 0, 0);
	}
    catch(err){
        alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the vertex buffer. Error =' +err.description);
		throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the vertex buffer. Error =' +err.description);
    }
    
    if(model.normals){
	    try{
			gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(model.normals.slice(0)), gl.STATIC_DRAW);
			
			pm.enableAttribute(essl.NORMAL_ATTRIBUTE);
			pm.setAttributePointer(essl.NORMAL_ATTRIBUTE,3,gl.FLOAT, false, 0,0);
		}
	    catch(err){
	        alert('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the normal buffer. Error =' +err.description);
			throw('There was a problem while rendering the actor ['+actor.name+']. The problem happened while handling the normal buffer. Error =' +err.description);
	    }
	}
	
	
	try{
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
		gl.drawElements(gl.TRIANGLES, model.indices.length, gl.UNSIGNED_SHORT,0);

    	gl.bindBuffer(gl.ARRAY_BUFFER, null);
    	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	}
	catch(err){
		alert('Error rendering actor ['+actor.name+']. Error =' +err.description);
		throw('Error rendering actor ['+actor.name+']. Error =' +err.description);
	}

};/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 

/**
 * @constructor
 * @class
 * Implements a basic rendering strategy that works with the following programs:
 * 
 * vxl.def.essl.bake
 * TODO: Does not deal with model scalars well...
 * 
 */
function vxlBakeEngine(renderer){
    this.renderer = renderer;
    
    var gl = renderer.gl;
    
    this._calls     = {}
    
    this._gl_buffers  = {
        index       : gl.createBuffer(),
        baked       : gl.createBuffer(),
        position    : gl.createBuffer(),
        scale       : gl.createBuffer(),
        shading     : gl.createBuffer()
    };  
    
    this._data        = {
        index       : [],
        baked       : [],
        position    : [],
        scale       : [],
        shading     : []
        
    }; 
     
    this._allocated   = []; //if an actor is here, do not allocate
    
    this._offsets     = {
       position :{},
       scale    :{},
       shading  :{},
       baked    :{} 
    }; 
    
    
    this.glsl = vxl.util.extend(
        vxl.def.essl,{
        POSITION: "aPosition",
        SCALE:    "aScale",
        SHADING:  "aShading"
    });

};


/**
 * Creates an array of a defined size populated with the indicated value
 * @private
 */
vxlBakeEngine.prototype._populate = function(value, size){
    var a = [];
    
    for (var i = 0; i < size; i+=1){
        if (value instanceof Array || value instanceof Float32Array){
            for (var j = 0; j < value.length; j+=1){
                a.push(value[j]);
            }
        }
        else{
            a.push(value);
        }
    }
    return a;
};


/**
 * Computes the number of required calls to render one scene
 * @private
 */
vxlBakeEngine.prototype._computeRequiredCalls = function(scene){

    var elements    = scene._actors; //.concat(scene.toys.list);
    var NUM         = elements.length;
    var accum = 0;
    var count = 1;
    
    for(var i = 0; i < NUM; i+=1){
        accum += elements[i].model.indices.length;
        if (accum > 65000){ //66560?
            accum = 0;
            count ++;
        }
    }
    return count;
};


/**
 * Receives one actor and returns the GL buffers
 * @private
 */
vxlBakeEngine.prototype._allocateActor = function(actor){
    
    if (this._allocated.indexOf(actor.UID) != -1) return; //this actor has been allocated
    var data            = this._data;
    var offsets         = this._offsets;
    var gl              = this.renderer.gl;
    var model           = actor.model;
    var NUM_VERTICES    = model.vertices.length;
    
        
    var color = [], normal = [];
    
    //Taking care of colors
    if (actor.material.diffuse) {
        color = this._populate(actor.material.diffuse, NUM_VERTICES/3);
    }
    else{
        color = this._populate([0.7,0.7,0.7], NUM_VERTICES/3);
    }
    
    //Taking care of normals
    if (model.normals){
        normal = model.normals;
    }
    else{
        normal = this._populate(0, NUM_VERTICES);
    }
    
    offsets.baked[actor.UID]    =data.baked.length;
    
    for (var i=0;i<NUM_VERTICES; i+=3){
        
        data.baked.push(model.vertices[i]);
        data.baked.push(model.vertices[i+1]);
        data.baked.push(model.vertices[i+2]);
        
        data.baked.push(normal[i]);
        data.baked.push(normal[i+1]);
        data.baked.push(normal[i+2]);
        
        data.baked.push(color[i]);
        data.baked.push(color[i+1]);
        data.baked.push(color[i+2]);
    }
    
    offsets.position[actor.UID] = data.position.length;
    offsets.scale[actor.UID]    = data.scale.length;
    offsets.shading[actor.UID]  = data.shading.length;
    
    data.position = data.position.concat(this._populate(actor._position, NUM_VERTICES/3));
    data.scale    = data.scale.concat(this._populate(actor._scale, NUM_VERTICES/3));
    data.shading = data.shading.concat(this._populate(actor.material.opacity, NUM_VERTICES/3));
    

    var ind = model.indices.slice(0);
    if (data.index.length > 0){
        var max = data.index.max()+1;
        var NUM_INDICES = model.indices.length;
        for (var i=0; i<NUM_INDICES; i+=1){
            ind[i] += max;
        }
        data.index = data.index.concat(ind);
    }
    else{
        data.index = ind;
    }
    
    this._allocated.push(actor.UID);
};

/**
 * @private
 */
vxlBakeEngine.prototype._updateActorPosition = function(actor){
    
    var data = this._data;
    var offset = this._offsets.position[actor.UID];
    
    if (offset == undefined) return;
    
    var LEN = actor.model.vertices.length + offset;
    for(var i =offset;i<LEN;i+=3){
        data.position[i]   = actor._position[0];
        data.position[i+1] = actor._position[1];
        data.position[i+2] = actor._position[2];
    }
};

/**
 * @private
 */
vxlBakeEngine.prototype._updateActorScale = function(actor){
    var data = this._data;
    var offset = this._offsets.scale[actor.UID];
    
    if (offset == undefined) return;
    
    var LEN = actor.model.vertices.length + offset;
    for(var i =offset;i<LEN;i+=3){
        data.scale[i]   = actor._scale[0];
        data.scale[i+1] = actor._scale[1];
        data.scale[i+2] = actor._scale[2];
    }
};


/**
 * @private
 */
vxlBakeEngine.prototype._updateActorColor = function(actor){
    var data = this._data;
    var offset = this._offsets.baked[actor.UID];
    
    if (offset == undefined) return;
    
    var LEN = (actor.model.vertices.length*3) + offset;
    for(var i =offset;i<LEN;i+=9){
        data.baked[i+6] = actor.material.diffuse[0];
        data.baked[i+7] = actor.material.diffuse[1];
        data.baked[i+8] = actor.material.diffuse[2];
    }
};

/**
 * @private
 */
vxlBakeEngine.prototype._updateActorShading = function(actor){
    var data = this._data;
    var offset = this._offsets.shading[actor.UID];
    
    if (offset == undefined) return;
    
    var LEN = (actor.model.vertices.length/3) + offset;
    var val = 0.0;
    
    if (actor.material.opacity){
        val = 1.0;
    }
    
    for(var i =offset;i<LEN;i+=1){
       data.shading[i]   = val;
    }
};


/**
 * @param {vxlScene} scene the scene to deallocate memory from
 */
vxlBakeEngine.prototype.deallocate = function(scene){

};


/**
 * Implements basic allocation of memory. Creates the WebGL buffers for the actor
 * @param {vxlScene} scene the scene to allocate memory for
 * @returns an object that contains the allocated WebGL buffers
 */
vxlBakeEngine.prototype.allocate = function(scene){
    
    if (this._computeRequiredCalls(scene) > 1) {
        throw 'Not renderable yet. Working on it. The number of indices exceeds the 65K limit';
    }
    
    var elements    = scene._actors; //.concat(scene.toys.list);
    var NUM         = elements.length;
    var r           = this.renderer;
    var buffers     = this._gl_buffers;
    var data        = this._data;

    var pm         = r.pm;
    var gl          = r.gl;
    var essl        = this.glsl;
    var mode        = gl.STATIC_DRAW;
    
    
    
    for(var i = 0; i < NUM; i+=1){
        this._allocateActor(elements[i]);
    }
    
    pm.enableAttribute(essl.VERTEX_ATTRIBUTE);
    pm.enableAttribute(essl.NORMAL_ATTRIBUTE);
    pm.enableAttribute(essl.COLOR_ATTRIBUTE);
    
    pm.enableAttribute(essl.POSITION);
    pm.enableAttribute(essl.SCALE);
    pm.enableAttribute(essl.SHADING);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.baked);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.baked), mode);
    pm.setAttributePointer(essl.VERTEX_ATTRIBUTE, 3, gl.FLOAT, false, 36, 0);
    pm.setAttributePointer(essl.NORMAL_ATTRIBUTE, 3, gl.FLOAT, false, 36, 12);
    pm.setAttributePointer(essl.COLOR_ATTRIBUTE, 3, gl.FLOAT, false, 36, 24);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.position), mode);
    pm.setAttributePointer(essl.POSITION, 3, gl.FLOAT, false,12,0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.scale);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.scale), mode);
    pm.setAttributePointer(essl.SCALE, 3, gl.FLOAT, false,12,0);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.shading);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.shading), mode);
    pm.setAttributePointer(essl.SHADING, 1, gl.FLOAT, false,4,0);
    

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data.index), mode);
};




/**
 * Renders the actors one by one
 * @param {vxlScene} scene the scene to render
 */
vxlBakeEngine.prototype.render = function(scene){

    //Updates the perspective matrix and passes it to the program
    var r       = this.renderer;
    var trx     = r.transforms
    var pm     = r.pm;
    var gl      = r.gl;
    var essl    = vxl.def.essl;
    var data    = this._data;
    
    trx.update();

    pm.setUniform(essl.PERSPECTIVE_MATRIX, trx.pMatrix);
    pm.setUniform(essl.MODEL_VIEW_MATRIX,  trx.mvMatrix);
    pm.setUniform(essl.NORMAL_MATRIX,      trx.nMatrix);
    pm.setUniform(essl.MVP_MATRIX,         trx.mvpMatrix);
    
    for(var i = 0, N = scene._actors.length; i<N; i+=1){
        var actor = scene._actors[i];
        this._updateActorPosition(actor);   
        this._updateActorScale(actor);     
        this._updateActorShading(actor);  
        this._updateActorColor(actor);     
    }
    
    
    gl.drawElements(gl.TRIANGLES, data.index.length, gl.UNSIGNED_SHORT,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
};
     
  
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  

/**
*  Each view has a vxlScene object associated to it. The actors added to the scene are those that the renderer's view will render.
*  Actors can be added/removed from the scene at any time.
*  The scene also determines the lookup table that is used by the actors in it.
*  A scene can have one or more views associated to it.
* 
*  @class
*  @constructor
*  @author Diego Cantor
*/
function vxlScene()
{
	this.views  				= [];
	this._actors 				= [];
	this._groups                = [];
	this.toys					= new vxlSceneToys(this);
	this.loadingMode 			= vxl.def.model.loadingMode.LIVE;
	this.normalsFlipped 		= false;
	this.lutID 					= null;
	this.timerID				= null;
	//this.dispatchRate 			= 500;
	this.scalarMIN 				= Number.MAX_VALUE;
	this.scalarMAX 				= Number.MIN_VALUE;
	this.bb 					= [0, 0, 0, 0, 0, 0];
	this.centre 				= [0, 0, 0];
	this.frameAnimation			= null;
	this.UID                    = vxl.util.generateUID();


	if (vxl.c.scene  == null) vxl.c.scene 	= this;

	vxl.go.scenes.push(this);
	
	var ntf = vxl.go.notifier;
    var e = vxl.events;
    ntf.publish([e.SCENE_NEW, e.SCENE_UPDATED], this);
    ntf.subscribe([e.MODELS_LOADED, e.DEFAULT_LUT_LOADED], this);
	ntf.fire(e.SCENE_NEW, this);
};

/**
 * Handles events sent by vxlNotifier
 * @param {String} event This event should be defined in vxl.events
 * @param {Object} the source that sent the event. Useful for callbacks
 */
vxlScene.prototype.handleEvent = function(event,src){
	
    if(event == vxl.events.MODELS_LOADED){
		this.updateScalarRange();
		if (this.lutID != null) {this.setLookupTable(this.lutID);}
	}
	else if (event == vxl.events.DEFAULT_LUT_LOADED){
		this.lutID = 'default';
		this.setLookupTable(this.lutID);
	}

};


/**
 * Sets the loading mode for this scene 
 * @param mode one of the valid loading modes
 * @see {vxl.def.model.loadingMode} 
 */
vxlScene.prototype.setLoadingMode = function(mode){
	var m = vxl.def.model.loadingMode;
	
	if (mode == undefined || mode == null || 
		(mode != m.LIVE &&  mode != m.LATER && mode != m.DETACHED)){
		 	throw('the mode '+mode+ 'is not a valid loading mode');
	}
	this.loadingMode = mode;
};




/**
 * Calculates the global bounding box and the centre for the scene. 
 * @private
 */
vxlScene.prototype._updateBoundingBoxWith = function(actor){

    //actor.computeBoundingBox();
    
    var b = actor._bb;
    
    vxl.go.console('Scene: updating metrics with ('+ b[0]+','+b[1]+','+b[2]+') - ('+b[3]+','+b[4]+','+b[5]+')');
    if (this._actors.length == 1){
        //Quicky!  
        this.bb = this._actors[0]._bb.slice(0);
        this.toys.update();
        return;
    }
    
    
    var bb = this.bb;
    var cc = this.centre;
    
	bb[0] = Math.min(bb[0],b[0]);
	bb[1] = Math.min(bb[1],b[1]);
	bb[2] = Math.min(bb[2],b[2]);
	bb[3] = Math.max(bb[3],b[3]);
	bb[4] = Math.max(bb[4],b[4]);
	bb[5] = Math.max(bb[5],b[5]);

	cc[0] = (bb[3] + bb[0]) /2;
	cc[1] = (bb[4] + bb[1]) /2;
	cc[2] = (bb[5] + bb[2]) /2;
	
	cc[0] = Math.round(cc[0]*1000)/1000;
	cc[1] = Math.round(cc[1]*1000)/1000;
	cc[2] = Math.round(cc[2]*1000)/1000;
	
	this.toys.update();

};

/**
 * Calculates the global bounding box and the center of the scene.
 * Updates the Scene's axis and bounding box toys.
 */
vxlScene.prototype.computeBoundingBox = function() {
    
    if (this._actors.length >0){
	   this.bb = this._actors[0]._bb.slice(0);
	}
	else{
	    this.bb = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
	}
	
	this.centre = [0.0, 0.0, 0.0];
	
	var i = this._actors.length;
	while(i--){
	   this._updateBoundingBoxWith(this._actors[i]);
	}
};

/**
 * This function creates AND ADD a new actor to this scene
 * @param {vxlModel} model the model from which a new actor will be created AND added to this scene
 * 
 * If you are looking to create but not adding an actor call new vxlActor(model) instead.
 * 
 * @returns actor the actor that was created and added to the scene, from the model passed as parameter
 */
vxlScene.prototype.createActor = function(model){
	var actor = new vxlActor(model);
	this.addActor(actor);
	return actor;
};

/**
 * Creates multiples actors at once
 * @param models a list of models to create actors from
 */
vxlScene.prototype.createActors = function(models){
    var i = models.length;
	while(i--){
		this.createActor(models[i]);
	}	
};
/**
 * Adds one actor.
 * The added actor becomes the current one (vxl.c.actor)
 * @param actor the actor to be added to the scene
 */
vxlScene.prototype.addActor = function(actor){
    
    actor.setScene(this);
    
    if (this.normalsFlipped){
        actor.flipNormals(true);
    }
    
    if (this.lutID != null){
        actor.setLookupTable(this.lutID, this.scalarMIN, this.scalarMAX);
    }
    
    this._actors.push(actor);
    this._updateBoundingBoxWith(actor); 
    
    vxl.go.console('Scene: Actor for model '+actor.model.name+' added');
    
    if (this._actors.length ==1){
    	vxl.c.actor = actor; //if we have only one
    }
    else{
    	vxl.c.actor = undefined; //if we have a bunch then we don't have a current one
    }
    
    vxl.go.notifier.fire(vxl.events.SCENE_UPDATED, this);
};

/**
 * Recreates the WebGL buffers when an actor has changed its geometry 
 * @param actor the actor to be updated
 */
vxlScene.prototype.updateActor = function(actor){
    if(!this.hasActor(actor)) return;
    
    actor.dirty = true;
    var i = this.views.length;
    while(i--){
        this.views[i].renderer.reallocate();                
    }
    actor.dirty = false;
};

/**
 * Removes one actor
 * @param actor the actor to be removed from the scene
 */
vxlScene.prototype.removeActor = function(actor){
	var idx = this._actors.indexOf(actor);
	this._actors.splice(idx,1);
    this.computeBoundingBox();
};

/**
 * Verifies if the actor passed as a parameter belongs to this scene
 * @param {vxlActor, String} actor the actor object or the actor name to verify 
 */
vxlScene.prototype.hasActor = function(actor){
	if (actor instanceof vxlActor){
		return (this._actors.indexOf(actor)!=-1)
	}
	else if (typeof(actor)=='string'){
		var aux = this.getActorByName(actor);
		return (aux != undefined);
	}
	else return false;
};


/**
 * Sets a property for all the actors in the scene
 * @param {String} property the name of the actor property
 * @param {Object} value the value of the property
 */
vxlScene.prototype.setPropertyForAll = function (property, value){
    var i = this._actors.length;
    while(i--){
        this._actors[i].setProperty(property, value);
    }
};


/**
 *Sets a property for a list of actors.
 * @param {Array} list list of actors (String or vxlActor)
 * @param {String} property the name of the actor property
 * @param {Object} value the value of the property
 
 */
vxlScene.prototype.setPropertyFor = function (list, property, value){
    var i = list.length;
    while(i--){
        if (this.hasActor(list[i])){
            var actor = undefined;
            if (typeof(list[i])=='string'){
                actor = this.getActorByName(list[i]);
            }
            else if (list[i] instanceof vxlActor){
                list[i].setProperty(property, value);
            }
            else{
                throw 'vxlScene.setPropertyFor: ERROR, the list of actors is invalid';
            }
        }
    }
};
/**
 * Updates the Scene's scalarMAX and scalarMIN properties.
 */
vxlScene.prototype.updateScalarRange = function(){
    var i = this._actors.length;
	while(i--){
		var actor = this._actors[i];
		if (actor.model.scalars && actor.model.scalars.max() > this.scalarMAX) this.scalarMAX = actor.model.scalars.max();
		if (actor.model.scalars && actor.model.scalars.min() < this.scalarMIN) this.scalarMIN = actor.model.scalars.min();
	}
};

/**
 * Sets a new lookup table by passing the lookup table id
 * @param lutID the lookup table id
 */
vxlScene.prototype.setLookupTable = function(lutID){
	this.lutID = lutID;
	var i = this._actors.length;
	while(i--){
     	this._actors[i].setLookupTable(lutID,this.scalarMIN, this.scalarMAX);
	}
};

/*
 * Removes all the actors from the Scene and resets the actor list
 * It will also set vxl.c.actor to null
 */
vxlScene.prototype.reset = function(){
    var i = this._actors.length;
	while(i--){
		this._actors[i] = null;
	}
	this._actors = [];
	vxl.c.actor = null;
	this.computeBoundingBox();
};

/**
 * Retrieves an actor object by name
 * @param name the name of the actor to retrieve
 */
vxlScene.prototype.getActorByName = function(name){
    name = name.replace(/\.[^/.]+$/, "");
	var i = this._actors.length;
    while(i--){
		if(this._actors[i].name == name){
			return this._actors[i];
		}
	}
	return null;
};


/**
 * Retrieves an actor object by Unique Identifier (UID)
 * @param UID the actor's UID
 */
vxlScene.prototype.getActorByUID = function(UID){
    var i = this._actors.length;
    while(i--){
        if(this._actors[i].UID == UID){
            return this._actors[i];
        }
    }
    return null;
};

/**
 * Retrieves an actor by Name or UID 
 */
vxlScene.prototype.getActor = function(actorNameOrUID){
     var actor = this.getActorByName(actorNameOrUID);
     
     if (actor == null){
         actor = this.getActorByUID(actorNameOrUID);
     }
     return actor;
};


/**
 * <p>Returns a list of actors based on the condition passed as parameter.</p>
 * <p>The condition is a function with the following signature:</p>
 * <p><code> condition(vxlActor): returns boolean</code></p>
 * <p>If the condition evaluates true then that actor is included in the results</p>
 * 
 * @param {function} condition the condition to evaluate in the actor list it receives an actor as a parameter
 * @returns {Array} list of actors 
 */
vxlScene.prototype.getActorsThat = function(condition){
    var idx = [];
    var i = this._actors.length;
    while(i--){
        if (condition(this._actors[i])) {
            idx.push(i);
        }
    }
    var results = [];
    var j = idx.length;
    while(j--){
        results.push(this._actors[idx[j]]);
    }
    return results;
};

/**
 * Changes the opacity for one or all actors in the scene
 * @param o opacity value [0..1]
 * @param name the name of the actor whose opacity will be changed. 
 *             If this parameter is missing, the opacity of all actors will be changed.
 */
vxlScene.prototype.setOpacity = function(o,name){
	if (name == null){
	    var i = this._actors.length;
		while(i--){
			this._actors[i].setOpacity(o);
		}
	}
	else{
		var actor = this.getActorByName(name);
		actor.setOpacity(o);
	}

};

/**
 * Flips the normals for all the actors in the scene. This will
 * have an immediate effect in the side of the object that it is being lit.
 */
vxlScene.prototype.flipNormals = function(){
    var i = this._actors.length;
	while(i--){
		this._actors[i].flipNormals();
	}
};


/**
 * Changes the visualization mode for all the objects in the scene
 * @param mode the visualization mode. It can be... TODO
 */
vxlScene.prototype.setVisualizationMode = function(mode){
	if (mode == null || mode == undefined) return;
	var i = this._actors.length;
	while(i--){
			this._actors[i].setVisualizationMode(mode);
	}
};


/**
 * Sets the animation for this scene
 * @param {vxlFrameAnimation} animation the animation to set on this scene
 * @see vxlFrameAnimation
 */
vxlScene.prototype.setAnimation = function(animation){
	if (animation instanceof vxlFrameAnimation){
		this.frameAnimation = animation;
		this.frameAnimation.scene = this;
		var i = this.views.length;
		while(i--){
			this.views[i].renderer.setMode(vxl.def.renderer.mode.ANIMFRAME);
		}
		
		vxl.go.console('Scene: animation added');
	}
};
/**
 * Removes the animation if there is one associated to this scene
 * @see vxlFrameAnimation
 * @TODO: Review what happens to the actors. Should we remove them too?
 */
vxlScene.prototype.clearAnimation = function(){
	if (this.frameAnimation) {
		this.frameAnimation.scene = null;
		this.frameAnimation = null;
	}
};

/**
 * Returns a list with the actor names
 * @returns {Array} a list with the actor names
 */
vxlScene.prototype.getActorNames = function(){
	var list = [];
	var i = this._actors.length;
	while(i--){
		list.push(this._actors[i].name);
	}
	return list;
};

/**
 * Return a list with the actors that are currently pickable 
 */
vxlScene.prototype.getPickableActors = function(){
    
    function condition(actor){
        return actor.isPickable();
    }
    
    return this.getActorsThat(condition);
};

/**
 * Given a cell uid the scene identifies the actor it belongs to. If an actor is not found
 * this method returns null 
 * @param {String} cellUID
 * @returns {vxlActor|null}
 * 
 */
vxlScene.prototype.getActorByCellUID = function(UID){
    var list = [];
    var i = this._actors.length;
    while(i--){
        var actor = this._actors[i];
        if (actor.mesh != undefined && actor.mesh.hasCell(UID)){
            return actor;
        }
    }
    return null;
};



/**
 * Creates an actor group 
 * @param {Object} name name of the actor group
 * @param {Object} list list of actors to add to the actor group. Elements in the list can be
 * actor classes, actors UID, actor names or any combination of these.
 * @see {vxlActorGroup}
 */
vxlScene.prototype.createActorGroup = function(name, list){
    var actorGroup = undefined;
    if(this.getActorGroup(name) != null){
        alert('vxlScene.createActorGroup: an actor group with the name '+name+' already exists');
        throw('vxlScene.createActorGroup: an actor group with the name '+name+' already exists');
    }
    
    try{
        actorGroup = new vxlActorGroup(this,name,list);
        this._groups.push(actorGroup);
    }
    catch(ex){
        if (ex instanceof vxlActorGroupException){
            alert(ex.messages);
        }
    }
    finally{
        return actorGroup;
    }
};

/**
 *Retrieves an actor group by name 
 * @param {Object} name
 */
vxlScene.prototype.getActorGroup = function(name){
    var i = this._groups.length;
    while(i--){
        if(this._groups[i].name == name){
            return this._groups[i];
        }
    }
    return null;
};
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  

/**
 * @class Manages the axis, the bounding box and the floor
 * These are auxiliary objects or 'toys'
 */
function vxlSceneToys(scn){
    
    this.scene = scn;
    this.list   = [];

	this.axis 				= new vxlAxis();
	this.boundingbox 		= new vxlBoundingBox();
	this.floor  			= new vxlFloor();
	
	this.list.push(this.axis);
    this.list.push(this.boundingbox);
    this.list.push(this.floor);
};

/**
 * Updates the toys according to information from the scene
 * 
 */
vxlSceneToys.prototype.update = function(){
    this.axis.setCentre(this.scene.centre);
    this.boundingbox.setBoundingBox(this.scene.bb);
};

/**
 * @class Contains a mapping between scalars and a color palette
 * @constructor
 */
function vxlLookupTable(){
	this.ID = null;
	this.map = null;
	this.max = Number.MIN_VALUE;
	this.min = Number.MAX_VALUE;
}

/**
 * Creates a lookup table
 * @param {String} ID the unique identifier of this lookup table in the system
 * @param {JSON} the JSON object that contains the lookup table entries. This JSON should follow Voxelent's syntax
 */
vxlLookupTable.prototype.load = function(ID,payload){
	this.ID = ID;
	this.map = payload;
	for (var key in this.map) {
		var n = Number(key);
		if (n < this.min) {this.min = n;}
		else if (n >= this.max) {this.max = n;}
    }
}

/**
 * Performs the lookup table value scaling to find the appropriate index according to the
 * number of entries and the extension of the scalar map determined by <code>min</code> and <code>max</code>
 */
vxlLookupTable.prototype._scale = function(value, min,max){
    return  value * this.max / max;
}


/**
 * Gets the correspondent color. To obtain the right entry, the scale method should be called first.
 */
vxlLookupTable.prototype.getColor = function(val, min, max){
    var value = this._scale(val, min,max);
	
	var l = this;
	var key = Math.round(value);
	
	if (key >= l.min && key <= l.max){
	    var c = [l.map[key][0],l.map[key][1],l.map[key][2]];
		return c;
	}
	
	else if (key <l.min) { //truncate to min value
			return  [l.map[l.min][0],l.map[l.min][1],l.map[l.min][2]];
	}
	
	else if (key>l.max){ //truncate to max value
		return  [l.map[l.max][0],l.map[l.max][1],l.map[l.max][2]];
	}
	
	else{
		alert('assertion error in getColor routine');
		return  [l.map[l.min][0],l.map[l.min][1],l.map[l.min][2]];
	}
		
}

/**
*
*	@param s array with scalar data
*	@param max range
*	@param min range
*	@returns unpacked colors translated through this lookup table 
*/
vxlLookupTable.prototype.getColors = function(s,min,max){
	var c = [];
	
	for(var i=0;i<s.length;i++){
		var cc = this.getColor(s[i], min, max);
		c.push(cc[0]);
		c.push(cc[1]);
		c.push(cc[2]);
	
	}
	
	return c;
}
/**
 * Manages the lookup table files. The constructor will try to load all
 * the lookup tables defined in vxl.def.luts at once.
 * 
 * @class Manages the lookup tables
 * @constructor
 */
function vxlLookupTableManager(){
	this.lutTimerID = 0;
	this._hashmap = {};
	this.location = "";
	vxl.go.notifier.publish(vxl.events.DEFAULT_LUT_LOADED,this);
};

vxlLookupTableManager.prototype.setLocation = function(loc){
	this.location = loc;
}

/**
 * Load a lookup table file
 * @param {String} name the filename of the lookup table to load
 */
vxlLookupTableManager.prototype.load = function(name){
		var self = this;
		if (this.isLoaded(name)) return;

	    var request = new XMLHttpRequest();
	    request.open("GET", this.location+'/'+name+'.lut');
	    request.onreadystatechange = function() {
	      if (request.readyState == 4) {
		    if(request.status == 404) {
				alert (name + ' does not exist');
				vxl.go.console('LookupTableManager: '+name + ' does not exist');
			 }
			else {
				self.handle(name,JSON.parse(request.responseText));
			}
		  }
	    };
		request.send();
};
/**
 * Once the lookup table file is retrieved, this method adds it to the lookup table manager
 */
vxlLookupTableManager.prototype.handle = function (ID, payload) {
	var lut = new vxlLookupTable();
	lut.load(ID,payload);
	this._hashmap[ID] = lut;
	
	if (lut.ID == vxl.def.lut.main){
		vxl.go.notifier.fire(vxl.events.DEFAULT_LUT_LOADED, this);
	}
};
/**
 * Check if a lookup table has been loaded by this lookup table manager
 * @param {String} ID the id of the table to check
 */
vxlLookupTableManager.prototype.isLoaded = function(ID){
	return this._hashmap[ID] != undefined;
};

/**
 * Retrieves a lookup table
 * @param {String} ID id of the lookup table to retrieve
 */
vxlLookupTableManager.prototype.get = function(ID){
	return this._hashmap[ID];
};

/**
 * Returns a list with the names of all of the lookup tables that have been loaded.
 * @returns {Array} an array with the names of the lookup tables that have been loaded
 */
vxlLookupTableManager.prototype.getAllLoaded = function(){
    var tables = [];
    for(lut in this._hashmap){
        tables.push(this._hashmap[lut].ID);
    }
    return tables;
};

/**
 * Checks if all the lookup tables have been loaded
 */
vxlLookupTableManager.prototype.allLoaded = function(){
    var size = 0;
	for(lut in this._hashmap){
        size++;
    }
	return (vxl.def.lut.list.length == size);
};

/**
 * Loads all the lookup tables defined in vxl.def.luts
 */
vxlLookupTableManager.prototype.loadAll = function(){
	for(var i=0;i<vxl.def.lut.list.length;i++){
		this.load(vxl.def.lut.list[i]);
	}
};

/**
 * Creates the global lookup table manager and load all the lookup tables at once
 */
vxl.go.lookupTableManager = new vxlLookupTableManager();
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  


vxl.def.model.boundingBox = new vxlModel();
vxl.def.model.boundingBox.load(
    'bounding box', 
    { "vertices" : [],
      "wireframe":[0,1,1,2,2,3,3,0,0,4,4,5,5,6,6,7,7,4,1,5,2,6,3,7], 
      "color":[1.0,1.0,1.0,1.0],
      "shading": false
    });

//vxlBoundingBox IS a vxlActor                                               
vxlBoundingBox.prototype = new vxlActor();
vxlBoundingBox.prototype.constructor = vxlBoundingBox;

/**
 * @class Cuboid that encloses the visible extent of a vxlScene
 * @constructor
 * @extends vxlActor
 */
function vxlBoundingBox() {
	vxlActor.call(this, vxl.def.model.boundingBox);
	this.bb 		= this.setBoundingBox([-1,-1,-1,1,1,1]);
    this.mode 		= vxl.def.actor.mode.WIREFRAME;
    this.visible 	= false;
    this.toy    	= true;
};

/**
* Sets the bounding box
* @param {Array} b the bounding box. The format of this param should be [x1,y1,z1,x2,y2,z2]
* where x1,y1,z1 correspond to the minimum bounding coordinates and x2,y2,z2 correspond to the
* maximum bounding coordinates
*/
vxlBoundingBox.prototype.setBoundingBox = function(b){
	this.bb = [
		b[0], b[1], b[2],
		b[0], b[4], b[2],
		b[3], b[4], b[2],
		b[3], b[1], b[2],
		b[0], b[1], b[5],
		b[0], b[4], b[5],
		b[3], b[4], b[5],
		b[3], b[1], b[5] 
		];
        
    this.model.vertices = this.bb;
};



/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 


vxl.def.model.axis = new vxlModel();
vxl.def.model.axis.load('axis', {
                    	"vertices": [	-1, 0, 0, 	 1, 0, 0, 	 0,-2, 0,	 0, 2, 0,	 0, 0,-1,	 0, 0, 1	],
                    	"wireframe": [ 	0, 1, 	2, 3, 	4, 5	],
                    	"colors": [	1, 0, 0, 	  1, 0, 0, 	0, 1 ,0, 	 0, 1 ,0,   0, 0, 1,	 0, 0, 1 	],
                    	"shading": false
                    	});
 

vxlAxis.prototype 				= new vxlActor();
vxlAxis.prototype.constructor 	= vxlAxis;

/**
 * @class Visible three-dimensional system of coordinates 
 * @constructor
 * @author Diego Cantor
 */
function vxlAxis() {
	vxlActor.call(this,vxl.def.model.axis);
	this.centre 	= [0,0,0];
	this.mode 		= vxl.def.actor.mode.WIREFRAME;
	this.visible 	= false;
	this.toy     	= true;
};


/**
* Sets the centre of the axis actor in the scene
*/
vxlAxis.prototype.setCentre = function (ctr){
    var x = ctr[0];
	var y = ctr[1];
	var z = ctr[2];
	
	this.centre[0] = x;
	this.centre[1] = y;
	this.centre[2] = z;
    
    var ver = this.model.vertices;
	
	ver[0] = x-1;
	ver[1] = y;
	ver[2] = z;
	
	ver[3] = x+1;
	ver[4] = y;
	ver[5] = z;
	
	ver[6] = x;
	ver[7] = y-2;
	ver[8] = z;
	
	ver[9] = x;
	ver[10] = y+2;
	ver[11] = z;
	
	ver[12] = x;
	ver[13] = y;
	ver[14] = z-1;
	
	ver[15] = x;
	ver[16] = y;
	ver[17] = z+1;
};/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  


vxl.def.model.floor = new vxlModel();
vxl.def.model.floor.load('floor',{"vertices":[],"indices":[],"color":[1.0,1.0,1.0,1.0],"shading": false});

vxlFloor.prototype = new vxlActor();
vxlFloor.prototype.constructor = vxlFloor;

/**
 * @class Visible grid that sets the floor reference and its extension
 * @constructor
 * @extends vxlActor
 */
function vxlFloor(){
	vxlActor.call(this, vxl.def.model.floor);
	this.mode 		= vxl.def.actor.mode.WIREFRAME;
    this.visible 	= false;
    this.toy    	= true;
};

/**
 * Creates the grid
 */
vxlFloor.prototype.setGrid =function(dimension, spacing){

	var dim = dimension;
    var lines = 2*dim/spacing;
    var inc = 2*dim/lines;
    var v = [];
    var i = [];

    for(var l=0;l<=lines;l++){
        v[6*l] = -dim; 
        v[6*l+1] = 0;
        v[6*l+2] = -dim+(l*inc);
        
        v[6*l+3] = dim;
        v[6*l+4] = 0;
        v[6*l+5] = -dim+(l*inc);
        
        v[6*(lines+1)+6*l] = -dim+(l*inc); 
        v[6*(lines+1)+6*l+1] = 0;
        v[6*(lines+1)+6*l+2] = -dim;
        
        v[6*(lines+1)+6*l+3] = -dim+(l*inc);
        v[6*(lines+1)+6*l+4] = 0;
        v[6*(lines+1)+6*l+5] = dim;
        
        i[2*l] = 2*l;
        i[2*l+1] = 2*l+1;
        i[2*(lines+1)+2*l] = 2*(lines+1)+2*l;
        i[2*(lines+1)+2*l+1] = 2*(lines+1)+2*l+1;        
    }
    this.model.vertices = v.slice(0);
    this.model.wireframe = i.slice(0);
    this.visible = true;
};




/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  

/**
* Each HTML5 canvas is assigned a view object (vxlView) in Voxelent's Nucleo.
* 
* A vxlView provides the code to handle cameras, interaction and rendering capabilities, plus actor handling on the 
* HTML5 canvas that otherwise would need to be written over and over for each application
* if you were writing a WebGL app from scratch.
* Luckily this is not the case. You have the awesome vxlView who takes care of all these little details for you.
* @class the class that manages what it is rendered the HTML5 canvas on the web page 
* @constructor
* @param {String} canvasID id of the canvas in the DOM tree. That's all we need to setup a vxlView for you
* @param {vxlScene} scene if this view is sharing a scene, this parameter corresponds to the scene being shared.
* @param {Boolean} handleLayout if true or absent, the canvas will be resized dynamically
* @author Diego Cantor
*/

function vxlView(canvasID, scene, handleLayout){

	//this.id = 0; //@TODO: Who handles this? Maybe one Scene has several Views?
	
	this.canvas = document.getElementById(canvasID);
	
	if (this.canvas == null){
		alert('View: the canvas ' + canvasID+ ' does not exist.');
		throw('View: the canvas ' + canvasID+ ' does not exist.');
	}
	
	this.name = canvasID;
	
    //View dimensions
	this.width = this.canvas.width;
	this.height = this.canvas.height;
	
	//Clear depth and background color
	this.clearDepth = 1.0;
	this.backgroundColor = vxl.def.view.background.slice(0);
	
	//Drag and drop
	this.dragndrop = false;

	//Create Renderer
	this.renderer = new vxlRenderer(this);
	this.setBackgroundColor(this.backgroundColor);
	this.setClearDepth(this.clearDepth);
	
	//Create Camera Manager
	this.cameraman = new vxlCameraManager(this);
	
	//Create View Interactor
	this.interactor = new vxlTrackerInteractor();
	
	this.interactor.connectView(this);
	
	//Create Scene
	if (scene != null && scene instanceof vxlScene){
		this.scene = scene;
	}
	else if (vxl.c.scene != undefined){
		this.scene = vxl.c.scene;
	}
	else{
		this.scene = new vxlScene();
	
	}
	//Add this view to the scene;
	this.scene.views.push(this);
	
	if (vxl.c.view == undefined){
		vxl.c.view = this;
	}
	
	vxl.go.views.push(this);
	
	if (handleLayout == undefined){
	    handleLayout = true;
	}
	
	this.setAutoResize(handleLayout);
	
	this.UID = vxl.util.generateUID();


    var ntf = vxl.go.notifier;
    var e   = vxl.events;
    ntf.publish(e.VIEW_NEW, this);
    ntf.subscribe(e.DEFAULT_LUT_LOADED,this);
    ntf.fire(e.VIEW_NEW, this);

	vxl.go.console('View: the view '+ this.name+' has been created');
};


/**
 * Handles the events to which a view is subscribed in Voxelent's Nucleo
 * @param {String} event the name of the event
 * @param {Object} source the origin of the event. Useful to do callbacks if necessary
 */
vxlView.prototype.handleEvent = function(event, source){
	vxl.go.console('vxlView ['+this.name+']: receiving event '+event);
	if (event == vxl.events.DEFAULT_LUT_LOADED){
		this.scene.setLookupTable(vxl.def.lut.main);
	}
};


/**
 * Clears the scene. Delegates this task to the renderer.
 */
vxlView.prototype.clear = function(){
	this.renderer.clear();
};

/**
 * It creates a div around the canvas to handle resizing appropriately
 * @private 
 */
vxlView.prototype._wrapDiv = function(){
    
    $(this.canvas).css({
        position: 'absolute',
        height: 'auto',
        bottom: 0,
        top: 0,
        left: 0,
        right: 0,
        margin: "5px"
    });
    
    $(this.canvas).wrap('<div id='+this.name+'-wrapper />');
    $('#'+this.name+'-wrapper').css({
       width:'100%',
       height:'100%' 
    });
    
    this.canvas.focus();
}

/**
 * Resizes the canvas so it fits its parent node in the DOM tree
 */
vxlView.prototype.resize = function(){
    var parent = this.canvas.parentNode;
    this.width = $(parent).width()-5;       
    this.height = $(parent).height()-5;
    
    if (this.width > window.innerWidth - 5){
    	this.width = window.innerWidth -5;
    }
    
    if (this.height > window.innerHeight - 5){
    	this.height = window.innerHeight - 5;
    }
    
    $(this.canvas).attr('width', this.width);
    $(this.canvas).attr('height', this.height);
}

/**
 * Enables automatic resizing of the view when the browser window is resized
 * @param flag enbles automatic resizing if true, disables it if false
 */
vxlView.prototype.setAutoResize = function(flag){
    
    if (flag){
         this._wrapDiv();
         this.resize(); //first time
        $(window).resize((function(self){return function(){self.resize();}})(this));
    }
    else{
        $(window).unbind('resize');
    }
};


/**
 * Run non standard code (mozilla, webkit) 
 *@private 
 */
vxlView.prototype._runPrefixMethod = function(obj,method){
    
    var pfx = ["webkit", "moz", "ms", "o", ""];
    var p = 0, m, t;

    while (p < pfx.length && !obj[m]) {
        m = method;
        if (pfx[p] == "") {
            m = m.substr(0,1).toLowerCase() + m.substr(1);
        }
        m = pfx[p] + m;
        t = typeof obj[m];
        if (t != "undefined") {
            pfx = [pfx[p]];
            return (t == "function" ? obj[m]() : obj[m]);
        }
        p++;
    }
};

/**
 * Handles HTML5 Full screen for this view 
 * @param {Boolean} flag set flag to true if fullscreen is wanted. Set it to false to exit fullscreen.
 */
vxlView.prototype.fullscreen = function(flag){
    if (flag == true){
        this._runPrefixMethod(this.canvas, "RequestFullScreen");
    }
    else{
        if (this._runPrefixMethod(document,"FullScreen") || 
            this._runPrefixMethod(document,"isFullScreen")){
            this._runPrefixMethod(document,"CancelFullScreen");
        }    
    }

};


/**
 * Starts the view
 */
vxlView.prototype.start = function(){
	this.renderer.start();
	this.refresh();
};

/**
 * Stops the view
 */
vxlView.prototype.stop = function(){
	this.renderer.stop();
};

/**
 * Resets the view
 */
vxlView.prototype.reset = function(){
	this.stop();
	this.scene.reset();
	this.cameraman.reset();
	this.start();
};

/**
 * Sets the view's background color
 * @param {Number, Array, vec3} r it can be the red component, a 3-dimensional Array or a vec3 (glMatrix)
 * @param {Number} g if r is a number, then this parameter corresponds to the green component
 * @param {Number} b if r is a number, then this parameter corresponds to the blue component
 
 * @see vxlRenderer#clearColor
 */
vxlView.prototype.setBackgroundColor = function(r,g,b){
	this.backgroundColor = vxl.util.createColor(r,g,b); 
	this.renderer.clearColor(this.backgroundColor);
};


/**
 * Sets the clear depth
 * @param {Number} d the new depth
 * @see vxlRenderer#clearDepth
 */
vxlView.prototype.setClearDepth = function(d){
	this.renderer.clearDepth(d);
};

/**
 * Refresh the view 
 * @see vxlRenderer#render
 */
vxlView.prototype.refresh = function(){
	this.renderer.render();
};

/**
 * Uses the interactor passed as parameter to handle user gestures
 * @param {vxlViewInteractor} interactor an instance of a vxlViewInteractor
 * 
 */
 vxlView.prototype.setInteractor = function(i){
    this.interactor = i;
    this.interactor.connectView(this);
};

/**
 *Sets the drag and drop flag 
 * @param {Boolean} flag
 */
vxlView.prototype.setDragAndDrop = function(flag){
    this.dragndrop = flag;
};

/**
 * Get FPS metric from the view renderer
 */
vxlView.prototype.getFPS = function(){
    return this.renderer.fps;
    
};
/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   
/**
 * Creates vxlModel objects and assigns them to a vxlScene. 
 * 
 * vxlModelManager provides methods for loading remote and local models.
 * 
 * 
 * @class Controls the loading and network transfer of models into memory
 * @constructor
 * @author Diego Cantor
 */
function vxlModelManager(){
	this.toLoad = []; 
	this.models = [];
	
	var e = vxl.events;
	vxl.go.notifier.publish([
	       e.MODELS_LOADING,
	       e.MODEL_NEW,
	       e.MODELS_LOADED
	    ],this);
	vxl.go.notifier.subscribe(e.READER_DONE, this);
};

/**
 * Handles voxelent events to which this model manager is subscribed to
 * @param {String} event the event that was fired 
 * @param {Object} source the object that fired the event 
 */
vxlModelManager.prototype.handleEvent = function(event,source){
    var reader = source;
    var parts = reader.getParts();
    for (var i = 0; i < parts.length; i+=1){
        this.add(parts[i],parts[i].name,reader.scene);
    }
}


/**
 * Uses a JSON/Ajax mechanism to load models from a Web Server.
 * @param {String} uri The path to the file that will be loaded. 
 * @param {vxlScene} scene The scene that will create an actor for this model. This parameter is optional.
 */  
vxlModelManager.prototype.load = function(uri, scene) {
    var manager = this;
    
    var filename = uri.replace(/^.*[\\\/]/, '');
    var modelname = filename.split('.')[0];
    var extension = filename.split('.')[1];
	
	var dtype = 'json';
	
	if (manager.isModelLoaded(modelname)) return;
	
	
	if (extension == 'vtk'){
	    dtype ='text';
	}
	else if (extension == 'json'){
	    dtype = 'json'
	}
	else{
	    alert ('vxlManager.load ERROR: Unknown filetype ['+extension+']');
	    throw ('vxlManager.load ERROR: Unknown filetype ['+extension+']');
	}
	   
	nocacheuri = uri +'?nocache=' + (new Date()).getTime();
	
	
	vxl.go.console('ModelManager.load: Requesting '+uri+'...');
	vxl.go.notifier.fire(vxl.events.MODELS_LOADING, this);
	
	var successHandler = function(manager,modelname,scene){
	    switch(extension){
	    case 'json':
    		return function(json, textStatus){
    		    json.uri = filename;
    		    json.path = vxl.util.getPath(uri)
    			manager.add(json,modelname,scene);
    		}
    		break;
    	case 'vtk':
		    return function(data){
		        reader = new vxlVTKReader(scene)
		        reader.parseText(modelname, data)
		    }
		 }
	};
	
	var errorHandler = function(uri){
		return function(request, status, error){
			
			if(error.code = 1012){
				alert('The file '+uri+' could not be accessed. \n\n'+
    			'Please make sure that the path is correct and that you have the right pemissions');
			}
			else{
				alert ('There was a problem loading the file '+uri+'. HTTP error code:'+request.status);
			}		
		}
	};
	
	var request  = $.ajax({
		url			: nocacheuri,
		type		:"GET",
		dataType	: dtype,
		success 	: successHandler(manager,modelname,scene),
		error		: errorHandler(uri)
	});    
};

/**
 * Loads a list of models and assigns them to a scene
 * @param {Array} list list of files to load 
 * @param {vxlScene} scene scene to callback when the models are loaded 
 */
vxlModelManager.prototype.loadList = function(list,scene){
	this.toLoad = list.slice(0); 
	vxl.go.console('ModelManager.loadList: models to load ->' + this.toLoad.length);
   	for(var i=0;i<this.toLoad.length; i++){
		this.load(this.toLoad[i],scene);
   	}
};

/**
 * 
 * @param {Object} JSON_OBJECT the JSON object that contains the definition of the model
 * @param {String} name name of the model to be created
 * @param {vxlScene} scene the scene to be called back when the model is created
 */
vxlModelManager.prototype.add = function(JSON_OBJECT,name,scene){
	
	var self = this;
	
	function scheduledAdd(){
	
    	
    	var model = new vxlModel(name, JSON_OBJECT);
    	
    	model.loaded = true;
    	self.models.push(model);
    	self.toLoad.splice(name,1); //removes it from the pending list if exists
    	
    	vxl.go.console('ModelManager: model '+model.name+' created.'); 
    	
    	if (scene != undefined && scene instanceof vxlScene){
    		vxl.go.console('ModelManager: notifying the scene...');
    		if (scene.loadingMode == vxl.def.model.loadingMode.LIVE){
    			scene.createActor(model);
    		}
    		else if (scene.loadingMode == vxl.def.model.loadingMode.LATER){
    			if(self.allLoaded()){
    				scene.createActors(self.models);
    			}
    		}
    		else if (scene.loadingMode == vxl.def.model.loadingMode.DETACHED){
    			//do nothing
    		}
    	}
        
    	if(self.allLoaded()){ 
    		vxl.go.notifier.fire(vxl.events.MODELS_LOADED, self);
    	}
    	else{
    	    vxl.go.notifier.fire(vxl.events.MODEL_NEW, self);
    	}
	}
	
	setTimeout(function(){scheduledAdd()},0);
 };
 
/**
 * It will delete all of the loaded models
 */  
vxlModelManager.prototype.reset = function(){
	this.firstLoadedModel = false;
	for (var i=0; i <this.models.length; i++){
		this.models[i] = null;
	}
	
	this.models        = [];
	this.toLoad        = [];
};

/**
 * Checks if a model has been loaded yet
 * @param {String} name the name of the model to check
 */
vxlModelManager.prototype.isModelLoaded = function(name){
	for(var i=0;i<this.models.length;i++){
		if (this.models[i].name == name) return true;
	}
	return false;
};

/**
 * Returns true if all the models in the list passed to the method loadList have been loaded.
 */
vxlModelManager.prototype.allLoaded = function(){
	return (this.toLoad.length == 0);
};


/**
 * Returns the model if it has been loaded by this model manager, null otherwise.
 * @param {String} name the name of the model to retrieve
 */
vxlModelManager.prototype.getModelByName = function(name){
 	for(var i=0, max = this.models.length; i<max; i+=1){
		if (this.models[i].name == name) return this.models[i];
	}
	return null;
};

/**
 * Defines the global Model Manager 
 */
vxl.go.modelManager = new vxlModelManager();/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 
/**
 * @namespace Application Programing Interface namespace.
 *  
 * Using vxl.api in your programs you will be able to access many of the features offered by 
 * Voxelent's Nucleo library.
 * 
 * By design, type checking is enforced throughout the functions provided by the public API. 
 * The goal is to help novice programmers that will use the API more often than advanced programmers.
  */
vxl.api = {
 
 /**
  * Creates and returns a vxlView object
  * @param {String} canvas_id The canvas' Document Object Model (DOM) id.
  * @param {vxlScene} scene optional, the scene associated to this view
  * @param {Boolean} handleLayout if true or absent, the canvas will be resized dynamically
  * @returns {vxlView} a new vxlView object
  */
 setup : function(canvas_id, scene, handleLayout){
 	if (scene != null && !(scene instanceof vxlScene)) throw ('api.setup: scene parameter is invalid');
 	return new vxlView(canvas_id,scene,handleLayout);
 },
  
  /**
   * Sets the rendering rate of the current view
   * @param {Number} r the new rendering rate given as a number in milliseconds
   * @see api#setCurrentView
   */
 setRenderRate : function(r){
	vxl.c.view.renderer.setRenderRate(r);
  },
  
  /**
   *Sets the render mode for the current view or the view passed as second
   * parameter 
   * @param {String} mode one of the modes defined in <code>vxl.def.renderer.mode</code>
   * @param {vxlView} view the view (Optional) If this is not set up then the current view is used
   */
  setRenderMode : function(mode, view){
      if (view == undefined && vxl.c.view == undefined){
          throw ('api.setRnederMode: you need to define a view');
      }
      else if (view != undefined && view instanceof vxlView){
          view.renderer.setMode(mode);
      }
      else {
          vxl.c.view.renderer.setMode(mode);
      }
      
  },
  /**
   *Changes the field of view of the current camera
   * 
   * @param{Number} fov the field of view in degrees [0-360] 
   */
  setFieldOfView : function(fov){
      if (fov >0 && fov <= 360){
        vxl.c.camera.setFieldOfView(fov);
      }
      else{
          throw('api.setFieldOfView: the field of view should be between 0 and 360 degrees');
      }
  },
 
 /**
  * If the object passed as a parameter is a vxlView then it sets it up as the current view.
  * All subsequent calls to API functions that reference the current view will be redirected
  * to affect the newly set object.
  * @param {a} the vxlView object that we want to make the current one
  */
 setCurrentView :  function(a){
	if (a instanceof vxlView){
		vxl.c.view = a;
	}
 },

 /**
  * Returns the current view. This is the view that is receiving all the API calls
  * @returns {vxlView} the current view
  */
 getCurrentView :  function(){
	return vxl.c.view;
 },
 
 
 /**
  * Sets the current actor
  * @param {vxlActor, String} actor This could be an actor object or an actor name
  * 
  * If the actor name is passed to this method, there must be a current scene. 
  * Otherwise an exception will raise.
  */
 setCurrentActor :  function(actor){
	if (actor instanceof vxlActor){
		vxl.c.actor = actor;
	}
	else if (typeof actor == 'string'){
		if (vxl.c.scene == undefined) throw ('vxl.api.setCurrentActor: there is no Current scene. Please call vxl.api.setCurrentScene');
		
		var theActor = vxl.c.scene.getActorByName(actor);
		if (theActor != undefined){
			vxl.c.actor = theActor;
		}
		else {
			throw ('vxl.api.setCurrentActor: the actor '+actor+' does not exist in the current scene');
		}
	}
	else{
	    vxl.c.actor = actor;
	}
 },
 
 getCurrentActor :  function(){
	return vxl.c.actor;
 },

 setCurrentCamera :  function(a){
	if (a instanceof vxlCamera){
		vxl.c.camera = a;
	}
 },
 
 getCurrentCamera :  function(){
	return vxl.c.camera;
 },

 setLookupTable :  function(name){
 	if (!vxl.go.lookupTableManager.isLoaded(name)){
		vxl.go.console('Lookup Table '+name+' has not been loaded');
		return;
	}
	
	vxl.c.view.scene.setLookupTable(name);
 },
 
 /**
  *@param {String} folder. This parameter is required. It specifies the location from where
  * the lookup tables will be loaded. If this parameter is not passed the current folder will
  * be used. The current folder is determined on running time and it is the folder where voxelent is 
  * located.
  */
 loadLUTS :  function(folder){
 	vxl.go.lookupTableManager.setLocation(folder);
	vxl.go.lookupTableManager.loadAll();
 },

 /**
  * Go back to square one. A clean scene with no actors
  * @TODO: Provide the option to keep the models in the cache (vxlModelManager)
  */
 resetScene :  function(){
    if (vxl.c.animation) vxl.c.animation.stop();
	vxl.c.view.reset();
	vxl.go.modelManager.reset();
 },
 
 /**
  * Loads 3D models, textures and other models to a Voxelent's scene.
  * 
  * This method is very flexible. It can load one or multiple models depending on the type of the 
  * first parameter. If it is a String, it will try to find the file with that name in Voxelent's data folder
  * (voxdata by default). Otherwise, if  the parameter 'arguments' is an Array, load will iterate
  * through it and will try to load every element of this list. Every element being the file name.
  * 
  * Nucleo supports three different loading modes which are defined in 
  * vxl.def.model.loadingMode:
  * 
  * LIVE: As each asset is loaded it is added immediately into the scene by creating the corresponding actor
  * 
  * LATER: All the models are loaded first THEN the actors are created. 
  * This is useful when you want to display a full scene instead of showing incremental updates.
  * 
  * DETACHED: The models are loaded into the vxlModelManager object but actors are never created.
  * This allows background loading.
  * 
  * @param {String|Array} arguments the name of the asset or the list of models (each element being the file name).
  * @param {String} path the path that will be concatenated to the list of files (optional).
  * @param {vxl.def.model.loadingMode} mode the loading mode
  * @param {vxlScene} scene the scene in case we do not want to load these models in the current one
  * 
  * @see {vxl#def#asset#loadingMode}
  * @see {vxlAssetManager}
  * @see {vxlScene#setLoadingMode}
  * 
  */
 load :  function(arguments,path,mode,scene){
 	
 	var scene = scene==null?vxl.c.scene:scene;
 	var models = [];
 	
 	var p = vxl.util.getPath(path);
 	
 	if (typeof(arguments) == 'string' || arguments instanceof String){
 		models.push(p  + arguments);
 	}
 	else if (arguments instanceof Array){
 		for(var i=0; i<arguments.length;i++){
			models.push(p + arguments[i]);
		}
 	}
 	if (mode != undefined && mode != null){
		scene.setLoadingMode(mode);
	}
	
	vxl.go.modelManager.loadList(models, scene);
 },
 
 /**
  * Loads a sequence
  * @param {String} prefix the shared name by all the files. For instance part in part1, part2, ...
  * @param {Number} start start number in the sequence
  * @param {Number} end end number in the sequence
  * @param {String} path relative path to the webpage where the files are located
  * @param {String} mode a loading mode (See load method)
  * @param {String} scene the scene where the generated actors should be placed
  */
 loadSequence :  function(prefix, start, end, path,mode,scene){
    
    var scene = scene==null?vxl.c.scene:scene;
    var models = [];
    
    var p = vxl.util.getPath(path);
    
    for(var i=start;i<=end; i+=1){
        models.push(p + prefix+i+'.json');
    }
    if (mode != undefined && mode != null){
        scene.setLoadingMode(mode);
    }
    
    vxl.go.modelManager.loadList(models, scene);
 },
 
 /**
  * Activates the axis in the current view
  * The axis is always centered in the focal point of the camera
  */
 axisON :  function(){
    if (vxl.c.scene == undefined){
       throw ('vxl.api.axisON: There is no current scene');
    }
	vxl.c.scene.toys.axis.setVisible(true);
	vxl.c.camera.refresh();
 },
 
 /**
  * Hides the axis in the current view
  */
 axisOFF :  function(){
    if (vxl.c.scene == undefined){
        throw ('vxl.api.axisOFF: There is no current scene');
    }
	vxl.c.scene.toys.axis.setVisible(false);
	vxl.c.camera.refresh();
 },
 
 /**
  * Shows the global bounding box of the current scene 
  * @TODO: move the bounding box to the scene object
  */
 boundingBoxON :  function(){
    if (vxl.c.scene == undefined){
        throw ('vxl.api.boundingBoxON: There is no current scene');
    } 
	vxl.c.scene.toys.boundingbox.setVisible(true);
	vxl.c.camera.refresh();
 },
 
  /**
  * Shows the global bounding box of the current scene 
  * @TODO: move the bounding box to the scene object
  */
 boundingBoxOFF:  function(){
    if (vxl.c.scene == undefined){
        throw ('vxl.api.boundingBoxOFF: There is no current scene');
    }
	vxl.c.scene.toys.boundingbox.setVisible(false);
	vxl.c.camera.refresh();
 },
 
/**
 * Shows the scene's floor. If the dimension and spacing have not been set, then the floor wiill not be visible'
 * @param{NUmber} dimension the floor dimension (this number will be multiplied by 2 to cover the negative cartesian space)
 * @param{Number} spacing the spacing tells how often we have grid divisions
 */
floorON: function(dimension, spacing){
    if (vxl.c.scene == undefined){
        throw ('vxl.api.floorON: There is no current scene');
    }
    if (dimension == undefined || spacing == undefined){
        vxl.c.scene.toys.floor.setVisible(true);
    }
    else{
        vxl.c.scene.toys.floor.setGrid(dimension, spacing);
    }
    vxl.c.camera.refresh();   
},

/**
 * Hides the floor in the current scene 
 */
floorOFF: function(){
    if (vxl.c.scene == undefined){
        throw ('vxl.api.floorOFF: There is no current scene');
    }
    vxl.c.scene.toys.floor.setVisible(false);
    vxl.c.camera.refresh();
},
 

/**
 * Sets the background color of the current view.
 * @param {Number, Array, vec3} r it can be the red component, a 3-dimensional Array or a vec3 (glMatrix)
 * @param {Number} g if r is a number, then this parameter corresponds to the green component
 * @param {Number} b if r is a number, then this parameter corresponds to the blue component
 */ 
 setBackgroundColor :  function(r,g,b){
	vxl.c.view.setBackgroundColor(r,g,b);
 },



/**
 * If an actor has been selected (If there is an current actor in vxl.c.actor), 
 * changes its visualization mode to WIREFRAME. 
 * Otherwise,shows all the scene in WIREFRAME mode.
 * 
 * @see vxl.def.actor.mode
 */ 
wireframeON :  function(){
	if (vxl.c.actor){
		vxl.c.actor.setVisualizationMode(vxl.def.actor.mode.WIREFRAME);
	}
	else {
		vxl.c.scene.setVisualizationMode(vxl.def.actor.mode.WIREFRAME);
	}
	vxl.go.console('API:Wireframe is shown.');
 },
 
 /**
  * Changes the visualization mode of the current actor (or all the actors if there's no current actor')
  * to a solid representation
  * @see vxl.def.actor.mode
  */
 surfaceON :  function(){
	if (vxl.c.actor){
		vxl.c.actor.setVisualizationMode(vxl.def.actor.mode.SOLID);
	}
	else {
		vxl.c.view.scene.setVisualizationMode(vxl.def.actor.mode.SOLID);
	}
	vxl.go.console('API:Wireframe is hidden.');
 },
 
 /**
  * Changes the visualization mode of the current actor (or all the actors if there's no current actor')
  * to a point representation
  * @see vxl.def.actor.mode
  */
 pointsON :  function(){
	if (vxl.c.actor){
		vxl.c.actor.setVisualizationMode(vxl.def.actor.mode.POINTS);
	}
	else {
		vxl.c.view.scene.setVisualizationMode(vxl.def.actor.mode.POINTS);
	}
 },
 
  /**
  * Changes the visualization mode of the current actor (or all the actors if there's no current actor')
  * to a solid representation
  * @see vxl.def.actor.mode
  */
 solidWireframeON :  function(){
    if (vxl.c.actor){
        vxl.c.actor.setVisualizationMode(vxl.def.actor.mode.WIRED_AND_SOLID);
    }
    else {
        vxl.c.view.scene.setVisualizationMode(vxl.def.actor.mode.WIRED_AND_SOLID);
    }
    vxl.go.console('API:Wireframe is hidden.');
 },
 /**
  * Returns a list of actor names. 
  * @param {vxlScene} scene the scene. This parameter is optional 
  */
 getActorNames : function(scene){
    var _scene = scene;
    if (_scene == undefined){ //look in the current scene
        if (vxl.c.scene == undefined){
            throw ('vxl.api.getActorNames: There is no current scene');
        }
        else{
            _scene = vxl.c.scene;
        }
    }
    return _scene.getActorNames();
 },
 
 /**
  *Creates an actor group for the current scene
  * @param {String} name name of the actor group
  * @param {List} list list of actors to add to the actor group
  * @returns {vxlActorGroup} the actor group
  * @see {vxlScene#createActorGroup} 
  */
 createActorGroup: function(name, list){
     return vxl.c.scene.createActorGroup(name, list);
 },
 
 /**
  *Retrieves an actor by name or UID
  * @param {String} actorNameOrUID actor name or UID
  * @param {vxlScene} scene looks in the specified scene. This parameter is optional. 
  * If not specified, the current scene (vxl.c.scene) will be queried
  */
 getActor: function(actorNameOrUID, scene){
     var actor = this.getActorByName(actorNameOrUID, scene);
     
     if (actor == null){
         actor = this.getActorByUID(actorNameOrUID, scene);
     }
     return actor;
 },
 /**
  * Retrieves an actor object by UID
  * @param {String} actorUID the UID of the actor
  * @param {vxlScene} scene looks in the specified scene. This parameter is optional. 
  * If not specified, the current scene (vxl.c.scene) will be queried
  *  
  */
 getActorByUID :  function(actorUID,scene){
    var _scene = scene;
    if (_scene == undefined){ //look in the current scene
        if (vxl.c.scene == undefined){
            throw ('vxl.api.getActorByUID: There is no current scene. Please the scene you want to look the actor with uid: '+UID+' into');
        }
        else{
            _scene = vxl.c.scene;
        }
    }
    
    return _scene.getActorByUID(actorUID);
 },
 /**
  * Retrieves an actor object by name
  * @param {String} actorName the name of the actor
  * @param {vxlScene} scene looks in the specified scene. This parameter is optional. 
  * If not specified, the current scene (vxl.c.scene) will be queried
  *  
  */
 getActorByName :  function(actorName,scene){
 	var _scene = scene;
 	if (_scene == undefined){ //look in the current scene
 		if (vxl.c.scene == undefined){
 			throw ('vxl.api.getActorByName: There is no current scene. Please the scene you want to look the actor '+actorName+' into');
 		}
 		else{
 			_scene = vxl.c.scene;
 		}
 	}
 	
 	return _scene.getActorByName(actorName);
 },
 
 /**
  * @param {Number} op  opacity value between 0 and 1 (float)
  * @TODO: Reevaluate this method. Opacity is shader dependent
  */
 setActorOpacity :  function(op){
    var opacity = Math.min(Math.max(0,Math.abs(op)),1);
	if (vxl.c.actor){
		vxl.c.actor.setOpacity(op);
	}
	else{
		vxl.c.view.scene.setOpacity(opacity);
	}
	vxl.c.view.refresh();
	vxl.go.console('API:Opacity changed to '+(op*100)+'%');
  },
  
 
 /**
  * Sets a property for one of the actors in the current scene.
  * This metod requires a current scene
  * @param {vxlActor, String} actor it can be a vxlActor or a String with the actor name
  * @param {String} property the property to change 
  * @param {Object} value the new value
  */
 setActorProperty :  function (actor, property, value){
	
	if (vxl.c.scene == undefined) throw ('vxl.api.setActorProperty: there is no current scene. Please call vxl.api.setCurrentScene');
	
	var scene = vxl.c.scene;
	var _actor = actor;
	if (_actor instanceof vxlActor){
		_actor.setProperty(property,value);
	}
	else{ //TODO: assuming string.VALIDATE!
		_actor = scene.getActorByName(_actor);
		if (_actor == undefined) throw 'The actor '+_actor+' does not belong to the current scene'
		_actor.setProperty(property,value);
	}
 },
 
 /**
  * Sets a property for all the actors 
  * @param {String} property the property to change 
  * @param {Object} value the new value
  * @param {vxlScene} scene the scene (optional). If this parameter is not passed the current scene is used 
  */
 setPropertyForAll : function (property, value, scene){
    var s = undefined; 
    if (vxl.c.scene == undefined && scene == undefined) throw ('vxl.api.setPropertyForAll: there is no current scene. Please call vxl.api.setCurrentScene');
    if (scene == undefined){
        s  = vxl.c.scene;
    }
    else {
        s = scene;
    }
    s.setPropertyForAll(property,value);         
 },
 
 
 /**
  * Sets a property for all the actors in the list 
  * @param {Array} list list of actors (String or vxlActor)
  * @param {String} property the property to change 
  * @param {Object} value the new value
  * @param {vxlScene} scene the scene (optional). If this parameter is not passed the current scene is used 
  */
 setPropertyFor : function(list, property, value, scene){
    var s = undefined; 
    if (vxl.c.scene == undefined && scene == undefined) throw ('vxl.api.setPropertyForAll: there is no current scene. Please call vxl.api.setCurrentScene');
    if (scene == undefined){
        s  = vxl.c.scene;
    }
    else {
        s = scene;
    }
    s.setPropertyFor(list,property,value);
 },
 
 /**
 * <p>Returns a list of actors based on the condition passed as parameter.</p>
 * <p>The condition is a function with the following signature:</p>
 * <p><code> condition(vxlActor): returns boolean</code></p>
 * <p>If the condition evaluates true then that actor is included in the results</p>
 * 
 * @param {function} condition the condition to evaluate in the actor list
 * @param {vxlScene} scene (Optional) If this parameter is not set, the current scene will be used
 * @returns {Array} list of actors 
 */
 getActorsThat : function(condition, scene){
    var s = undefined;
    if (vxl.c.scene == undefined && scene == undefined) throw ('vxl.api.setPropertyForAll: there is no current scene. Please call vxl.api.setCurrentScene');
    if (scene == undefined){
        s = vxl.c.scene;
    }
    else{
        s = scene;
    }
    return s.getActorsThat(condition);
 },
 
 /**
  * Flip the normals of the current actor or the whole scene if the current actor is undefined
  */
 flipActorNormals :  function (){
	if (vxl.c.actor){
		vxl.c.actor.flipNormals();
	}
	else{
		vxl.c.view.scene.flipNormals();
	}
	vxl.c.view.refresh();
 },
 
 /**
  *If there is an animation object (vxl.c.animation) then
  * it stops the animation 
  */
 stopAnimation :  function(){
	if(vxl.c.animation != null) vxl.c.animation.stop();
 },
 
 /**
  *If there is an animation object (vxl.c.animation) then 
  * it starts the animation 
  */
 startAnimation :  function(){
	if(vxl.c.animation != null) vxl.c.animation.start();
 },
 
 /**
  * If there is a vxlFrameAnimation object attached to the scene then it 
  * sets the current animation frame
  * @param {Number} f the animation frame index
  */
 setFrame :  function(f){
	if (vxl.c.animation == null) return;
	var a = vxl.c.animation;
	a.stop();
	if (f>=1){
		a.setFrame(f);
	}
	else{
		vxl.go.console('API:frame ' + f +' does not exist. Animation goes back to the beginning');
		a.setFrame(1);
	}
 },

 /**
  *Removes the current animation from the scene 
  */
 clearAnimation :  function(){
	if(vxl.c.animation){
		vxl.c.animation.stop();
		vxl.c.animation = null;
	}
 },
 /**
  * Resets the current camera
  */
 resetCamera :  function(){
	vxl.c.camera.reset();
 },
 
 /**
  * Saves the current camera state
  */
 saveCamera :  function(){
	vxl.c.camera.save();
 },
 
 /**
  * Retrieves the last saved camera state
  */
 retrieveCamera :  function(){
	vxl.c.camera.retrieve();
 },
 
 /**
  * Sets the azimuth of the camera
  * @param {Number} a azimuth
  */
 setAzimuth :  function(a){
	vxl.c.camera.setAzimuth(a);
 },
 
 /**
  * Sets the elevation of the camera
  * @param {Number} e elevation
  */
 setElevation :  function(e){
	vxl.c.camera.setElevation(e);
 },
 
 
 getLookupTables :  function(){
    return vxl.go.lookupTableManager.getAllLoaded();
 },
 
 //runScript :  function(file){
 //use JQuery here.
 //}
 

 //TODO: Wwork in progress... sorry for the mess.
 //buildProgramFromDOM: function(id,VERTEX_SHADER_DOM_ID,FRAGMENT_SHADER_DOM_ID){
 //       var vshader= document.getElementById(VERTEX_SHADER_DOM_ID);
        
     
 //},
  /**
  * Forces the renderer to use a specific program
  * @param{vxlView} view the view to configure
  * @param{Object} program a JSON object that defines the progrma to execute
  * @param{vxlEngine} engine (optional) the engine that the renderer should use to communicate with the program. T
  *                        
  */
 setProgram :  function(view,program,engine){
    view.renderer.setProgram(program,engine,true);
    
 },
 
 /**
  *Releases the program used by the view passed as parameter
  * @param{vxlView} view
  */
 releaseProgram: function(view){
     view.renderer.releaseProgram();
 },
 /**
  * Returns the name of the current program
  * @param {vxlView} view the view that we want to query. If this parameter is not passed,
  * the current view will be used (vxl.c.view) 
  */
 getProgram : function(view){
     if (view == undefined){
         view = vxl.c.view
     }
     if (view == undefined){
         throw ('vxl.api.getProgram: please indicate a view');
     }
     return view.renderer.pm._currentProgramID;
 },
 /**
  * Sets the default value for an uniform
  */
  setUniformDefault: function(programID, uniformID, value){
      vxl.c.view.renderer.pm.setDefault(programID, uniformID, value)
  },
  
  setUniform: function(uniformID, value){
      vxl.c.view.renderer.pm.setUniform(uniformID, value)
  },
  
  /**
   * Gets the default value for an uniform 
   */
  getUniformDefault: function(programID, uniformID){
      vxl.c.view.renderer.pm.getDefault(programID, uniformID);
  },
  
  /**
   * Return the uniform names of the current program
   */
  getUniformList: function(){
      return vxl.c.view.renderer.pm._uniformList[vxl.c.view.renderer.pm._currentProgramID].slice(0);
  },
  
  getUniform : function(uniformID){
     return vxl.c.view.renderer.pm.getUniform(uniformID);  
  },
  
  /**
   * <p>Suscribes the to Voxelent events </p>
   * 
   * <p>The context parameter corresponds to the class that is going to listen for Voxelent events.</p>
   * 
   * <p>Such class needs to implement a method to handle the events that it has subscribed to. This method/function needs
   * to have the following signature:</p>
   * 
   * <p><code>handleEvent(event, src)</code></p>
   * 
   * <p> The event parameter corresponds to the event that has been fired by Voxelent. Notice that 
   * your class will only be notified of those events that it has been subscribed to.
   * 
   * @param {String, Array} list the event or events that we are going to subscribe to
   * @param {Object} context the object that needs to implement the handleEvent method
   * 
   */
  subscribe: function(list, context){
  	vxl.go.notifier.subscribe(list, context);
  }
  
 }; 
 /*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/  
/*
* Idea: to use a lightweight pattern. A pool of vxlModels that are reused.
* Every frame the information is copied to the buffers, instead of saving as many gl vbos as models
*/
/**
 * Provides frame-to-frame animation
 * 
 * @class Manages a frame-to-frame animation
 * @constructor
 * @param map  JSON object where each property name is one frame and each property value
 * is a list of actors 
 * var map = {"frame1":["actor1","actor2"], "frame2":["actor3","actor4"]}
 * 
 */
function vxlFrameAnimation(map){
	this.scene             = null;

	this.actorByFrameMap   = [];
	this.activeFrame       = 1;
	this.mark              = 1;
	this._running          = false;
    this.frameCount        = 0;
    this.renderRate        = 500;
    
    this._startDate        = undefined;
    this._time             = 0;
    
    this._setup(map);
    if (vxl.c.animation == null) vxl.c.animation = this;
};

/**
 * The actor will appear in the indicated frame of this animation
 * @param {Number} frame the frame
 * @param {String} actorName the name of the actor. It must exist.
 */
vxlFrameAnimation.prototype.addActorToFrame = function(frame,actorName){
	if (typeof(this.actorByFrameMap[frame])=='undefined'){
		this.actorByFrameMap[frame] = new Array();
	}
	if (this.actorByFrameMap[frame].indexOf(actorName) == -1){
		this.actorByFrameMap[frame].push(actorName);
	}
    if (frame>this.frameCount) this.frameCount = frame;
};

/**
 * Map is a JSON object where each property name is one frame and each property value
 * is a list of actors 
 * 
 * var map = {"frame1":["actor1","actor2"], "frame2":["actor3","actor4"]}
 * @private
 */
vxlFrameAnimation.prototype._setup = function(map){
	this.activeFrame = 1;

	for (var f in map){
		var actorList = map[f];
		var frame = parseInt(f.substr(5,f.length));
		for(var i=0, max = actorList.length; i < max; i+=1){
			this.addActorToFrame(frame,actorList[i]);
		}
	}
	vxl.go.console('FrameAnimation: Setup finished.');
};

/**
 * Starts the animation loop
 * @param {Number} rate the framerate for the animation (optional)
 */
vxlFrameAnimation.prototype.start = function(rate){
	if (this.scene == null) throw 'FrameAnimation: the animation is not associated with any scene. Please use scene.setFrameAnimation method';

    this._startDate = new Date().getTime();
    this._time  = 0;
    this._running = true;
    
    if (rate != undefined && rate >=0){
    	this.renderRate = rate;
    }
    
    this._timeUp();
};


/**
 * Implements a self-adjusting timer
 * @see http://www.sitepoint.com/creating-accurate-timers-in-javascript/
 * @private 
 */
vxlFrameAnimation.prototype._timeUp = function(){
    if (!this._running) return;
    
    this.nextFrame();
    
    if (this._time == this.renderRate * 100){  //for long running animations
        this._time = 0;
        this._startDate = new Date().getTime();
    }
    
    this._time += this.renderRate;

    var diff = (new Date().getTime() - this._startDate) - this._time;
    
    if (diff > this.renderRate) diff = 0; //ignore it
    
    setTimeout((function(self){
        return function(){
            self._timeUp();
        }
    })(this), this.renderRate - diff);
    
};

/**
 * Stops the animation loop
 */
vxlFrameAnimation.prototype.stop = function(){
    this._running = false;
};

vxlFrameAnimation.prototype.setFrameRate = function(rate){
	if (rate <=0) return;
	this.stop();
	this.renderRate = rate;
	this.start();
};


/**
 * Selects the actors that will be visible in the current frame
 */
vxlFrameAnimation.prototype.update = function(){
	
	if (this.scene == null) throw 'FrameAnimation: the animation is not associated with any scene. Please use scene.setFrameAnimation method';
	
	
	//we hide them all first
	this.scene.setPropertyForAll('visible', false);  
	 
	//then we decide which ones are visible
	var currentActors = this.actorByFrameMap[this.activeFrame]
	var NUM = currentActors.length;
	for (var i=0; i<NUM; i++){
		var actor = this.scene.getActorByName(currentActors[i]);
		if (actor != null){
			actor.setVisible(true);
		}
	}
};

/**
 * Verifies if the frame number passed as parameter is in the range of the current animation
 * @param f a frame number
 * @returns true if the number passed as parameter is a valid frame number, false otherwise
 */
vxlFrameAnimation.prototype.isValidFrame = function(f){
 return (f>=1 && f<= this.frameCount);
};

/**
 * Moves the animation to the next valid frame. If the activeFrame is the last frame in the animation, then
 * the animation is reset to the first frame.
 */
vxlFrameAnimation.prototype.nextFrame = function(){
	if (this.activeFrame < this.frameCount){
		this.activeFrame++;
	}
	else{
		this.activeFrame = 1;
	}
};

/**
 * Gets the next n valid frames. Works as a circular buffer.
 */
vxlFrameAnimation.prototype.getNextFrames = function(n){
	var list = [];
	var c = this.activeFrame;
	if (n> this.frameCount) n = this.frameCount;
	for (var i=1; i <=n; i++){
		var next = c + i;
		if (this.isValidFrame(next)){
			list.push(next);
		}
		else{
			list.push(next-this.frameCount);
		}
	}
	vxl.go.console('Animation: next frames: ' + list);
	return list;
};

/**
 * Gets the previous n frames. Works as a circular buffer.
 */
vxlFrameAnimation.prototype.getPreviousFrames = function(n){
	var list = [];
	var c = this.activeFrame;
	if (n> this.frameCount) n = this.frameCount;
	for (var i=1; i <=n; i++){
		var previous = c - i;
		if (this.isValidFrame(previous)){
			list.push(previous);
		}
		else{
			list.push(this.frameCount+previous);
		}
	}
	vxl.go.console('Animation: previous frames: ' + list);
	return list;
};

/**
 * Sets f as the active frame
 * @param f the frame to set as active
 */
vxlFrameAnimation.prototype.setFrame = function (f){
	if (f>=1 && f <= this.frameCount){
		this.activeFrame = f;
		this.render();
	}
};

/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 

/**
 * Reads a VTK file and creates the respective JSON(s) file(s).
 * @class Reads VTK files (ASCII)  and creates JSON objects that can be used as models
 * @constructor 
 */
function vxlVTKReader(scene){

    this.scene      = scene; //the scene that will be updated
    this.ARRAY_SIZE = 65536*3;
    this.vertices   = [];
    this.indices    = [];
    this.normals    = [];
    this.scalars    = [];
    this.colors     = [];
    

    this.mode = "SOLID";

    this.tags = {
        NOWHERE             : 0,    
        POINTS              : 1,
        LINES               : 2,
        POLYGONS            : 3,
        POINT_DATA          : 4,
        NORMALS             : 5,
        CELL_DATA           : 6,
        TEXTURE_COORDINATES : 7,
        SCALARS             : 8,
        LOOKUP_TABLE        : 9,
        COLOR_SCALARS       : 10
    };
    
    this.parts = [];
    
    vxl.go.notifier.publish(vxl.events.READER_DONE, this);
};

/**
 * Verifies if the HTML5 API is available. 
 */
vxlVTKReader.prototype.isSupported = function(){
    return (window.File && window.FileReader && window.FileList && window.Blob);
};


/**
 * @param {File} file an HTML5 File object
 */
vxlVTKReader.prototype.read = function(file){
    var vtkReader = this;
    var filename = file.name;
    
    if (filename.length - 4 !== filename.indexOf('.vtk')){
        throw 'vxlVTKReader.read: the file '+file+' is not a VTK file';
    }
    
    modelname = filename.replace(/\.[^/.]+$/, "");
    var reader = new FileReader();
     
    reader.onload = function(event){
        document.body.style.cursor = 'default';
        var contents = event.target.result.trim();
        var lines = contents.split(/\r\n|\r|\n/);
        vtkReader._parse(lines);  
        vtkReader._processIndexBlocks(modelname);
        vxl.go.notifier.fire(vxl.events.READER_DONE, vtkReader);
    };
    
    document.body.style.cursor = 'wait';
    reader.readAsText(file);
};


/**
 * If the VTK file exists in memory as a String (text) then we can
 * use this method to parse it. 
 * 
 * @param {String} name the name of the object
 * @param {String} text the retrieved object contents
 */
vxlVTKReader.prototype.parseText = function(name, text){
    document.body.style.cursor = 'wait'; 
    var lines = text.split(/\r\n|\r|\n/);
    this._parse(lines);  
    this._processIndexBlocks(name);
    vxl.go.notifier.fire(vxl.events.READER_DONE, this);
    document.body.style.cursor = 'default';
};

/**
 * Reads the file line by line and populates the respective arrays
 */
vxlVTKReader.prototype._parse = function(lines){
   this.outputfile = '';
   this.numBlocks = 0;
   this.location = 'NOWHERE';
   var linenumber = 0;
   for(var linenumber=0; linenumber<lines.length; linenumber++)
   {
    
       try
            {
                if (lines[linenumber].indexOf('POINTS') == 0)
                {
                    console.log(lines[linenumber]);
                    this.location = this.tags.POINTS;
                    continue;
                }
                else if (lines[linenumber].indexOf('LINES') == 0)
                {
                    console.log(lines[linenumber]);
                    this.location = this.tags.LINES;
                    this.mode = "LINES";
                    continue;
                }
                else if (lines[linenumber].indexOf('POLYGONS')==0)
                {
                    console.log(lines[linenumber]);
                    this.location = this.tags.POLYGONS;
                    continue;
                }
                else if (lines[linenumber].indexOf('POINT_DATA')==0)
                {                   
                    this.location = this.tags.POINT_DATA;
                    continue;
                }
                else if (lines[linenumber].indexOf('NORMALS')==0)
                {      
                    console.log(lines[linenumber]);             
                    this.location = this.tags.NORMALS;
                    continue;
                }
                else if (lines[linenumber].indexOf('CELL_DATA')==0)
                {      
                    console.log(lines[linenumber]);             
                    this.location = this.tags.CELL_DATA;
                    continue;
                }
                else if (lines[linenumber].indexOf('TEXTURE_COORDINATES')==0)
                {      
                    console.log(lines[linenumber]);             
                    this.location = this.tags.TEXTURE_COORDINATES;
                    continue;
                }
                else if (lines[linenumber].indexOf('SCALARS')==0)
                {      
                    console.log(lines[linenumber]);             
                    this.location = this.tags.SCALARS;
                    continue;
                }
                else if (lines[linenumber].indexOf('LOOKUP_TABLE')==0)
                {      
                    console.log(lines[linenumber]);             
                    this.location = this.tags.LOOKUP_TABLE;
                    continue;
                }   
                else if (lines[linenumber].indexOf('COLOR_SCALARS')==0)
                {      
                    console.log(lines[linenumber]);             
                    this.location = this.tags.COLOR_SCALARS;
                    continue;
                }           
                // -------------------
                else if(this.location == this.tags.POINTS)
                {
                    var v = lines[linenumber].trim().split(' ');
                    if (v == "") continue;
                    for (var i=0; i<v.length; i++)
                    {
                         this.vertices.push(parseFloat(v[i]));
                    }
                }
                else if(this.location == this.tags.LINES)
                {
                    var tt = lines[linenumber].trim().split(' ');
                    if (tt == "") continue;
                    if(tt.length>0 && tt[0] == '2')
                    {
                        this.indices.push(parseInt(tt[1]));
                        this.indices.push(parseInt(tt[2]));
                    }
                }
               else if(this.location == this.tags.POLYGONS) //they have to be triangles
                {
                    var tt = lines[linenumber].trim().split(' ');
                    if (tt=="") continue; 
                    if(tt.length>0 && tt[0] != '3')
                    {
                        throw "Not triangles here";
                    }
                    for(var i= 1; i<tt.length; i++)
                    {
                        this.indices.push(parseInt(tt[i]));
                    }
                }
                else if(this.location == this.tags.LOOKUP_TABLE)
                {
                    if(lines[linenumber].indexOf('LOOKUP_TABLE')==0)
                        continue;
                    else
                    {
                        var pd = lines[linenumber].trim().split(' ');
                        if (pd=="") continue;
                        for(var i=0; i<pd.length; i++)
                        {
                            this.scalars.push(parseFloat(pd[i]));
                        }
                   }
                }
                else if(this.location == this.tags.COLOR_SCALARS)
                {
                    var n = lines[linenumber].trim().split(' ');
                    if (n=="") continue;
                    for(var i=0; i<n.length; i++)
                    {
                        this.colors.push(parseFloat(n[i]));
                    }
                }
                else if(this.location == this.tags.NORMALS)
                {
                    var n = lines[linenumber].trim().split(' ');
                    if (n=="") continue;
                    for(var i=0; i<n.length; i++)
                    {
                        this.normals.push(parseFloat(n[i]));
                    }
                }
           } // end try
        catch(err)
            {
            console.log('Error while processing line '+ linenumber.toString());
            //console.log(lines) // what is this for??
            throw err;
            }
    }// end foor loop
};

/**
 * Divides the calculated indices into blocks
 * @private
 */
vxlVTKReader.prototype._processIndexBlocks = function(filename){
   this.numBlocks = 0;
   var v_count =  this.vertices.length/3;
   var n_count =  this.normals.length/3;
   var ii_count = this.indices.length;
   var i_count =  ii_count/3;
   var c_count =  this.colors.length/3;
   var pd_count = this.scalars.length;
 
   console.log('vertices:\t' + v_count.toString() +'\nnormals:\t' + n_count.toString() + '\nindices:\t' + ii_count.toString() +'\ntriangles:\t' + i_count.toString() +
             '\nscalars:\t' + pd_count.toString() + '\ncolors:\t'+ c_count.toString()+'\n');
 
    this.numBlocks = parseInt(ii_count/this.ARRAY_SIZE);
    if (ii_count % this.ARRAY_SIZE != 0)
        this.numBlocks  = this.numBlocks + 1;
    console.log( 'Number of Blocks: ' + this.numBlocks.toString());
    
    for(var i=0; i<this.numBlocks; i++){
        this._processBlock(i, filename);
    }
};

/**
 * Process the selected block of indices
 * @private
 */
vxlVTKReader.prototype._processBlock = function(blockID, filename){
    var fid = (blockID + 1).toString();
    var blockname = "";
    
    if (this.numBlocks == 1)
        blockname = filename ;
    else
        blockname = filename + '_' + fid;
        
    var block  = this._weaveBlock(blockID);
    this._writeJSON(blockname, block);
    console.log('Block ['+ fid +'] processed,  output: '+ blockname);
};

/**
 * Calculates the new index array for the block in question
 */
vxlVTKReader.prototype._weaveBlock = function(blockID){

    var lowerBound = this.ARRAY_SIZE*blockID;
    var upperBound = this.ARRAY_SIZE*(blockID+1);

    if (upperBound > this.indices.length){
        upperBound = this.indices.length;
    }
    
    var newindex = {};
    
    var block = {
        vertices: [],   //new vertex array
        indices : [],   //new index array
        scalars : [],   //new scalar array
        colors  : []   //new color array
    };
    
    var hasPointData = (this.scalars.length>0);
    var hasColorData = (this.colors.length>0);
    
    
    // Set of indices to be processed
    var aux = this.indices.slice(lowerBound, upperBound);
    
    taux = aux.length;
    var nidx = -1
    
    
    console.log('Weaving block #' + (blockID+1) + '  ['+ lowerBound+','+upperBound+']');
    
    //for each index to be processed
    for (var i=0; i<taux; i+=1){ 
        //if index hasn't been mapped
        var oidx = aux[i];
        if (newindex[oidx] == undefined){
            nidx++;
            // create new index for the old index (incrementally)
            block.indices.push(nidx);
            // save in the map for posterior searches
            newindex[oidx] = nidx;
            // multiply by three to find the right starting point in the vertex array
            var index = oidx * 3
            // add the correspondent vertex into the new position in the new vertex array
            block.vertices.push(this.vertices[index]);
            block.vertices.push(this.vertices[index+1]);
            block.vertices.push(this.vertices[index+2]);
            // add the correspondent point data if any
            if (hasPointData){
                block.scalars.push(this.scalars[oidx]);
            }
            if (hasColorData){
                block.colors.push(this.colors[index]);
                block.colors.push(this.colors[index+1]);
                block.colors.push(this.colors[index+2]);
            }
        }
        else{
            // if the index was mapped then use it in the new index array
            block.indices.push(newindex[oidx]);
        }
    }
    delete aux;
    return block;

};

/**
 * Creates the JSON object
 * @private 
 */
vxlVTKReader.prototype._writeJSON = function(fname,block){
    
     var jsonPart = new Object();
     
     jsonPart["name"]        = fname;
     jsonPart["vertices"]    = block.vertices.slice(0);
     jsonPart["indices"]     = block.indices.slice(0);
     
     if (block.scalars.length>0){
        jsonPart["scalars"]  = block.scalars.slice(0);
     }
     
     if (block.colors.length >0){
        jsonPart["colors"]   = block.colors.slice(0);
     }
     
     jsonPart["mode"]        = this.mode;
     
     this.parts.push(jsonPart);
};  

/**
 * Once the reader has finished. This method allows retrieving the parsed parts 
 */
vxlVTKReader.prototype.getParts = function(){
    return this.parts;
}/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/ 


/**
 * <p>
 * A vxlTexture is a representation of a raster image in Voxelent. Textures can be loaded providing a
 * URI
 * </p>
 * <p> 
 * To set the magnification and minification filters for a texture please refer to the constants
 * defined in <code>vxl.def.texture.filter</code>. A vxlTexture object uses the <code>min</code> and
 * <code>mag</code> properties to set these filters. For example: </p>
 * 
 * <pre class="prettyprint">
 * var texture = new vxlTexture('iphone_screen.png');
 * texture.min = vxl.def.texture.filter.LINEAR;
 * texture.mag = vxl.def.texture.filter.NEAREST;
 * </pre>
 * 
 * <p>The maginfication and minification filters by default are:
 * vxl.def.texture.filter.LINEAR and vxl.def.texture.filter.LINEAR_MIPMAP_LINEAR respectively    
 * </p>
 * 
 * <p>Under normal circumstances you will not need to create a vxlTexture. An actor representing a model with texture
 * information in it will create a vxlTexture automatically. In this case you can access the available vxlTexture object from the actor like this:</p>
 *  
 * <pre class="prettyprint">
 * var actor = vxl.c.scene.getActorByName('iphone_screen.json');
 * actor.texture.min = [set the filter here using the constants defined in vxl.def.texture.filter]
 * actor.texture.mag = [set the filter here using the constants defined in vxl.def.texture.filter]
 * </pre>
 * 
 * <p>If you want to replace the texture object with a new raster image, you can write something like this:</p>
 * 
 * <pre class="prettyprint">
 * var actor = vxl.c.scene.getActorByName('iphone_screen.json');
 * var wallpaper = new vxlTexture('new_wallpaper.png');
 * actor.setTexture(wallpaper);
 * </pre>
 * @class A vxlTexture is a representation of a raster image in Voxelent. 
 * @constructor
 * @param {String} uri texture location
 * @author Diego Cantor
 */
function vxlTexture(uri){
    var self = this;

    this.image = new Image();
    this.image.onload = function(){
        self._onLoad();
    }
    
    this.image.onError = function(){
        self._onError();
    }
    
    this.uri = uri;
    if (this.uri != undefined){
        this.load(this.uri);
    }
    
    this.mag = vxl.def.texture.filter.LINEAR;
    this.min = vxl.def.texture.filter.LINEAR_MIPMAP_LINEAR;
    this.loaded = false;     
};

/**
 * Sets the magnification filter. 
 * @param {String} magfilter one of the options in vxl.def.texture.filter
 * @see {vxl.def.texture.filter}
 */
vxlTexture.prototype.setMagFilter = function(magfilter){
    this.mag = magfilter;
};

/**
 * Sets the minification filter. 
 * @param {String} minfilter one of the options in vxl.def.texture.filter
 * @see {vxl.def.texture.filter}
 */
vxlTexture.prototype.setMinFilter = function(minfilter){
    this.min = minfilter;  
};

/**
 * Loads an image and it associates it to this texture object
 * @param {Object} uri the location of the image to load into this texture object
 */
vxlTexture.prototype.load = function(uri){
   this.image.src = uri;
};

/**
 * @private
 */
vxlTexture.prototype._onError = function(){
    console.info('vxlTexture: the texture '+this.uri+' could not be found.');
    this.loaded = false;
};

/**
 * @private
 */
vxlTexture.prototype._onLoad = function(){
    this.loaded = true;
};

/**
 * Returns the appropriate gl constant that identifies the current magnification
 * filter applied to this texture
 * @param {Object} gl the gl context
 */
vxlTexture.prototype.getMagFilter = function(gl){
    
  var tf = vxl.def.texture.filter;  
  switch(this.mag){
      case tf.LINEAR: return gl.LINEAR; break;
      case tf.NEAREST: return gl.NEAREST; break;
      default: return gl.NEAREST; 
  }
};

/**
 * Returns the appropriate gl constant that identifies the current minification filter
 * applied to this texture
 * @param {Object} gl the gl context 
 */
vxlTexture.prototype.getMinFilter = function(gl){
    var tf = vxl.def.texture.filter;
    switch(this.min){
      case tf.LINEAR: return gl.LINEAR; break;
      case tf.NEAREST: return gl.NEAREST; break;
      case tf.LINEAR_MIPMAP_LINEAR : return gl.LINEAR_MIPMAP_LINEAR; break;
      case tf.LINEAR_MIPMAP_NEAREST: return gl.LINEAR_MIPMAP_NEAREST; break;
      case tf.NEAREST_MIPMAP_LINEAR: return gl.NEAREST_MIPMAP_LINEAR; break;
      case tf.NEAREST_MIPMAP_NEAREST: return gl.NEAREST_MIPMAP_NEAREST; break;
      default: return gl.NEAREST; 
  }
};

/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/


function vxlMaterial(model){
    this.ambient   = vxl.def.material.ambient;
    this.diffuse   = vxl.def.material.diffuse;
    this.specular  = vxl.def.material.specular;
    this.shininess = vxl.def.material.shininess;
    this.opacity   = vxl.def.material.opacity;
    this.shading   = vxl.def.material.shading;
    this.texture   = undefined;
    this.colors    = undefined;

    if (model){
        this.getFrom(model);
    } 
};

/**
 * 
 * @param {Object} model the model from where the material properties are read
 */
vxlMaterial.prototype.getFrom = function(model){
 
    
    if (model.ambient != undefined)
    {
        this.ambient = model.ambient.slice(0);
    }
    
    if (model.diffuse != undefined){
        this.diffuse = model.diffuse.slice(0) 
    }
    
    if (model.specular != undefined){
        this.specular = model.specular.slice(0);
    }
    
    if (model.color != undefined){
        this.diffuse = model.color.slice(0);
    }
    
    if (model.shininess != undefined){
        this.shininess = model.shininess;
    }
    
    if (model.opacity != undefined){
        this.opacity = model.opacity;
    }
    
    if (model.shading != undefined){
        this.shading = model.shading;
    }
    
    if (model.texture != undefined){
        this.texture = new vxlTexture(model.path + model.texture); 
    }
    
    if (model.colors != undefined){
        this.colors = model.colors;
    }
    
    
};






/**
 * @class A Renderable is an intermediary object between an actor and the rendering strategy that allows rendering
 * very complex models.
 * 
 * Think of this scenario. You have a model that has more than 65K number of vertices.
 * Yes, it is going to happen eventually.
 * 
 * In WebGL you can't do more than 65K indices per draw call. This is because the type of the WebGL index array is unsigned short. 
 * So, a model with more than 65K indices could not be rendered at once.
 * 
 * In previous Voxelent versions (<0.89.3) it was required that a complex model was broken down in several
 * JSON files. This was a way to make sure that each 'part' did not get so big as to be unable to render it.
 * This is, each part had an index array of at most 16k elements.
 * 
 * For example, the VTK to JSON importer (vtk2json) handles this situation and produces parts with index arrays of length = 65K.
 * 
 * However, since version 0.89.2, it is possible to create flat shading models and also to do cell based 
 * picking. This requires generating models where triangles are not shared (so we can do flat shading).
 * Now, if triangles are not shared, then most likely, very complex models are going to surpass the 65K 
 * limit for their index array. 
 * 
 * The renderable object encapsulates a complex model and delivers parts that abide by the 65K index rule.
 * 
 * The renderables are requested internally by vxlRenderEngine whenever a model of BIG_OBJECT or  MESH types
 * need to be rendered.
 * 
 * 
 * 
 * @constructor A Renderable is an intermediary object between an actor and the rendering engine that allows rendering
 * very complex models.
 * 
 * @param{vxlActor} model the actor to be decomposed into renderable parts
  *  
 * @author Diego Cantor
 */

function vxlRenderable(actor){
    
    
    if (actor == undefined){
        throw('vxlRenderable: the actor can not be undefined');
    }
   
    
    this.actor = actor;
    this.parts = [];    
    this.update(vxl.def.renderable.task.CREATE);
}


/**
 *  Updates the renderable based on changes in the underlying model. After updating, the 
 *  renderable parts will contain any changes to the geometry, colors or other model attributes
 *  @param {Boolean} reslice if true, it will recreate the parts. Otherwise will use the current parts
 */
vxlRenderable.prototype.update = function(task){
    
    if (task == undefined){
        throw ("vxlRenderable.update: Please specify a task");
    }

  
    var model  = this.actor.getRenderableModel();
    
    if (model == undefined) return;
    
    switch(model.type){
        case vxl.def.model.type.MESH: this._processMesh(model,task); break;
        case vxl.def.model.type.BIG_DATA: this._processBigData(model,task); break;
    }
   
};

/**
 * This methods creates renderable parts from a mesh. The implementation is straight forward
 * given that a mesh does not share triangles. This is what we need to do flat shading and therefore
 * to perform cell color based picking.
 * 
 * 
 */
vxlRenderable.prototype._processMesh = function(model,task){
    
  

    var size = vxl.def.model.MAX_NUM_INDICES;
    var N = Math.floor(model.indices.length / size), R = model.indices.length % size;
    
    if (task == vxl.def.renderable.task.CREATE){
        
        this.parts = [];
        
        for (var i=0; i<=N; i +=1){
            
            var part = new vxlModel(model.name+'-renderable-part-'+i);
            var startIndex = i*size;
            var endIndex = startIndex + size;
            var start = i * size * 3;
            var end   = start + size *3;
            
            if (i == N) {
                startIndex = N*size;
                endIndex = startIndex + R;
                start = N * size * 3;
                end   = start + R *3;
                
                if (R==0){
                    break;
                }
            }
            
            part.indices = this._reindex(model.indices.slice(startIndex,endIndex));
            part.vertices = model.vertices.slice(start, end);
            
            
            if (model.normals && model.normals.length >0){ part.normals  = model.normals.slice(start, end);  }
            if (model.colors  && model.colors.length >0) { part.colors = model.colors.slice(start, end);     }
            
            if (model.pickingColors){
                part.pickingColors = model.pickingColors.slice(start, end);
            }
            
            part.update();
      
            this.parts.push(part);
        }
    }
    
    
    
    else if (task == vxl.def.renderable.task.UPDATE_COLORS){
        for (var i=0; i<=N; i +=1){
            
            var part = this.parts[i];
            var start = i * size * 3;
            var end   = start + size *3;
            
            if (i == N) {

                start = N * size * 3;
                end   = start + R *3;
                
                if (R==0){
                    break;
                }
            }
          
            if (model.colors  && model.colors.length >0) { part.colors = model.colors.slice(start, end);  }

        }
    }
     
};

/**
 * Return indices starting from 0
 * @param {Object} indices
 */
vxlRenderable.prototype._reindex = function(indices){
    var min = indices.min();
    for(var i=0, N = indices.length; i<N;i+=1){
        indices[i] = indices[i] - min;
    }
    return indices;
}


/***
 * Processing big data 
 * 
 * The idea here is read chunks of size 65K from the model index array. Then obtain vertex, normal, and color
 * arrays for each index in the chunk.
 * After that, the new part index is generated
 * 
 * 
 */
vxlRenderable.prototype._processBigData = function(model,reslice){
    
    
    
    var bigDataIndex = model.indices;
    
    var size = vxl.def.model.MAX_NUM_INDICES;
    
    var N = Math.floor(model.indices.length / size);
    var R = model.indices.length % size;
    
    var material = this.actor.material;
    
    //TODO: Be more clever about the partitioning. The arrays don't need to have 65K in lenght
    //what the specs means is that the max element in the array index is 65K.
    //this is because the index range goes up to 65535 as the highest index.
    
    for (var i=0; i<=N; i +=1){
        
        var part = new vxlModel(model.name+'-renderable-part-'+i);    
        var indexMap = [], localIndexArray = [], globalIndexArray = [], innerIndex = 0;
        
        if (i == N) {
            if ( R > 0){
                globalIndexArray = bigDataIndex.slice(i*size,i*size+R);
             }
             else{
                 break;
             }
        }
        else{
            globalIndexArray = bigDataIndex.slice(i*size,(i+1)*size);
        }
        
        if (material.colors && material.colors.length>0)  {  part.colors = [];   }   
        
        if (model.normals && model.normals.length>0){  part.normals = [];  }
        
        if (model.scalars && model.scalars.length>0){  part.scalars = [];  }
        
        for(var k=0,K = globalIndexArray.length; k<K; k+=1){
            //Get an index from the global index
            var outerIndex  = globalIndexArray[k];
            
            //if it has not been processed then process it.
            //Processing consist into adding data to the respective part arrays
            if (indexMap[outerIndex] == undefined){
                indexMap[outerIndex] = innerIndex;
                
                vertexInfo = this._getBigDataVertexInfo(outerIndex);
                part.vertices.push.apply(part.vertices, vertexInfo.coords);
                if (model.normals && model.normals.length>0){
 
                    part.normals.push.apply(part.normals, vertexInfo.normal);
                }
                if (material.colors && material.colors.length>0){
                    part.colors.push.apply(part.colors, vertexInfo.color);
                }
                if (model.scalars && model.scalars.length>0){
                    part.scalars.push(vertexInfo.scalar);
                }
                innerIndex +=1;
            }
            //write the new index to the part index array
            part.indices.push(indexMap[outerIndex]);
            
        }
        part.update();
        this.parts.push(part);
    }   
};

/**
 * Unlike meshes, Big Data models do not have picking colors associated
 * @param {Object} index
 * @private
 */
vxlRenderable.prototype._getBigDataVertexInfo = function(index){
    
    var material = this.actor.material;
    var model = this.actor.model;
    
    var vertexInfo = {};
    
    vertexInfo.coords = model.vertices.slice(index*3, index*3+3);
    
    if (model.normals){ vertexInfo.normal = model.normals.slice(index*3, index*3+3);}
    if (material.colors){  vertexInfo.color = material.colors.slice(index*3, index*3+3);}
    if (model.scalars){  vertexInfo.scalar = model.scalars[index];}
    
    return vertexInfo;
    
    
};/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/

/**
*  Sometimes it makes sense to associate actors in a scene to perform operations as a unit.
*  For instance you can have a bicycle composed by several actors and you want to change 
*  its color or its position on the scene. You could accomplish that calling the respective
*  methods for each one of the actors that make part of the bicycle or you can create an
*  actor group named bycicle and call just the setColor and translate operations on the actor group.
* 
*  @class
*  @constructor
*  @author Diego Cantor
*/
function vxlActorGroup(scene, name, list){
    this.scene = scene;
    this.name = name;
    this.list = [];
    this.addList(list);
};

/**
 *  Add a list of actors to the actor group
 * @param {Object} list a list of actors
 */
vxlActorGroup.prototype.addList = function(list){
    var messages = [];
    
    for(var i=0, N = list.length; i <N; i+=1){
        var actor = list[i];
        if (actor instanceof vxlActor && actor.scene == this.scene){
            this.list.push(actor);
        }
        else if (typeof(actor) == 'string'){
            var actorObject  = this.scene.getActor(actor);
            if (actorObject != null){
                this.list.push(actorObject);
            }
            else{
                messages.push("Could not find actor: "+actor);
            }
        }
        else{
            messages.push("The object "+actor+" is not of the expected type (vxlActor, string)");
        }
    }
    
    if (messages.length != 0){
        this.list = [];
        throw new vxlActorGroupException(messages);
    }
    
}

/**
* Adds one actor to the actor group
* @param {vxlActor} actor the actor to be added
*/
vxlActorGroup.prototype.add = function(actor){
    var messages = [];

    if (actor instanceof vxlActor && actor.scene == this.scene){
        this.list.push(actor);
    }
    else if (typeof(actor) == 'string'){
        var actorObject  = this.scene.getActor(actor);
        if (actorObject != null){
            this.list.push(actorObject);
        }
        else{
            messages.push("Could not find actor: "+actor);
        }
    }
    else{
        messages.push("The object "+actor+" is not of the expected type (vxlActor, string)");
    }
    
    if (messages.length != 0){
        this.list = [];
        throw new vxlActorGroupException(messages);
    }
};

/**
 * Returns true if the actor is associated to this actor group. False otherwise
 */
vxlActorGroup.prototype.hasActor = function(actor){
    if (actor instanceof vxlActor){
        return (this.list.indexOf(actor)!=-1)
    }
    else if (typeof(actor)=='string'){
        var actorObject = this.scene.getActor(actor);
        return (actorObject != null);
    }
    
    else return false;
}

vxlActorGroup.prototype.remove = function(actor){
    var index = -1;
    if (actor instanceof vxlActor){
        index = this.list.indexOf(actor);
        
    }
    else if (typeof(actor)=='string'){
        actorObject = this.scene.getActor(actor);
        index = this.list.indexOf(actorObject);
    }   
   
    if (index !=1){
        this.list.splice(index,1);
    }
    else{
        throw new vxlActorGroupException(['the actor '+actor+' was not found in the group '+this.name]);
    }
};


/**
 * Returns the size of the actor group
 * @returns {Number} the lenght of the actor group
 */
vxlActorGroup.prototype.size = function(){
    return this.list.length;
};

/**
 * Set a property for actors in the group. Please notice that by design actor groups only 
 * set actor level properties instead of model level properties.
 * 
 */
vxlActorGroup.prototype.setProperty = function(property, value){
    for(var i=0, N = this.list.length; i<N; i+=1){
        this.list[i].setProperty(property,value,vxl.def.actor);
    }
    
    return this;
};

/**
 * Invoke an operation on the actors belonging to this group
 * @param {function} operation from vxlActor.prototype
 * @param {list} parameters
 */
vxlActorGroup.prototype._apply = function(operation, parameters){
   for(var i=0, N = this.list.length; i<N; i+=1){
        operation.apply(this.list[i], parameters);
    };
    
    return this;
};

/**
 * Flip normals
 */
vxlActorGroup.prototype.flipNormals = function(){
    return this._apply(vxlActor.prototype.flipNormals);
};

/**
 * Rotation on the X axis
 * @param {float} angle angle in degrees
 */
vxlActorGroup.prototype.rotateX = function(angle){
    return this._apply(vxlActor.prototype.rotateX, [angle]);
};

/**
 * Rotation on the Y axis
 * @param {float} angle angle in degrees
 */
vxlActorGroup.prototype.rotateY = function(angle){
    return this._apply(vxlActor.prototype.rotateY, [angle]);
};

/**
 * Rotation on the Z axis
 * @param {float} angle angle in degrees
 */
vxlActorGroup.prototype.rotateZ = function(angle){
    return this._apply(vxlActor.prototype.rotateZ, [angle]);
};

/**
 * Translation by a given vector
 */
vxlActorGroup.prototype.translate = function(x,y,z){
    return this._apply(vxlActor.prototype.translate, [x,y,z]);
};

/**
 * Sets the material diffuse color of the group
 * @param {list} color in rgb decimal format
 */
vxlActorGroup.prototype.setColor = function(color){
    return this.setProperty('color',color);
};

/**
 * Sets the lookup table for this group
 */
vxlActorGroup.prototype.setLookupTable = function(lutID, min, max){
    return this._apply(vxlActor.prototype.setLookupTable, [lutID, min,max]);
};

/**
 * Sets the opacity for this group
 */
vxlActorGroup.prototype.setOpacity = function(opacity){
    return this.setProperty('opacity', opacity);
};

/**
 * Sets the picker for this group
 * @see {vxlActor#setPicker}
 */
vxlActorGroup.prototype.setPicker = function(type, callback){
    return this._apply(vxlActor.prototype.setPicker,[type,callback]);
};

/**
 * Sets the position for this group
 * @see {vxlActor#setPosition}
 */
vxlActorGroup.prototype.setPosition = function(x,y,z){
    return this._apply(vxlActor.prototype.setPosition,[x,y,z]);
};

/**
 * Sets the scale for this group
 * @see {vxlActor#setScale}
 */
vxlActorGroup.prototype.setScale = function(x,y,z){
    return this._apply(vxlActor.prototype.setScale,[x,y,z]);
};

/**
 * Sets the shininess for this group
 * @see {vxlActor#setShininess}
 */
vxlActorGroup.prototype.setShininess = function(shine){
    return this.setProperty('shininess', shine);
};

/**
 * Sets the visibility for this group
 * @see {vxlActor#setVisibility}
 */
vxlActorGroup.prototype.setVisible = function(visible){
    return this.setProperty('visible', visible);
};


/**
 *  Sets the shading for this group
 * @see {vxlActor#setShading}
 */
vxlActorGroup.prototype.setShading = function(shading){
    return this.setProperty('shading', shading);
};

/**
 * Sets the visualization mode for this group
 * @see {vxlActor#setVisualizationMode}
 */
vxlActorGroup.prototype.setVisualizationMode = function(mode){
    return this._apply(vxlActor.prototype.setVisualizationMode, [mode]);
};




/**
 * Contains the explanation of why the actor group could not be created
 * @class
 * @author Diego Cantor
 */
function vxlActorGroupException(messages){
    this.messages = messages;
};
