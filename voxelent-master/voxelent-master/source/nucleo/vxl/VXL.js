/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   
try{
    if (!jQuery){
    	alert('Voxelent: jQuery is not loaded. Please include JQuery in your page');	
    }
}catch(e){
    alert('Voxelent: jQuery is not loaded. Please include JQuery in your page');
}


/**
* <p>Contains all the constants and default variables used by Voxelent.</p> 
* 
* <p> These properties aregrouped into sub namespaces. 
* The <code>vxl.c</code> namespace covers all the 'current' objects such as the 
* <i>current view</i> and the <i>current scene</i>.</p>
* <p>The <code>vxl.def</code> namespace contains all the definitions and default values for 
* voxelent's global parameters</p> 
* <p>The <code>vxl.events</code> namespace contains all the events used in Voxelent</p>
* <p>The <code>vxl.go</code> namespace contains all the 'global' objects. These are objects that
* can be accessed from any context in a Voxelent program</p>
* <p>The <code>vxl.version</code> namespace simply informs the version of the current Voxelent platform</p> 
* 
* @namespace Voxelent Main Namespace
* @property {vxl.c}         c           current objects
* @property {vxl.def}       def         definition objects
* @property {vxl.events}    events      events generated by voxelent
* @property {vxl.go}        go          global objects
* @property {vxl.version}   version     version
* 
*/
var vxl = {

/**
* Version
* @namespace Voxelent Version
* @property {String} number         the number of the current version
* @property {String} codename       the codename of the current version
* @property {Array}  plugins        installed plugins if any
*/
version : 
{
    number: '0.89.5',
   	codename : 'c4n314',
   	plugins  : []
},

/**
 * @namespace Voxelent Default/Definition Objects
 * @property {vxl.def.essl}     essl    ESSL constants
 * @property {vxl.def.lut}      lut     Lookup Table Definitions
 * @property {vxl.def.model}    model   Default          values for models
 * @property {vxl.def.view}     view    Default values for views 
 * 
 */
def : {
  
    /**
     * Pi divided by 2
     */
    piOver2: Math.PI /2,
    /**
     * Multiplicative constant to convert degrees to radians
     */
    deg2rad : Math.PI / 180,
    /**
     * Multiplicative constant to convert radians to degrees 
     */
    rad2deg : 180 / Math.PI,
    /**
     * Used mainly by <code>vxlRenderEngine</code> and its descendents
     * @namespace GLSL constants
     * @property {String} VERTEX_SHADER Vertex Shader Id
     * @property {String} FRAGMENT_SHADER Fragment Shader Id
     * @property {String} MODEL_VIEW_MATRIX  the model view matrix Id
     * @property {String} NORMAL_MATRIX the normal matrix Id
     * @property {String} PERSPECTIVE_MATRIX the perspective matrix Id
     * @property {String} MVP_MATRIX the model view perspective matrix Id
     * @property {String} VERTEX_ATTRIBUTE the vertex attribute Id
     * @property {String} NORMAL_ATTRIBUTE the normal attribute Id
     * @property {String} COLOR_ATTRIBUTE the color attribute Id
     * @property {JSON} blender The program to render blender scenes
     * @property {JSON} lambert The program to render scenes without specular reflections
     * @property {JSON} phong The program to render scenes with specular reflections
     * @property {JSON} bake The program that interleaves buffers for optimized rendering
     */
	essl			: { 
						VERTEX_SHADER   	: 'VERTEX_SHADER',
						FRAGMENT_SHADER 	: 'FRAGMENT_SHADER',
						MODEL_VIEW_MATRIX  	: 'mModelView',
						NORMAL_MATRIX   	: 'mNormal',
						PERSPECTIVE_MATRIX 	: 'mPerspective',
						MVP_MATRIX          : 'mModelViewPerspective',
						VERTEX_ATTRIBUTE    : 'aVertexPosition',
						NORMAL_ATTRIBUTE    : 'aVertexNormal',
						COLOR_ATTRIBUTE     : 'aVertexColor',
						TEXCOORD_ATTRIBUTE  : 'aVertexTextureCoords'
					},
    /** 
     * @namespace Lookup Table Definitions 
     * @property {Array}       list         List of lookup tables available
     * @property {String}      main         Lookup table loaded by default
     */                
	lut             : {
             
						list : ["default","aal","autumn","blackbody","bone","brodmann","cardiac",
								"copper","cortex","cte","french","fs","ge_color","gold","gooch",
								"hot","hotiron","hsv","jet","nih","nih_fire","nih_ice","pink",
								"rainramp","spectrum","surface","x_hot","x_rain"],
                              
						main:"default"

				    },
	/**
    * @namespace Default values for models
    */
	model			: {
	                   
						/** 
						 *  Enumeration with the different loading modes provided for models
						 * <ul>
                         * <li><code>LIVE</code>: Each asset is added to the scene as soon as it is downloaded</li>
                         * <li><code>LATER</code>: The assets are added to the scene only when ALL of them have been downloaded</li> 
                         * <li><code>DETACHED</code>: The assets are never added to the scene. The programmer decides when to do this.</li> 
                         * </ul> 
                         * 
                         * These modes can be used with {@link vxl.api.load} and with {@link vxlScene.setLoadingMode}
                         */
                         loadingMode     : { LIVE:'LIVE', LATER:'LATER', DETACHED:'DETACHED'},
                         /**
                          * Maximum number of indices per model (Unsigned Short range) 
                          */
                         MAX_NUM_INDICES: 65535,
                         /**
                          * Types of models
                          * <ul>
                          * <li><code>SIMPLE</code>: The model is rendered at all once
                          * <li><code>MESH</code>: This model represents a mesh (no shared triangles). Flat shading is required
                          * <li><code>BIG_DATA</code>: This model is complex and it may required several rendering cycles.
                          */
                         type :{SIMPLE:'SIMPLE', MESH:'MESH', BIG_DATA:'BIG DATA'}
					},

    material        : {
                       /**
                        * Diffuse color used by default when a model does 
                        * not have diffuse color information: [0.8,0.8,0.8,1.0] 
                        */ 
                        diffuse: [0.8,0.8,0.8,1.0],
                        /**
                        * Ambient color used by default when a model 
                        * does not have ambient color information: [0.0,0.0,0.0,1.0] 
                        */
                        ambient: [0.0,0.0,0.0,1.0],
                        /**
                        * Specular color used by default when a model 
                        * does not have specular color information: [0.0,0.0,0.0,1.0] 
                        */
                        specular: [0.0,0.0,0.0,1.0],
                        /**
                        * Shininess used by default when a model 
                        * does not have shininess information: 0 
                        */
                        shininess : 0.0,
                        /**
                        * Opacity used by default when a model 
                        * does not have opacity information: 0 
                        */
                        opacity : 1.0,
                        /**
                        * Shading used by default when a model 
                        * does not have shading information: 0 
                        */
                        shading : true
    },				
    /**
    * @namespace Default values for views
    * @property {Array} background  A 4-valued array that contains the default background colour for view. The format is [r,g,b,a]
    */
    view			: {
    					background: [135/256,135/256,135/256]
    					
    				},	
    /**
     *@namespace Default values for view interactors 
     */ 				
    interactor :{
                        /** 
                         * 
                         * Enumeration of common camera tasks
                         * 
                         * <p>The camera tasks can be:
                         * <ul>
                         * <li><code>NONE</code></li>
                         * <li><code>PAN</code></li> 
                         * <li><code>ROTATE</code></li> 
                         * <li><code>DOLLY</code></li>
                         * <li><code>ROLL</code></li>
                         * </ul>
                         * </p>
                         *  These constants are used internally and you probably would never need to use them.
                         */
                        task      : { NONE : 0, PAN : 1, ROTATE : 2, DOLLY : 3, ROLL : 4}
    },     						      
	/**
    * Contains the constants and default values that can be associated with <code>vxlActor</code>
    * 
    * @namespace Default values and constants that can be used with the <code>vxlActor</code> class.
    */
	actor			: {
                        /**
                         * <p>Defines the visualization modes available for instances of vxlActor</p> 
                         * <p>The visualization  modes can be:
                         * <ul>
                         * <li><code>TEXTURED</code>: Used when the model associated with this actor has a texture</li>
                         * <li><code>SOLID</code></li>
                         * <li><code>WIREFRAME</code></li> 
                         * <li><code>POINTS</code></li> 
                         * <li><code>LINES</code></li>
                         * <li><code>BOUNDING_BOX</code> (added in 0.88.1)</li>
                         * <li><code>BB_AND_SOLID</code> (added in 0.89)</li>
                         * <li><code>WIRED_AND_SOLID</code> (added in 0.89.1)</li>
                         * <li><code>FLAT</code> (added in 0.89.1)</li>
                         * </ul>
                         * </p>
                         * <p> to set the actor mode you should use the <code>{@link vxlActor#setVisualizationMode}</code>
                         *  For instance, if you want to visualize the wireframe of your actor you can do something like this:
                         * </p>
                         *  <pre class='prettyprint'>
                         *  var actor = vxl.c.scene.getActorByName('example.json'); //from the current scene
                         *  actor.setVisualizationMode(vxl.def.actor.mode.WIREFRAME)
                         * </pre>
                         * @see vxlActor#setVisualizationMode
                         */
						mode: {	
						        TEXTURED:'TEXTURED', 
						        SOLID:'SOLID', 
						        WIREFRAME:'WIREFRAME', 
						        POINTS:'POINTS', 
						        LINES:'LINES', 
						        BOUNDING_BOX:'BOUNDING_BOX',
						        BB_AND_SOLID:'BBANDSOLID',
						        WIRED_AND_SOLID:'WIRED_AND_SOLID',
						        FLAT:'FLAT',
						 },
						 /**
						  *  <p>Defines the culling modes available for instances of vxlActor</p> 
                          *  <p>These modes can be BACK,FRONT or NONE</p>
                          *  <pre class='prettyprint'>
                          *   var actor = vxl.c.scene.getActorByName('sphere'); //from the current scene
                          *   actor.cullFace(vxl.def.actor.cull.BACK); //hides the back face.
                          *  </pre>
						  */
						 cull:{
						     BACK:'BACK',
						     FRONT:'FRONT',
						     NONE:'NONE'
						 },
						 
						 /**
						  * <p>Defines the picking modes available for <code>vxlActor</code></p> 
						  */
						 picking: {
						     DISABLED:'DISABLED',
						     CELL:'CELL',
						     OBJECT:'OBJECT'
						 }
						
					},
	/**
	 * Defines the constants that can be used with <code>vxlCamera</code> 
	 *
     * @namespace Default values for cameras
     */
	camera          : {
                        
                        /** 
                         * Camera type available
                         * 
                         * <p>The camera type can be:
                         * <ul>
                         * <li><code>ORBITING</code>: Orbiting Camera - Around the World</li>
                         * <li><code>DYNAMIC</code>: Camera axes are updated on every rotation</li> 
                         * <li><code>TRACKING</code>: Tracking Camera - First Person Camera</li> 
                         * </ul>
                         * </p>
                         * 
                         * <p> These modes can be used with the {@link vxlCamera vxlCamera constructor} or with its {@link vxlCamera#setType setType} method</p>
                         */
    					type      : { ORBITING: 'ORBITING', TRACKING : 'TRACKING', EXPLORING: 'EXPLORING'},
    					/**
    					 * Right vector constant: [1,0,0] 
    					 */
    					right     : [1,0,0],
    					/**
    					 * Up vector constant: [0,1,0] 
    					 */
    					up        : [0,1,0],
    					/**
    					 * Camera axial or normal vector constant: [0,0,1] 
    					 */
    					normal    : [0,0,1],
    					/**
    					 * Default field of view value: 30 
    					 */
    					fov       : 30,
    					/**
    					 * Default value for the near field: 0.1 
    					 */
    					near      : 0.1,
    					/**
    					 * Default value for the far field: 10000 
    					 */
    					far       : 10000,
    					/**
                         * <p>Defines the tracking modes available for instances of vxlCamera</p>
                         * <p>A tracking mode is <u>only</u> required when the camera is set to follow an 
                         * actor using <code>{@link vxlCamera#follow}</code></p> 
                         * <p>The tracking  modes can be:
                         * <ul>
                         * <li><code>DEFAULT</code>:  The camera does not follow an actor. Controlled by the user to look around the world.</li>
                         * <li><code>ROTATIONAL</code>: The camera does not move but follows an actor position</li>
                         * <li><code>TRANSLATIONAL</code>: The camera moves with the actor, the angle is constant</li> 
                         * <li><code>CINEMATIC</code>: Similar to ROTATIONAL but allowing camera roll for a more dramatic effect</li>
                         * </ul>
                         * </p>
                         * <p> to set the tracking mode of the camera <code>myCamera</code> you should make sure that your camera is of tracking type with:
                         *  <code>myCamera.setType(vxl.def.camera.type.TRACKING)</code>.
                         *  For instance:
                         * </p>
                         *  <pre class='prettyprint'>
                         *  var actor = vxl.api.getActor('cone'); //from the current scene
                         *  var camera = vxl.c.camera;
                         *  camera.setType(vxl.def.camera.type.TRACKING);
                         *  camera.setTrackingMode(vxl.def.camera.tracking.ROTATIONAL);
                         *  camera.follow(actor);
                         * </pre>
                         * <p> a shorter way would be:</p>
                         * <pre class='prettyprint'>
                         *  var actor = vxl.api.getActor('cone'); //from the current scene
                         *  var camera = vxl.c.camera;
                         *  camera.setType(vxl.def.camera.type.TRACKING);
                         *  camera.follow(actor, vxl.def.camera.tracking.ROTATIONAL);
                         * </pre>
                         * @see vxlCamera#follow, vxlCamera#setTrackingMode
                         */
                        tracking: {
                              DEFAULT:'DEFAULT',
                              ROTATIONAL:'ROTATIONAL',
                              TRANSLATIONAL:'TRANSLATIONAL',
                              CINEMATIC: 'CINEMATIC'   
                        }
					},
				 	
    /**
    * @namespace Default values for renderers
    * @property {vxl.def.renderer.mode} mode The rendering mode
    * @property {vxl.def.renderer.rate} rate The rendering rat
    */
	renderer 		: {
			        mode: { TIMER:'TIMER', ANIMFRAME:'ANIFRAME'}, //EXPERIMENTAL NOT WAY TO CANCEL YET },
			        rate : { SLOW: 10000,  NORMAL: 500 }
	},
	
	renderable      :{
	                 task :{CREATE:'CREATE', 
	                        UPDATE_GEOMETRY:'UPDATE_GEOMETRY',
	                        UPDATE_COLORS:'UPDATE_COLORS'}
	    
	},
					
	/**
	 * @namespace Constants to handle textures 
	 * @property {vxl.def.texture.filter} filter The different filters applicable to textures
	 */
	texture : {
	    filter:{
    	    NEAREST:'NEAREST',
    	    LINEAR:'LINEAR',
    	    NEAREST_MIPMAP_NEAREST:'NEAREST_MIPMAP_NEAREST',
    	    LINEAR_MIPMAP_NEAREST:'LINEAR_MIPMAP_NEAREST',
    	    NEAREST_MIPMAP_LINEAR:'NEAREST_MIPMAP_LINEAR',
    	    LINEAR_MIPMAP_LINEAR:'LINEAR_MIPMAP_LINEAR'
	    }
	}
},

/**
* Congregates all the events fired by Voxelent
* 
* These events are registered with the vxlNotifier
* 
* @namespace Voxelent Events
* @property {String} DEFAULT_LUT_LOADED fired when the default lookup table is loaded
* @property {String} SCENE_UPDATED fired by vxlScene when an actor is added to the scene
* @property {String} MODELS_LOADED fired by vxlModelManager after loading a set of models
* @property {String} MODEL_NEW fired by the vxlModel constructor
* @property {String} ACTOR_MOVED fired by vxlActor when that actor instance is moved
* @property {String} ACTOR_SCALED fired by vxlActor
* @property {String} ACTOR_CHANGED_COLOR fired by vxlActor
* @property {String} ACTOR_CHANGED_SHADING fired by vxlActor
* @property {String} VIEW_NEW fired by the vxlView constructor
* @property {String} SCENE_NEW fired by the vxlScene constructor
* @property {String} READER_DONE fired when a reader is done reading window.File(s)
* @see {vxlNotifier}
*/
events : {
	DEFAULT_LUT_LOADED 	   : 'vxl.events.DEFAULT_LUT_LOADED',
	SCENE_UPDATED		   : 'vxl.events.SCENE_UPDATED',
	MODELS_LOADING         : 'vxl.events.MODELS_LOADING',
	MODEL_NEW              : 'vxl.events.MODEL_NEW',
	MODELS_LOADED		   : 'vxl.events.MODELS_LOADED',
	ACTOR_MOVED            : 'vxl.events.ACTOR_MOVED',
	ACTOR_SCALED           : 'vxl.events.ACTOR_SCALED',
	ACTOR_ROTATED          : 'vxl.events.ACTOR_ROTATED',
	ACTOR_CHANGED_COLOR    : 'vxl.events.ACTOR_CHANGED_COLOR',
	ACTOR_CHANGED_SHADING  : 'vxl.events.ACTOR_CHANGED_SHADING',
	VIEW_NEW               : 'vxl.events.VIEW_NEW',
	SCENE_NEW              : 'vxl.events.SCENE_NEW',
	READER_DONE            : 'vxl.events.READER_DONE'
},


/**
* @namespace Voxelent Global Objects
*
*/
go : {
    debug 	 		    : false,					  
    notifier            : undefined,
    modelManager        : undefined,
    lookupTableManager  : undefined,
    views               : [],
    scenes              : [],
    essl : {},
    renderman : {

		_timid : 0,
		_rates : [],
		_stop  : false,
		
		render : function(){
			for(var i=0; i<vxl.go.views.length;i+=1){
				vxl.go.views[i].renderer.render();
			}
			if (vxl.go.renderman._stop != true){
			 vxl.go.renderman._timid = window.requestAnimFrame(vxl.go.renderman.render);
			}
			else{
			    vxl.go.renderman._stop = false;
			}
		},
		
		cancel : function(){
		    vxl.go.renderman._stop = true;
		},
		
		slow : function(){
			/*vxl.go.renderman._rates = [];
			for(var i = 0; i < vxl.go.renderman._views.length; i++){
			    if (vxl.go.renderman._views[i].renderer.mode == vxl.def.renderer.mode.ANIMFRAME) continue;
				vxl.go.console('vxl.go.slowRendering: slow rendering on view '+vxl.go.renderman._views[i].name,true);
				vxl.go.renderman._rates.push(vxl.go.renderman._views[i].renderer.renderRate);
				vxl.go.renderman._views[i].renderer.setRenderRate(vxl.def.renderer.rate.SLOW);
			}*/
		},
		
		normal : function(){
			/*for(var i = 0; i < vxl.go.renderman._views.length; i++){
			    if (vxl.go.renderman._views[i].renderer.mode == vxl.def.renderer.mode.ANIMFRAME) continue;
				vxl.go.console('vxl.go.normalRendering: go back to normal rendering on view '+vxl.go.renderman._views[i].name,true);
				if (vxl.go.renderman._rates[i] != undefined){
				    vxl.go.renderman._views[i].renderer.setRenderRate(vxl.go.renderman._rates[i]);
				}
			}*/
		}
	},
	
	console : function(txt,flag) { 
		if (this.debug == true || flag){
			console.info(txt);
		}
	}
	
},

/**
* @namespace Voxelent Current Objects
* @property {vxlScene}          scene       the current scene
* @property {vxlView}           view        the current view
* @property {vxlCamera}         camera      the current camera
* @property {vxlActor}          actor       the current actor
* @property {vxlFrameAnimation} animation   the current animation
*/
c : {
	scene		: undefined,
	view		: undefined,
	camera 		: undefined,
	actor		: undefined,  
	animation 	: undefined
},
/**
 * Utility functions
 * @namespace Voxelent Util methods
 * 
 */
util : {
    
    isMac: function(){
        return navigator.platform.toUpperCase().indexOf("MAC") != -1;
    },
    /**
     *Returns a RGB color based on an integer (0..16 millions?) 
     */
    int2rgb: function(i){
        return [((i >> 16) & 0xFF)/256,((i >> 8) & 0xFF)/256,(i & 0xFF)/256]; 
    },
    
    /**
     * This function is attributed to Tim Down
     * @link{http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb} 
     */
    hex2rgb: function(hex){
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
             parseInt(result[1], 16),
             parseInt(result[2], 16),
             parseInt(result[3], 16)
        ] : null;
    },
    /**
     * Rescales the color from [0,255] to [0,1]
     * WebGL uses [0,1] range 
     */
    rgb2decimal : function(rgb){
        if (rgb == null || rgb == undefined) return null;  
        return [rgb[0]/255, rgb[1]/255,rgb[2]/255];   
    },
    
    createColor : function(r,g,b){
        var color = [];
        if (r == undefined) {
            return null;
        }
        
        if (r instanceof Array){
            var c = r.slice(0);
            r = c[0];
            g = c[1];
            b = c[2];
        }
        
        if (typeof(r) == 'string'){
            color = this.rgb2decimal(this.hex2rgb(r)); 
        }
        else if (typeof(r) == 'number'){
            if (r <0 || g == undefined || b == undefined || g <0 || b <0){
                return null; //invalid color
            }
            else if (r>1 || g>1 || b>1){
                color = this.rgb2decimal([r,g,b]);
            }
            else{
                color = [r,g,b]
            }
        }
        
        return color;
    },
    /**
     * Formats Arrays, vec3 and vec4 for display
     * 
     * @param {Array, vec3, vec4} arr the object to format
     * @param {Number} digits the number of decimal figures
     */
	format: function(arr, digits){
		var p = Math.pow(10,digits);
		if (typeof(arr) == 'object'){
			
			var result = '['; 
			for (var i=0; i < arr.length-1; i+=1){
				result  += Math.round(arr[i] * p) / p + ', '; 
			}
			result += Math.round(arr[arr.length-1] * p) / p  + ']'
		}
		else if (typeof(arr) == 'number'){
			result = '[' + Math.round(arr * p) / p  + ']';
		}
		return result;
	},
	
	/**
	 * Creates a vector from a set of parameters
	 * @param {Array, vec3, Number} x it can be an Array, a vec3 or a number
	 * @param {Number} y if x is a number, this parameter corresponds to the y-component
	 * @param {Number} z if x is a number, this parameter corresponds to the z-component
	 */
	createVec3: function(x,y,z){
	    var vvv = vec3.create();
	    if (x instanceof Array){
            vec3.set(vec3.create(x), vvv)
        }
        else if (x instanceof determineMatrixArrayType()){
            vec3.set(x, vvv)
        }
        else{
            vec3.set(vec3.createFrom(x,y,z), vvv);
        }
        return vvv;
	},
	/**
     * Creates an array from a set of parameters
     * @param {Array, vec3, Number} x it can be an Array, a vec3 or a number
     * @param {Number} y if x is a number, this parameter corresponds to the y-component
     * @param {Number} z if x is a number, this parameter corresponds to the z-component
     */
	createArr3: function(x,y,z){
	    var vvv = []
        if (x instanceof Array || x instanceof determineMatrixArrayType()){
            vvv[0] = x[0];
            vvv[1] = x[1];
            vvv[2] = x[2];
        }
        else{
            vvv[0] = x;
            vvv[1] = y;
            vvv[2] = z;
        }
        return vvv;
	},
	
	generateUID: function(){
	       function S4() {
                return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
            }
        return (S4()+"-"+S4()+"-"+S4()+"-"+S4());
    },
    
    extend : function(){
      var ret = {};
      var len = arguments.length;
      for (var i=0; i<len; i++) {
        for (p in arguments[i]) {
          if (arguments[i].hasOwnProperty(p)) {
            ret[p] = arguments[i][p];
          }
        }
      }
      return ret;
    },
    
    getPath : function(path){
        if (path ==undefined || path == null) {
            return "";
        }
        else if (path.length - 1 == path.lastIndexOf('/')){
            return path;
        }
        else if (path.lastIndexOf('.') > path.lastIndexOf('/')){
            return path.substring(0, path.lastIndexOf('/')+1)
        }
        else   
            return path + '/';
    },
    /**
     * Returns an angle between 0 and 360 deg
     * @param{Number} angle the angle 
     */
    getAngle: function(angle){
        if (angle > 360 || angle <-360) {
            return angle % 360;
        }
        else return angle;
    },
    /**
     *Converts degrees to radians
     * @param{Number} deg angle in degrees 
     */
    deg2rad: function(deg){
        return deg * Math.PI / 180;
    }
    
}

};

Array.prototype.max = function(){
    if (this.length > 65535){
       var max = this[0];
       for(var i=0,N = this.length; i <N; i+=1){
           if (this[i] > max){
               max = this[i];
           }
       }
       return max; 
    }
    else{
	   return Math.max.apply(null, this);
	}
};

Array.prototype.min = function(){
	if (this.length > 65535){
       var min = this[0];
       for(var i=0,N = this.length; i <N; i+=1){
           if (this[i] < min){
               min = this[i];
           }
       }
       return min; 
    }
    else{
       return Math.min.apply(null, this);
    }
};




Array.prototype.hasObject = (
  !Array.indexOf ? function (o)
  {
    var l = this.length + 1;
    while (l -= 1)
    {
        if (this[l - 1] === o)
        {
            return true;
        }
    }
    return false;
  } : function (o)
  {
    return (this.indexOf(o) !== -1);
  }
);

window.requestAnimFrame = (function(){
    return  window.requestAnimationFrame       || 
        window.webkitRequestAnimationFrame || 
        window.mozRequestAnimationFrame    || 
        window.oRequestAnimationFrame      || 
        window.msRequestAnimationFrame     || 
        function(/* function */ callback, /* DOMElement */ element){
            return window.setTimeout(callback, 1000 / 60);
        };
})();

window.cancelRequestAnimFrame = ( function() {
    return window.cancelAnimationFrame          ||
        window.webkitCancelRequestAnimationFrame    ||
        window.mozCancelRequestAnimationFrame       ||
        window.oCancelRequestAnimationFrame     ||
        window.msCancelRequestAnimationFrame        ||
        clearTimeout
})();


//$(window).bind('focus', vxl.go.renderman.normal);
//$(window).bind('blur', vxl.go.renderman.slow);
